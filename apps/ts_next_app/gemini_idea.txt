/**
 * IframeAgentSandbox.ts
 * A secure execution environment for AI Agents using Iframe + Proxy Membrane.
 */

export interface SandboxOptions {
  timeoutMs?: number; // Time before we consider the script "frozen"
  allowedGlobals?: Record<string, any>; // APIs exposed to the agent
}

export class AgentSandbox {
  private iframe: HTMLIFrameElement | null = null;
  private timeoutMs: number;
  private allowedGlobals: Record<string, any>;

  constructor(options: SandboxOptions = {}) {
    this.timeoutMs = options.timeoutMs || 5000;
    this.allowedGlobals = options.allowedGlobals || {};
  }

  /**
   * Executes code in a isolated iframe and returns the result.
   */
  async execute(code: string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.iframe = document.createElement("iframe");
      
      // 1. Security: 'allow-scripts' only. 
      // NO 'allow-same-origin' means origin is null (total isolation).
      this.iframe.setAttribute("sandbox", "allow-scripts");
      this.iframe.style.display = "none";
      document.body.appendChild(this.iframe);

      // 2. Setup the Proxy Membrane
      const membrane = this.createMembrane({
        ...this.allowedGlobals,
        console: {
          log: (...args: any[]) => console.log("[Agent Log]:", ...args),
          error: (...args: any[]) => console.error("[Agent Error]:", ...args),
        },
        resolve: (val: any) => {
          this.cleanup();
          resolve(val);
        },
      });

      // 3. Attach membrane to window so iframe can find it via parent
      // Note: Because of unique origin, the iframe can't 'see' this via window.parent
      // unless we provide a specific bridge.
      (window as any).__SANDBOX_BRIDGE = membrane;

      // 4. Generate the payload
      // We use 'with(sandbox)' to trap all variable access in the proxy.
      const srcDoc = `
        <!DOCTYPE html>
        <html>
          <body>
            <script>
              (function() {
                const sandbox = window.parent.__SANDBOX_BRIDGE;
                try {
                  with (sandbox) {
                    (async function() {
                      try {
                        ${code}
                      } catch (e) {
                        console.error(e);
                      }
                    })();
                  }
                } catch (err) {
                  console.error("Critical Sandbox Failure:", err);
                }
              })();
            </script>
          </body>
        </html>
      `;

      this.iframe.srcdoc = srcDoc;

      // 5. Watchdog Timeout
      setTimeout(() => {
        if (this.iframe) {
          this.cleanup();
          reject(new Error("Execution Timed Out: The agent might be in an infinite loop."));
        }
      }, this.timeoutMs);
    });
  }

  private createMembrane(exposed: Record<string, any>) {
    return new Proxy(exposed, {
      get(target, prop) {
        if (prop in target) return target[prop as string];
        
        // Block access to everything else
        console.warn(`[Security] Agent tried to access: ${String(prop)}`);
        return undefined;
      },
      set(target, prop, value) {
        // Allow agent to set their own local variables
        target[prop as string] = value;
        return true;
      },
      has() {
        // Force the 'with' statement to always use this proxy
        return true;
      }
    });
  }

  private cleanup() {
    if (this.iframe) {
      document.body.removeChild(this.iframe);
      this.iframe = null;
      delete (window as any).__SANDBOX_BRIDGE;
    }
  }
}

// --- Usage Example ---
/*
const sandbox = new AgentSandbox({
  allowedGlobals: {
    add: (a: number, b: number) => a + b
  }
});

sandbox.execute(`
  const result = add(10, 5);
  console.log("Result is", result);
  resolve(result); // Signal completion
`).then(res => console.log("Sandbox Finished:", res));
*/
