'use client';

import * as tsw from "tidyscripts_web";

/* create logger */ 
const log = tsw.common.logger.get_logger({id : 'firebase_instance'})  ; 

/* load the firebase web client from tidyscripts  */
const firebase = tsw.apis.firebase

const {doc,
       addDoc,
       getDoc,
       setDoc,
       collection, 
} = firebase ;

import { getDocs, query, where  } from "firebase/firestore";


import * as db_test from "./db_test"
export {db_test} ; 

/* temporary placeholder for Auth type */ 
type Auth = any ;
type Firestore = any ; 

/* define the  Firebase config object  */ 
const firebaseConfig = {
  apiKey: "AIzaSyByjw-kqCpeYXQpApAeUU3GAnh1WfSQd7I",
  authDomain: "tidyscripts.firebaseapp.com",
  projectId: "tidyscripts",
  storageBucket: "tidyscripts.appspot.com",
  messagingSenderId: "292052354057",
  appId: "1:292052354057:web:77fa4743a205deb40764d8",
  measurementId: "G-4SJGBBQWW2"
};

export var app  : any = null ;
export var auth : any = null ;
export var db   : any = null ;

export function get_auth() { return auth }
export function get_app() { return app } 
export function get_db() { return db } 
    

export function initialized() {
    return ( (app && auth && db) !== null ) 
} 

/* Function to Load the app, auth, and db objects */
export function initialize() {
    if (initialized())  { log(`Already initialized`) }
    else {
	log(`Initializing`)
	let tmp = firebase.initialize_firebase_auth_firestore(firebaseConfig) ;
	app = tmp.app ;
	auth = tmp.auth ;
	db = tmp.db 
    } 
} 

initialize(); 


export function give_feedback(msg : string) {
    let user_data = {
	t : tsw.common.util.unix_timestamp_ms() ,
	feedback : msg ,
	uid : (get_auth().currentUser?.uid  || "anon")
    }
    log(`Giving feedback using data: ${JSON.stringify(user_data)}`) 
    store_data(db, ["permissionless", "user", "feedback"] , user_data ) ; 
} 

type UserData  = any
interface FirebaseDataStoreOps {
    app_id : string ,
    path : string [] ,
    data : UserData 
} 

interface FirebaseDataGetOps {
    app_id : string ,
    path : string [] ,
} 

/**
 * Main function for adding a new document with a specified ID at a specified path
 * The last string in the path is assumed to be the docId (and length of path MUST be even) 
 *
 * @returns A promise that resolves when the document is successfully written.
 */
export async function user_doc_store(args : FirebaseDataStoreOps) {

    let {app_id , path , data  } = args ;
    var user_id : any  = null  ;
    let auth = get_auth() ;
    let db   = get_db()  ;
    log(`Request to user_doc_store: appid=${app_id}, path =${path}, data=${JSON.stringify(data)}`)
    
    try {
	user_id = auth.currentUser?.uid;
	if (!user_id) {
	    throw new Error('User is not authenticated.');
	}
    } catch (error : any) { } 
    
    let docId = path.splice(0,path.length -1)  ; 

    let full_path = [ "users" , user_id , app_id, ...path]  ; 

    var docRef = doc(db, ...full_path)

    log(`Obtained document reference: ${docRef}`)

    try { 
	await setDoc(docRef, data) 
	log(`Wrote document`)
    } catch (error : any) {
	log(`Error writing document: ${error}`)
	
    } 
}

/**
 * Main function for adding a new document into a collection. Creates an autogenerated document ID 
 * The last string in the path is assumed to be a collection (and length of path MUST be even) 
 *
 * @returns A promise that resolves when the document is successfully written.
 */
export async function store_in_user_collection(args : FirebaseDataStoreOps) {

    let {app_id , path , data  } = args ;
    
    let auth = get_auth() ;
    let db   = get_db()  ;
    log(`Request to store in user collection: appid=${app_id}, path =${path}, data=${JSON.stringify(data)}`) 
    return await store_user_data( auth , db, app_id , path, data)
}

/**
 * Main function for retrieving a collection 
 * The last string in the path is assumed to be a collection (and length of path MUST be even) 
 *
 * @returns the collection array 
 */
export async function get_user_collection(args : FirebaseDataGetOps) {

    let {app_id , path  } = args ;

    var user_id : any  = null  ;
    let auth = get_auth() ;
    let db   = get_db()  ;
    
    try {
	user_id = auth.currentUser?.uid;
	if (!user_id) {
	    throw new Error('User is not authenticated.');
	}
    } catch (error : any) { } 

    
    log(`Request to get user collection: appid=${app_id}, path =${path}`)
    let full_path = [ "users" , user_id , app_id, ...path]  ; 

    log(`Using full path: ${full_path}`) 
    
    // Get a reference to the collection
    const collectionRef = collection(db, ...full_path);

    // Get all documents in the collection
    const snapshot = await getDocs(collectionRef);

    // Create an array to hold the document data
    const documents: any[] = [];

    // Loop through each document in the snapshot
    snapshot.forEach((doc) => {
	// Add the document data to the array
	documents.push({ id: doc.id, ...doc.data() });
    });

    return documents;
}









/**
 * Stores a document for a user in a specified subcollection path within the "users" collection, with an autogenerated document ID.
 *
 * @param auth - The Firebase Auth instance.
 * @param db - The Firestore instance.
 * @param app_id - ID of the APP that is storing data 
 * @param path - An array of strings representing the subcollection path.
 * @param user_data - The data to be stored in the document.
 * @returns A promise that resolves when the document is successfully written.
 */
export var  store_user_data = async (auth: Auth, db: Firestore, app_id : string, path: string[], user_data: UserData): Promise<void> => {
  try {
    const user_id = auth.currentUser?.uid;
    if (!user_id) {
      throw new Error('User is not authenticated.');
    }

      const full_path = ['users', user_id, app_id, ...path];
      // @ts-expect-error
      const collection_ref = collection(db, ...full_path);
      await addDoc(collection_ref, user_data);
    console.log(`User document for ${user_id} at path ${full_path.join('/')} has been added successfully.`);
  } catch (error) {
    console.error('Error adding user document:', error);
  }
};

/**
 * Retrieves a document for a user from a specified subcollection path within the "users" collection.
 *
 * @param auth - The Firebase Auth instance.
 * @param db - The Firestore instance.
 * @param path - An array of strings representing the subcollection path.
 * @param doc_id - The ID of the document to retrieve.
 * @returns A promise that resolves with the document data if found, otherwise null.
 */
const get_user_data = async (auth: Auth, db: Firestore, path: string[], doc_id: string): Promise<UserData | null> => {
  try {
    const user_id = auth.currentUser?.uid;
    if (!user_id) {
      throw new Error('User is not authenticated.');
    }

      const full_path = ['users', user_id, ...path];

    const doc_ref = doc(db, ...full_path, doc_id);
    const doc_snapshot = await getDoc(doc_ref);

    if (doc_snapshot.exists()) {
      console.log(`Document data for ${user_id} at path ${full_path.join('/')} retrieved successfully.`);
      return doc_snapshot.data() as UserData;
    } else {
      console.log(`No document found for ${user_id} at path ${full_path.join('/')}.`);
      return null;
    }
  } catch (error) {
    console.error('Error retrieving user document:', error);
    return null;
  }
};


/**
 * Stores a document at a specified collection path, with an autogenerated document ID.
 *
 * @param db - The Firestore instance.
 * @param path - An array of strings representing the collection path.
 * @param data - The data to be stored in the document.
 * @returns A promise that resolves when the document is successfully written.
 */
const store_data = async (db: Firestore, path: string[], data: Record<string, any>): Promise<void> => {
  try {
      // Construct the collection reference using the path array
      log(`Request to store data at path: ${path}`)

      // @ts-expect-error      
      const collection_ref = collection(db, ...path);

      await addDoc(collection_ref, data);
    log(`Document at path ${path.join('/')} has been added successfully.`);
  } catch (error) {
    console.error('Error adding document:', error);
  }
};


/**
 * Retrieves a document from a specified collection path.
 *
 * @param db - The Firestore instance.
 * @param path - An array of strings representing the collection path.
 * @param doc_id - The ID of the document to retrieve.
 * @returns A promise that resolves with the document data if found, otherwise null.
 */
const get_data = async (db: Firestore, path: string[], doc_id: string): Promise<UserData | null> => {
  try {
    const doc_ref = doc(db, ...path, doc_id);
    const doc_snapshot = await getDoc(doc_ref);

    if (doc_snapshot.exists()) {
      console.log(`Document data at path ${path.join('/')} retrieved successfully.`);
      return doc_snapshot.data() as UserData;
    } else {
      console.log(`No document found at path ${path.join('/')}.`);
      return null;
    }
  } catch (error) {
    console.error('Error retrieving document:', error);
    return null;
  }
};

export { get_user_data, store_data, get_data };

export  {
    doc,
    addDoc,
    getDoc,
    getDocs, 
    setDoc,
    collection,
} 



/*
TESTS 
 */

export async function test_store() {

    var citiesRef = collection(db, "cities");
    
    await setDoc(doc(citiesRef, "SF"), {
	name: "San Francisco", state: "CA", country: "USA",
	capital: false, population: 860000,
	regions: ["west_coast", "norcal"] });
    await setDoc(doc(citiesRef, "LA"), {
	name: "Los Angeles", state: "CA", country: "USA",
	capital: false, population: 3900000,
	regions: ["west_coast", "socal"] });
    await setDoc(doc(citiesRef, "DC"), {
	name: "Washington, D.C.", state: null, country: "USA",
	capital: true, population: 680000,
	regions: ["east_coast"] });
    await setDoc(doc(citiesRef, "TOK"), {
	name: "Tokyo", state: null, country: "Japan",
	capital: true, population: 9000000,
	regions: ["kanto", "honshu"] });
    await setDoc(doc(citiesRef, "BJ"), {
	name: "Beijing", state: null, country: "China",
	capital: true, population: 21500000,
	regions: ["jingjinji", "hebei"] })


}

export async function get() {
    
    const docRef = doc(db, "cities", "SF");
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
	console.log("Document data:", docSnap.data());
    } else {
	// docSnap.data() will be undefined in this case
	console.log("No such document!");
    }
} 

export async function test_get_2(){
    const q = query(collection(db, "cities"), where("capital", "==", true));

    const querySnapshot = await getDocs(q);
    querySnapshot.forEach((doc) => {
	// doc.data() is never undefined for query doc snapshots
	console.log(doc.id, " => ", doc.data());
    });

}


export async function test_2() {
    const querySnapshot = await getDocs(collection(db, "cities"));
querySnapshot.forEach((doc) => {
  // doc.data() is never undefined for query doc snapshots
  console.log(doc.id, " => ", doc.data());
});
}

export async function test_3() {

   // Query a reference to a subcollection
const querySnapshot = await getDocs(collection(db, "cities", "SF", "landmarks"));
querySnapshot.forEach((doc) => {
  // doc.data() is never undefined for query doc snapshots
  console.log(doc.id, " => ", doc.data());
});

}



