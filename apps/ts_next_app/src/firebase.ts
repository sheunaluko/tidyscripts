'use client';

import * as tsw from "tidyscripts_web";

/* create logger */ 
const log = tsw.common.logger.get_logger({id : 'firebase_instance'})  ; 

/* load the firebase web client from tidyscripts  */
const firebase = tsw.apis.firebase

const {doc,
       addDoc,
       getDoc,
       collection, 
} = firebase ; 

/* temporary placeholder for Auth type */ 
type Auth = any ;
type Firestore = any ; 

/* define the  Firebase config object  */ 
const firebaseConfig = {
  apiKey: "AIzaSyByjw-kqCpeYXQpApAeUU3GAnh1WfSQd7I",
  authDomain: "tidyscripts.firebaseapp.com",
  projectId: "tidyscripts",
  storageBucket: "tidyscripts.appspot.com",
  messagingSenderId: "292052354057",
  appId: "1:292052354057:web:77fa4743a205deb40764d8",
  measurementId: "G-4SJGBBQWW2"
};

export var app  : any = null ;
export var auth : any = null ;
export var db   : any = null ;

export function get_auth() { return auth }
export function get_app() { return app } 
export function get_db() { return db } 
    

export function initialized() {
    return ( (app && auth && db) !== null ) 
} 

/* Function to Load the app, auth, and db objects */
export function initialize() {
    if (initialized())  { log(`Already initialized`) }
    else {
	log(`Initializing`)
	let tmp = firebase.initialize_firebase_auth_firestore(firebaseConfig) ;
	app = tmp.app ;
	auth = tmp.auth ;
	db = tmp.db 
    } 
} 

initialize(); 


export function give_feedback(msg : string) {
    let user_data = {
	t : tsw.common.util.unix_timestamp_ms() ,
	feedback : msg ,
	uid : (get_auth().currentUser?.uid  || "anon")
    }
    log(`Giving feedback using data: ${JSON.stringify(user_data)}`) 
    store_data(db, ["permissionless", "user", "feedback"] , user_data ) ; 
} 

interface UserData {
  [key: string]: any;
}



/**
 * Stores a document for a user in a specified subcollection path within the "users" collection, with an autogenerated document ID.
 *
 * @param auth - The Firebase Auth instance.
 * @param db - The Firestore instance.
 * @param path - An array of strings representing the subcollection path.
 * @param user_data - The data to be stored in the document.
 * @returns A promise that resolves when the document is successfully written.
 */
const store_user_data = async (auth: Auth, db: Firestore, path: string[], user_data: UserData): Promise<void> => {
  try {
    const user_id = auth.currentUser?.uid;
    if (!user_id) {
      throw new Error('User is not authenticated.');
    }

      const full_path = ['users', user_id, ...path];
      // @ts-expect-error
      const collection_ref = collection(db, ...full_path);
      await addDoc(collection_ref, user_data);
    console.log(`User document for ${user_id} at path ${full_path.join('/')} has been added successfully.`);
  } catch (error) {
    console.error('Error adding user document:', error);
  }
};

/**
 * Retrieves a document for a user from a specified subcollection path within the "users" collection.
 *
 * @param auth - The Firebase Auth instance.
 * @param db - The Firestore instance.
 * @param path - An array of strings representing the subcollection path.
 * @param doc_id - The ID of the document to retrieve.
 * @returns A promise that resolves with the document data if found, otherwise null.
 */
const get_user_data = async (auth: Auth, db: Firestore, path: string[], doc_id: string): Promise<UserData | null> => {
  try {
    const user_id = auth.currentUser?.uid;
    if (!user_id) {
      throw new Error('User is not authenticated.');
    }

      const full_path = ['users', user_id, ...path];

    const doc_ref = doc(db, ...full_path, doc_id);
    const doc_snapshot = await getDoc(doc_ref);

    if (doc_snapshot.exists()) {
      console.log(`Document data for ${user_id} at path ${full_path.join('/')} retrieved successfully.`);
      return doc_snapshot.data() as UserData;
    } else {
      console.log(`No document found for ${user_id} at path ${full_path.join('/')}.`);
      return null;
    }
  } catch (error) {
    console.error('Error retrieving user document:', error);
    return null;
  }
};


/**
 * Stores a document at a specified collection path, with an autogenerated document ID.
 *
 * @param db - The Firestore instance.
 * @param path - An array of strings representing the collection path.
 * @param data - The data to be stored in the document.
 * @returns A promise that resolves when the document is successfully written.
 */
const store_data = async (db: Firestore, path: string[], data: Record<string, any>): Promise<void> => {
  try {
      // Construct the collection reference using the path array
      log(`Request to store data at path: ${path}`)

      // @ts-expect-error      
      const collection_ref = collection(db, ...path);

      await addDoc(collection_ref, data);
    log(`Document at path ${path.join('/')} has been added successfully.`);
  } catch (error) {
    console.error('Error adding document:', error);
  }
};


/**
 * Retrieves a document from a specified collection path.
 *
 * @param db - The Firestore instance.
 * @param path - An array of strings representing the collection path.
 * @param doc_id - The ID of the document to retrieve.
 * @returns A promise that resolves with the document data if found, otherwise null.
 */
const get_data = async (db: Firestore, path: string[], doc_id: string): Promise<UserData | null> => {
  try {
    const doc_ref = doc(db, ...path, doc_id);
    const doc_snapshot = await getDoc(doc_ref);

    if (doc_snapshot.exists()) {
      console.log(`Document data at path ${path.join('/')} retrieved successfully.`);
      return doc_snapshot.data() as UserData;
    } else {
      console.log(`No document found at path ${path.join('/')}.`);
      return null;
    }
  } catch (error) {
    console.error('Error retrieving document:', error);
    return null;
  }
};

export { store_user_data, get_user_data, store_data, get_data };
