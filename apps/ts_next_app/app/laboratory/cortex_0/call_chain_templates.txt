Below is a key idea, however I have some modifications to it:
1) I want to call them Call Chain Templates (not function templates) 
2) dont need versioning or created_by or created at
3) for now - dont need to modify run_cortex_output to include chain_id , etc (i.e. dont need the observability)
4) don't worry about guardrails right now -- lets make a minimal code diff to implement the feature 
5) Note: I did start implementing this in cortex_agent_web as a cortex function but at that time the core architecture was diffrent. The only thing to preserve from that implementation idea is the fact that & sign was used for resolving template parameters and some of those implementation ideas were sketched out.
6) in this case though - i want a fresh and minimal implementation



{
	createdAt: d'2025-12-05T01:20:49.548449566Z',
	created_at: d'2025-12-05T01:20:49.548434846Z',
	id: cortex:zt9xp01606o9ywhmgqb9,
	kind: 'design_note',
	owner: user:lxvkjd38tjir8q66a2uh,
	summary: "Dynamic Function Template Architecture

Goal
Enable the Cortex agent to define, persist, discover, and execute reusable multi-step tool macros (function_templates) that behave like single tools but internally run full call chains.

Core concepts
1) FunctionTemplate (macro)
- A named, parameterized wrapper around a CortexOutput.
- Looks like a single tool from the model’s perspective, but expands to a sequence of function calls.

Structure (conceptual)
- name: string           // human- and model-friendly name
- description: string    // what the template does
- version: number        // supports evolution over time
- created_by: string     // e.g. 'cortex' or a user id
- status: 'draft' | 'approved'
- params_schema: object  // simple JSON schema or type hints for parameters
- calls: FunctionCall[]  // parameterized calls, with placeholders for args
- return_indeces: number[] // which call results to surface as the template’s output

These fields together represent a parameterized CortexOutput: calls + return_indeces with placeholders like $paramName that are filled at runtime.

2) Database storage (cortex_templates)
Store templates in a dedicated table, e.g. cortex_templates, with records like:
- id: template:<name>_v<version>
- name: string
- version: number
- description: string
- created_by: string
- created_at / updated_at: datetime
- status: 'draft' | 'approved'
- params_schema: object
- calls: array<FunctionCall>
- return_indeces: array<number>

This lets multiple versions exist and supports moderation (only approved templates are runnable by default).

3) Tools exposed to the model
To work with templates, the agent gets a small API surface:

(1) save_function_template
- Input: { name, description, params_schema, calls, return_indeces, status? }
- Behavior:
  - Create or update a cortex_templates record.
  - Optionally auto-increment version or let the caller supply it.
  - Default new templates to status='draft' for human review, unless explicitly allowed.

(2) get_function_template
- Input: { name, version? }
- Behavior:
  - Fetch the latest approved version for a given name (or a specific version).

(3) list_function_templates
- Input: optional filters (status, created_by, name prefix).
- Behavior:
  - Return a list of templates so the agent can discover and reuse them.

(4) run_function_template
- Input: { template_name, template_args, version? }
- Behavior:
  1) Fetch the template using get_function_template.
  2) Validate template_args against params_schema (if defined).
  3) Substitute argument values into the template’s calls:
     - Replace placeholders like $paramName in parameters with concrete values.
  4) Produce a concrete CortexOutput: { thoughts, calls, return_indeces }.
     - thoughts can be auto-filled or left minimal (e.g. \"running template X\").
  5) Execute this CortexOutput through run_cortex_output (with its own chain_id / sub_chain_id).
  6) Return the filtered results (according to return_indeces) as the tool output back to the model.

4) Execution and observability
- Every run of run_function_template is treated as a normal tool call from the agent’s perspective.
- Internally, it triggers a sub-chain execution via run_cortex_output.
- The tracing mechanism (events with chain_id, seq, timestamps, etc.) should include:
  - Outer chain: the original user request and the run_function_template call.
  - Inner chain: the template’s call sequence, ideally tagged with a sub_chain_id and linked back to the parent chain.

This allows the trace viewer to expand or collapse template executions as logical units.

5) Agent workflow with dynamic templates
- Creating/updating:
  - When the agent sees a repeated pattern, it can construct a JSON template body and call save_function_template.
  - The template is stored as draft until optionally approved by a human.

- Reusing:
  - Later, in this or another session, the agent can call run_function_template by name and arguments.
  - The backend handles lookup, substitution, and execution, returning a single structured result.

6) Safety and guardrails
- Status field (draft/approved) to gate which templates can run automatically.
- Optional restrictions on which underlying tools can appear in model-authored templates (e.g. disallow raw DELETE in templates unless human-created).
- Params validation (params_schema) to ensure correct usage.
- Full trace logging so you can inspect, debug, and refine templates over time.

Overall
This architecture turns function_templates into first-class, persistent macros:
- From the model’s POV: a clean, small set of tools (save/get/list/run templates).
- From the system’s POV: a growing library of higher-level behaviors, versioned, observable, and optionally human-reviewed.
",
	topic: 'dynamic_function_templates',
	updatedAt: d'2025-12-05T01:20:49.548729150Z'
}


