// Result Analysis Prompt - LLM prompt for analyzing test results

import { ModelTestResult } from '../types';

/**
 * System prompt for analyzing note generation test results
 */
export const RESULT_ANALYSIS_SYSTEM_PROMPT = `You are an expert medical documentation analyst specializing in AI-generated clinical notes.

Your task is to analyze and compare medical notes generated by different AI models using the same template and input data.

Provide:
1. Overall quality assessment of each model's output
2. Comparison of how well each model:
   - Followed the template structure
   - Extracted relevant information from input
   - Applied template syntax correctly (conditional logic, variables, fallback text)
   - Formatted the output professionally as clean markdown
   - Maintained medical documentation standards
3. Notable strengths and weaknesses of each model
4. Recommendation for which model(s) performed best for this use case

Format your analysis as clear, structured markdown with sections and bullet points.
Be objective, specific, and cite examples from the generated notes.
Focus on practical differences that would matter to physicians using this tool.`;

/**
 * Build complete analysis prompt with all context
 * @param templateSyntaxDocs - Template syntax documentation from constants
 * @param systemPrompt - System prompt used for note generation
 * @param template - Template content
 * @param inputText - Input text provided
 * @param results - Array of model test results
 * @returns Object with system and user prompts
 */
export function buildAnalysisPrompt(
  templateSyntaxDocs: any, // TEMPLATE_SYNTAX from constants
  systemPrompt: string,
  template: string,
  inputText: string,
  results: ModelTestResult[]
): { system: string; user: string } {
  // Format syntax documentation
  const syntaxDoc = formatTemplateSyntax(templateSyntaxDocs);

  // Format results
  const resultsText = results
    .filter(r => r.status === 'success' && r.note)
    .map((r, i) => `
### Model ${i + 1}: ${r.model}
**Duration**: ${r.duration}ms

**Generated Note**:
\`\`\`markdown
${r.note}
\`\`\`
`)
    .join('\n---\n');

  const successCount = results.filter(r => r.status === 'success').length;
  const errorResults = results.filter(r => r.status === 'error');

  const userPrompt = `## Template Syntax Documentation

${syntaxDoc}

---

## System Prompt Used for Generation

\`\`\`
${systemPrompt}
\`\`\`

---

## Template

\`\`\`
${template}
\`\`\`

---

## Input Text Provided

\`\`\`
${inputText}
\`\`\`

---

## Generated Results (${successCount} successful, ${errorResults.length} failed)

${resultsText}

${errorResults.length > 0 ? `
### Failed Models
${errorResults.map(r => `- **${r.model}**: ${r.error}`).join('\n')}
` : ''}

---

Please analyze these results and provide a comprehensive comparison. Focus on how well each model followed the template syntax rules and extracted information appropriately.`;

  return {
    system: RESULT_ANALYSIS_SYSTEM_PROMPT,
    user: userPrompt,
  };
}

/**
 * Format template syntax documentation as readable markdown
 */
function formatTemplateSyntax(syntaxDocs: any): string {
  if (!syntaxDocs || !syntaxDocs.patterns) {
    return 'Template syntax documentation not available.';
  }

  let output = `${syntaxDocs.description}\n\n`;

  // Format each pattern
  syntaxDocs.patterns.forEach((pattern: any, index: number) => {
    output += `### Pattern ${index + 1}: ${pattern.name}\n\n`;
    output += `**Syntax**: \`${pattern.syntax}\`\n\n`;

    if (pattern.rules && pattern.rules.length > 0) {
      output += '**Rules**:\n';
      pattern.rules.forEach((rule: string) => {
        output += `- ${rule}\n`;
      });
      output += '\n';
    }

    if (pattern.examples && pattern.examples.length > 0) {
      output += '**Examples**:\n';
      pattern.examples.forEach((example: string) => {
        output += `- ${example}\n`;
      });
      output += '\n';
    }

    if (pattern.notes) {
      output += `*Note: ${pattern.notes}*\n\n`;
    }
  });

  // Add traditional syntax if available
  if (syntaxDocs.traditional) {
    const trad = syntaxDocs.traditional;
    output += `### Traditional Syntax (Legacy)\n\n`;
    output += `**Syntax**: \`${trad.syntax}\`\n\n`;

    if (trad.rules && trad.rules.length > 0) {
      output += '**Rules**:\n';
      trad.rules.forEach((rule: string) => {
        output += `- ${rule}\n`;
      });
      output += '\n';
    }

    if (trad.examples && trad.examples.length > 0) {
      output += '**Examples**:\n';
      trad.examples.forEach((example: string) => {
        output += `- ${example}\n`;
      });
    }
  }

  return output;
}
