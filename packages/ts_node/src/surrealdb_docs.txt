Directory structure:
└── surrealdb-surrealdb.js/
    ├── README.md
    ├── biome.json
    ├── CODE_OF_CONDUCT.md
    ├── CONTRIBUTING.md
    ├── LICENSE
    ├── package.json
    ├── SECURITY.md
    ├── tsconfig.json
    ├── .npmrc
    ├── packages/
    │   ├── cbor/
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   └── src/
    │   │       ├── constants.ts
    │   │       ├── decoder.ts
    │   │       ├── encoded.ts
    │   │       ├── encoder.ts
    │   │       ├── error.ts
    │   │       ├── gap.ts
    │   │       ├── index.ts
    │   │       ├── partial.ts
    │   │       ├── reader.ts
    │   │       ├── tagged.ts
    │   │       ├── util.ts
    │   │       └── writer.ts
    │   ├── sdk/
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   └── src/
    │   │       ├── errors.ts
    │   │       ├── index.ts
    │   │       ├── cbor/
    │   │       │   ├── index.ts
    │   │       │   ├── replacer.ts
    │   │       │   └── utils.ts
    │   │       ├── controller/
    │   │       │   └── index.ts
    │   │       ├── engine/
    │   │       │   ├── http.ts
    │   │       │   ├── index.ts
    │   │       │   └── websocket.ts
    │   │       ├── internal/
    │   │       │   ├── get-incremental-id.ts
    │   │       │   ├── http.ts
    │   │       │   ├── output.ts
    │   │       │   ├── rand.ts
    │   │       │   ├── range.ts
    │   │       │   ├── reconnect.ts
    │   │       │   ├── tokens.ts
    │   │       │   └── validation.ts
    │   │       ├── surreal/
    │   │       │   ├── index.ts
    │   │       │   ├── v1.ts
    │   │       │   └── v2.ts
    │   │       ├── types/
    │   │       │   ├── auth.ts
    │   │       │   ├── export.ts
    │   │       │   ├── helpers.ts
    │   │       │   ├── index.ts
    │   │       │   ├── live.ts
    │   │       │   ├── patch.ts
    │   │       │   ├── publisher.ts
    │   │       │   ├── query.ts
    │   │       │   ├── rpc.ts
    │   │       │   └── surreal.ts
    │   │       ├── utils/
    │   │       │   ├── equals.ts
    │   │       │   ├── escape.ts
    │   │       │   ├── index.ts
    │   │       │   ├── jsonify.ts
    │   │       │   ├── live.ts
    │   │       │   ├── prepared-query.ts
    │   │       │   ├── publisher.ts
    │   │       │   ├── range.ts
    │   │       │   ├── string-prefixes.ts
    │   │       │   ├── tagged-template.ts
    │   │       │   ├── to-surql-string.ts
    │   │       │   └── version.ts
    │   │       └── value/
    │   │           ├── decimal.ts
    │   │           ├── duration.ts
    │   │           ├── future.ts
    │   │           ├── geometry.ts
    │   │           ├── index.ts
    │   │           ├── range.ts
    │   │           ├── record-id-range.ts
    │   │           ├── record-id.ts
    │   │           ├── string-record-id.ts
    │   │           ├── table.ts
    │   │           ├── uuid.ts
    │   │           └── value.ts
    │   └── tests/
    │       ├── import.ts
    │       ├── package.json
    │       ├── tsconfig.json
    │       ├── integration/
    │       │   ├── authentication.test.ts
    │       │   ├── connection.test.ts
    │       │   ├── export.test.ts
    │       │   ├── import.test.ts
    │       │   ├── __helpers__/
    │       │   │   ├── database.ts
    │       │   │   ├── env.ts
    │       │   │   ├── helpers.ts
    │       │   │   ├── index.ts
    │       │   │   └── surreal.ts
    │       │   ├── __snapshots__/
    │       │   │   ├── export.test.ts.snap
    │       │   │   └── import.test.ts.snap
    │       │   ├── protocol/
    │       │   │   ├── http.test.ts
    │       │   │   └── websocket.test.ts
    │       │   └── query/
    │       │       ├── create.test.ts
    │       │       ├── delete.test.ts
    │       │       ├── insert.test.ts
    │       │       ├── live.test.ts
    │       │       ├── merge.test.ts
    │       │       ├── params.test.ts
    │       │       ├── patch.test.ts
    │       │       ├── relate.test.ts
    │       │       ├── run.test.ts
    │       │       ├── select.test.ts
    │       │       ├── update.test.ts
    │       │       └── upsert.test.ts
    │       └── unit/
    │           ├── cbor.test.ts
    │           ├── __helpers__/
    │           │   ├── index.ts
    │           │   └── mock.ts
    │           ├── __snapshots__/
    │           │   └── cbor.test.ts.snap
    │           ├── utilities/
    │           │   ├── equals.test.ts
    │           │   ├── escape.test.ts
    │           │   ├── jsonify.test.ts
    │           │   ├── string-prefixes.test.ts
    │           │   ├── to-surql-string.test.ts
    │           │   ├── version.test.ts
    │           │   └── __snapshots__/
    │           │       ├── jsonify.test.ts.snap
    │           │       └── to-surql-string.test.ts.snap
    │           └── values/
    │               ├── decimal.test.ts
    │               ├── duration.test.ts
    │               └── record-id.test.ts
    ├── scripts/
    │   ├── build/
    │   │   ├── declarations.ts
    │   │   ├── esbuild.ts
    │   │   ├── index.ts
    │   │   └── jsr.ts
    │   ├── publish/
    │   │   ├── channel.ts
    │   │   ├── index.ts
    │   │   └── publish.ts
    │   ├── utils/
    │   │   ├── logger.ts
    │   │   └── package.ts
    │   └── versions/
    │       └── index.ts
    ├── .github/
    │   ├── CODEOWNERS
    │   ├── PULL_REQUEST_TEMPLATE.md
    │   ├── ISSUE_TEMPLATE/
    │   │   ├── bug_report.yml
    │   │   ├── config.yml
    │   │   └── feature_request.yml
    │   └── workflows/
    │       ├── check.yml
    │       └── publish.yml
    └── .zed/
        └── settings.json


Files Content:

(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
<br>

<p align="center">
    <img width=120 src="https://raw.githubusercontent.com/surrealdb/icons/main/surreal.svg" />
    &nbsp;
    <img width=120 src="https://raw.githubusercontent.com/surrealdb/icons/main/javascript.svg" />
</p>

<h3 align="center">The official SurrealDB SDK for JavaScript.</h3>

<br>

<p align="center">
    <a href="https://github.com/surrealdb/surrealdb.js"><img src="https://img.shields.io/badge/status-stable-ff00bb.svg?style=flat-square"></a>
    &nbsp;
    <a href="https://surrealdb.com/docs/sdk/javascript"><img src="https://img.shields.io/badge/docs-view-44cc11.svg?style=flat-square"></a>
    &nbsp;
    <a href="https://www.npmjs.com/package/surrealdb"><img src="https://img.shields.io/npm/v/surrealdb?style=flat-square"></a>
    &nbsp;
    <a href="https://www.npmjs.com/package/surrealdb"><img src="https://img.shields.io/npm/dm/surrealdb?style=flat-square"></a>
    &nbsp;
    <a href="https://deno.land/x/surrealdb"><img src="https://img.shields.io/npm/v/surrealdb?style=flat-square&label=deno"></a>
</p>

<p align="center">
    <a href="https://surrealdb.com/discord"><img src="https://img.shields.io/discord/902568124350599239?label=discord&style=flat-square&color=5a66f6"></a>
    &nbsp;
    <a href="https://twitter.com/surrealdb"><img src="https://img.shields.io/badge/twitter-follow_us-1d9bf0.svg?style=flat-square"></a>
    &nbsp;
    <a href="https://www.linkedin.com/company/surrealdb/"><img src="https://img.shields.io/badge/linkedin-connect_with_us-0a66c2.svg?style=flat-square"></a>
    &nbsp;
    <a href="https://www.youtube.com/@SurrealDB"><img src="https://img.shields.io/badge/youtube-subscribe-fc1c1c.svg?style=flat-square"></a>
</p>

# surrealdb

The official SurrealDB SDK for JavaScript.

## Documentation

View the SDK documentation [here](https://surrealdb.com/docs/sdk/javascript).

## Learn SurrealDB

- SurrealDB University: https://surrealdb.com/learn/fundamentals
- Aeon's Surreal Renaissance (Interative book): https://surrealdb.com/learn/book
- Documentation: https://surrealdb.com/docs

## How to install

### Install for [JSR/Deno](https://jsr.io/@surrealdb/surrealdb)

Import it with:

```ts
import Surreal from "@surrealdb/surrealdb";
```

### Install for [Node.js](https://www.npmjs.com/package/surrealdb)

Install it with:

```sh
# using npm
npm i surrealdb
# or using pnpm
pnpm i surrealdb
# or using yarn
yarn add surrealdb
```

Next, just import it with:

```ts
const { Surreal } = require("surrealdb");
```

or when you use modules:

```ts
import Surreal from "surrealdb";
```

### Install for the browser

For usage in a browser environment, when using a bundler (e.g. [Rollup](https://rollupjs.org/), [Vite](https://vitejs.dev/), or [webpack](https://webpack.js.org/)) you can install it with:

```sh
# using npm
npm i surrealdb
# or using pnpm
pnpm i surrealdb
# or using yarn
yarn add surrealdb
```

Next, just import it with:

```ts
import Surreal from "surrealdb";
```

or when you use CommonJS:

```ts
const { Surreal } = require("surrealdb");
```

### Install for the browser with a CDN

For fast prototyping we provide a browser-ready bundle. You can import it with:

```ts
import Surreal from "https://unpkg.com/surrealdb";
// or
import Surreal from "https://cdn.jsdelivr.net/npm/surrealdb";
```

_**NOTE: this bundle is not optimized for production! So don't use it in production!**_

## Getting started

In the example below you can see how to connect to a remote instance of SurrealDB, authenticating with the database, and issuing queries for creating, updating, and selecting data from records.

> This example requires SurrealDB to be [installed](https://surrealdb.com/install) and running on port 8000.

> This example makes use of [top level await](https://v8.dev/features/top-level-await), available in [modern browsers](https://caniuse.com/mdn-javascript_operators_await_top_level), [Deno](https://deno.com/) and [Node.js](https://nodejs.org/) >= 14.8.

```ts
import { Surreal, RecordId, Table } from "surrealdb";

const db = new Surreal();

// Connect to the database
await db.connect("http://127.0.0.1:8000/rpc");

// Select a specific namespace / database
await db.use({
    namespace: "test",
    database: "test"
});

// Signin as a namespace, database, or root user
await db.signin({
    username: "root",
    password: "root",
});

// Create a new person with a random id
let created = await db.create("person", {
    title: "Founder & CEO",
    name: {
        first: "Tobie",
        last: "Morgan Hitchcock",
    },
    marketing: true,
});

// Update a person record with a specific id
let updated = await db.merge(new RecordId('person', 'jaime'), {
    marketing: true,
});

// Select all people records
let people = await db.select("person");

// Perform a custom advanced query
let groups = await db.query(
    "SELECT marketing, count() FROM $tb GROUP BY marketing",
    {
        tb: new Table("person"),
    },
);
```

## Contributing

### Local setup

This is a [Bun](https://bun.sh) project, not Node.js. It works across all major runtimes, however.

#### Supported environments

- [Deno](https://deno.land)
- [Node.js](https://nodejs.org)
- [Bun](https://bun.sh)
- Web Browsers

### Requirements

- Bun
- SurrealDB (for testing)

### Build for all supported environments

For Deno, no build is needed. For all other environments run

`bun run build`.

### Code Quality Fixes

`bun qa`

### Code Quality unsafe fixes

`bun qau`

### Run tests for WS

`bun test`

### Run tests for HTTP

`SURREAL_DEFAULT_PROTOCOL=http bun test`

### PRs

Before you commit, please format and lint your code accordingly to check for
errors, and ensure all tests still pass

### Local setup

For local development the
[Bun extension](https://marketplace.visualstudio.com/items?itemName=oven.bun-vscode) and [Biome extension](https://marketplace.visualstudio.com/items?itemName=biomejs.biome)
for VSCode are helpful.

### Directory structure

- `./biome.json` include settings for code quality.
- `./scripts` include the build scripts for NPM and JSR.
- `./src` includes all source code. `./src/index.ts` is the main entrypoint.
- `./dist` is build by `./scripts/build.ts` and includes the compiled and minified bundles for ESM, CJS and bundled ESM targets.
- `./tests` includes all test files.



================================================
FILE: biome.json
================================================
{
	"$schema": "https://biomejs.dev/schemas/1.8.3/schema.json",
	"organizeImports": {
		"enabled": true
	},
	"linter": {
		"enabled": true,
		"rules": {
			"recommended": true,
			"suspicious": {
				"noConsoleLog": "error"
			},
			"correctness": {
				"noUnusedImports": "error"
			},
			"style": {
				"useFilenamingConvention": {
					"level": "error",
					"options": {
						"filenameCases": ["kebab-case"]
					}
				}
			}
		}
	},
	"files": {
		"ignore": ["dist/**", "npm/**", "scripts/**"]
	}
}



================================================
FILE: CODE_OF_CONDUCT.md
================================================
# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behaviour that contributes to creating a positive environment include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behaviour by participants include:

* The use of sexualised language or imagery and unwelcome sexual attention or advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable behaviour and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behaviour.

Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviours that they deem inappropriate, threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behaviour may be reported by contacting the project team at info@surrealdb.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant](https://www.contributor-covenant.org), version 1.4, available [here](https://www.contributor-covenant.org/version/1/4/code-of-conduct.html). For answers to common questions about this code of conduct, see [FAQs](https://www.contributor-covenant.org/faq).



================================================
FILE: CONTRIBUTING.md
================================================
# Contributing

We would &nbsp;<img width="15" alt="Love" src="https://github.com/surrealdb/surrealdb/blob/main/img/love.svg?raw=true">&nbsp; for you to contribute to SurrealDB and help make it better! We want to ensure contributing to SurrealDB is fun, enjoyable, and educational for anyone and everyone. All contributions are welcome, including features, bug fixes, and documentation changes, as well as updates and tweaks, blog posts, workshops, and everything else.

## How to start

If you are worried or don’t know where to start, check out our next section explaining what kind of help we could use and where can you get involved. You can ask us a question on [GitHub Discussions](https://github.com/surrealdb/surrealdb/discussions), or the [SurrealDB Discord Server](https://surrealdb.com/discord). Alternatively, you can message us on any channel in the [SurrealDB Community](https://surrealdb.com/community)!

## Code of conduct

Please help us keep SurrealDB open and inclusive. Kindly read and follow our [Code of Conduct](/CODE_OF_CONDUCT.md).

<!--
--------------------------------------------------
ONLY RELEVANT FOR CLIENT SDK REPOSITORIES
--------------------------------------------------
-->

## Coding standards

We aim to develop according to coding standards in-line with each programming language. We suggest you go through the prerequisite reading section below before proceeding with a contribution!

<details>
  <summary>Prerequisite Reading</summary>

  ## What is a Database Driver?
  
  A database driver (also known as a client library), is a module for a programming language that is implemented to provide access to SurrealDB, and enables access to the wide range of functionality the database offers.
  
  Its focus is primarily on network protocol correctness, performance, access to distinct database features, error handling, and in due course, transaction handling and retriability.
  
  Drivers are not designed to be a one-size-fits-all, as we cannot make assumptions about how users will use the drivers. JDBC? Async? ORM? DSL? Due to the many different features and functionalities in each language, we are unable to provide all this functionality in a single driver.
  
  We want users to have very clear expectations about how our software works. It’s very important for us that when users move between languages or compare implementations, the SurrealDB integration is as familiar as possible across all languages.
  
  ## Driver architecture
  
  We would recommend following the API of the [Rust driver](https://github.com/surrealdb/surrealdb/tree/main/crates/sdk), as the Rust driver is fully utilising our capabilities and is the de-facto reference implementation. In the future, it will also be the underlying implementation as we begin to share a common API (either via foreign function interfaces or WASM), with native language-specific bindings.
  
  Drivers connect to SurrealDB using either REST, a text-based WebSocket protocol, or a binary-based WebSocket protocol. Each of the protocols aims to support as many of the SurrealDB features as possible, ensuring that similar functionality and similar performance are supported regardless of the protocol being used.
  
  Beyond baseline protocol support, error handling is also a key feature. This is tied with both custom SurrealQL protocol status codes included in the response itself, or with HTTP status codes in some cases.
  
  There isn't any specific configuration per driver. We may introduce configuration options in due course, and we will update this guide if we change those configurations.
  
  <!--
  --------------------------------------------------
  END
  --------------------------------------------------
  -->
</details>

## Introducing new features

We would &nbsp;<img width="15" alt="Love" src="https://github.com/surrealdb/surrealdb/blob/main/img/love.svg?raw=true">&nbsp; for you to contribute to SurrealDB, but we would also like to make sure SurrealDB is as great as possible and loyal to its vision and mission statement. For us to find the right balance, please open a question on [GitHub discussions](https://github.com/surrealdb/surrealdb/discussions) with any ideas before creating a [**GitHub Issue**](/issues). This will allow the SurrealDB community to have sufficient discussion about the new feature value and how it fits in the product roadmap and vision, before introducing a new pull request

This is also important for the SurrealDB lead developers to be able to give technical input and different emphasis regarding the feature design and architecture. Some bigger features might need to go through our [RFC process](https://github.com/surrealdb/rfcs).

## Submitting a pull request

The **branch name** is your first opportunity to give your task context.
Branch naming convention is as follows 

`TYPE-ISSUE_ID-DESCRIPTION`

It is recommended to combine the relevant [**GitHub Issue**](/issues) with a short description that describes the task resolved in this branch. If you don't have GitHub issue for your PR, then you may avoid the prefix, but keep in mind that more likely you have to create the issue first. For example:
```
bugfix-548-ensure-queries-execute-sequentially
```

Where `TYPE` can be one of the following:

- **refactor** - code change that neither fixes a bug nor adds a feature
- **feature** - code changes that add a new feature
- **bugfix** - code changes that fix a bug
- **docs** - documentation only changes
- **ci** - changes related to CI system

### Commit your changes

- Write a descriptive **summary**: The first line of your commit message should be a concise summary of the changes you are making. It should be no more than 50 characters and should describe the change in a way that is easy to understand.

- Provide more **details** in the body: The body of the commit message should provide more details about the changes you are making. Explain the problem you are solving, the changes you are making, and the reasoning behind those changes.

- Use the **commit history** in your favour: Small and self-contained commits allow the reviewer to see exactly how you solved the problem. By reading the commit history of the PR, the reviewer can already understand what they'll be reviewing, even before seeing a single line of code.

### Create a pull request

- The **title** of your pull request should be clear and descriptive. It should summarize the changes you are making in a concise manner.

- Provide a detailed **description** of the changes you are making. Explain the reasoning behind the changes, the problem it solves, and the impact it may have on the codebase. Keep in mind that a reviewer was not working on your task, so you should explain why you wrote the code the way you did.

- Describe the scene and provide everything that will help to understand the background and a context for the reviewers by adding related GitHub issues to the description, and links to the related PRs, projects or third-party documentation. If there are any potential drawbacks or trade-offs to your changes, be sure to mention them too.

- Be sure to **request reviews** from the appropriate people. This might include the project maintainers, other contributors, or anyone else who is familiar with the codebase and can provide valuable feedback. You can also join our [Weekly Developer Office Hours](https://github.com/orgs/surrealdb/discussions/2118) to chat with the maintainers who will review your code! 

### Getting a better review

- [**Draft pull requests**](https://github.blog/2019-02-14-introducing-draft-pull-requests/) allow you to create a pull request that is still a work in progress and not ready for review. This is useful when you want to share your changes with others but aren't quite ready to merge them or request immediate feedback.    
https://github.blog/2019-02-14-introducing-draft-pull-requests/

- Once your pull request has been reviewed, be sure to **respond** to any feedback you receive. This might involve making additional changes to your code, addressing questions or concerns, or simply thanking reviewers for their feedback.  

- By using the [**re-request review** feature](https://github.blog/changelog/2019-02-21-re-request-review-on-a-pull-request/), you can prompt the reviewer to take another look at your changes and provide feedback if necessary.  

- The [**CODEOWNERS** file](https://github.com/surrealdb/surrealdb/blob/main/.github/CODEOWNERS) in GitHub allows you to specify who is responsible for code in a specific part of your repository. You can use this file to automatically assign pull requests to the appropriate people or teams and to ensure that the right people are notified when changes are made to certain files or directories.  

<!--
**[OPTIONAL - can be removed]** We use [**scheduled reminders** to Slack](https://docs.github.com/en/organizations/organizing-members-into-teams/managing-scheduled-reminders-for-your-team) for abandoned pull requests to will receive reminders to the team's channel for PRs that are non-draft and have no activity for a couple of days.
-->

### Finalize the change

- We are actively using **threads** to allow for more detailed and targeted discussions about specific parts of the pull request. A resolved thread means that the conversation has been addressed and the issue has been resolved. Reviewers are responsible for resolving the comment and not the author. The author can simply add a reply comment that the change has been done or decline a request.

- When your pull request is approved, our team will be sure to **merge it responsibly**. This might involve running additional tests or checks, ensuring that the codebase is still functional.

### Summary

To summarize, fork the project and use the `git clone` command to download the repository to your computer. A standard procedure for working on an issue would be to:

1. Clone the repository and download it to your computer.
 
2. Pull all changes from the upstream `main` branch, before creating a new branch - to ensure that your `main` branch is up-to-date with the latest changes.

3. Create a new branch from `main` like: `bugfix-548-ensure-queries-execute-sequentially`.

4. Make changes to the code, and ensure all code changes are formatted correctly.

5. Commit your changes when finished,

6. Push changes to GitHub.

7. Submit your changes for review, by going to your repository on GitHub and clicking the `Compare & pull request` button.

8. Ensure that you have entered a commit message which details the changes, and what the pull request is for.

9. Now submit the pull request by clicking the `Create pull request` button.

10. Wait for code review and approval.

## Scalability and Performance

SurrealDB is designed to be fast and to scale. It is built to work in both a single-node setup and as a distributed cluster. In distributed mode, SurrealDB builds upon [TiKV](https://tikv.org). Please keep in mind that SurrealDB and the Client SDKs are designed to be run in different environments, with different configurations, and at differing scales.

When contributing code to the database or the Client SDKs, please take into account the following considerations:

- SurrealDB startup time
- Query execution time
- Query response times
- Query throughput
- Requests per second
- Websocket connections
- Network usage
- Memory usage

## Security and Privacy

We take the security of SurrealDB code, software, cloud platform, and client SDKs very seriously. If you believe you have found a security vulnerability in SurrealDB, we encourage you to let us know right away. We will investigate all legitimate reports and do our best to quickly fix the problem.

Please report any issues or vulnerabilities to security@surrealdb.com, instead of posting a public issue in GitHub. Please include the SurrealDB version identifier, by running `surreal version` on the command-line, and details on how the vulnerability can be exploited.

When developing, make sure to follow the best industry standards and practices.

## External dependencies

Please avoid introducing new dependencies to SurrealDB or the Client SDKs without consulting the team. New dependencies can be very helpful but also introduce new security and privacy issues, complexity, and impact total docker image size. Adding a new dependency should have vital value on the product with minimum possible risk.

## Other Ways to Help

Pull requests are great, but there are many other areas where you can help.

### Blogging and speaking

Blogging, speaking about, or creating tutorials about one of SurrealDB's many features. Mention [@surrealdb](https://twitter.com/surrealdb) on Twitter, and email community@surrealdb.com so we can give pointers and tips and help you spread the word by promoting your content on the different SurrealDB communication channels. Please add your blog posts and videos of talks to our [showcase](https://github.com/surrealdb/showcase) repo on GitHub.

### Presenting at meetups

Presenting at meetups and conferences about your SurrealDB projects. Your unique challenges and successes in building things with SurrealDB can provide great speaking material. We’d love to review your talk abstract, so get in touch with us at community@surrealdb.com if you’d like some help!

### Feedback, bugs, and ideas

Sending feedback is a great way for us to understand your different use cases of SurrealDB better. If you want to share your experience with SurrealDB, or if you want to discuss any ideas, you can start a discussion on [GitHub discussions](https://github.com/surrealdb/surrealdb/discussions), chat with the [SurrealDB team on Discord](https://surrealdb.com/discord), or you can tweet [@tobiemh](https://twitter.com/tobiemh) or [@surrealdb](https://twitter.com/surrealdb) on Twitter. If you have any issues or have found a bug, then feel free to create an issue on [**GitHub Issue**](/issues).

### Documentation improvements

Submitting [documentation](https://surrealdb.com/docs) updates, enhancements, designs, or bug fixes, and fixing any spelling or grammar errors will be very much appreciated.

### Joining our community

Join the growing [SurrealDB Community](https://surrealdb.com/community) around the world, for help, ideas, and discussions regarding SurrealDB.

- View our official [Blog](https://surrealdb.com/blog)
- Follow us on [Twitter](https://twitter.com/surrealdb)
- Connect with us on [LinkedIn](https://www.linkedin.com/company/surrealdb/)
- Join our [Dev community](https://dev.to/surrealdb)
- Chat live with us on [Discord](https://discord.gg/surrealdb)
- Get involved on [Reddit](http://reddit.com/r/surrealdb/)
- Read our blog posts on [Medium](https://medium.com/surrealdb)
- Questions tagged #surrealdb on [StackOverflow](https://stackoverflow.com/questions/tagged/surrealdb)



================================================
FILE: LICENSE
================================================
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright © SurrealDB Ltd

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.



================================================
FILE: package.json
================================================
{
	"name": "surrealdb.js",
	"version": "2.0.0-alpha.3",
	"private": true,
	"packageManager": "^bun@1.1.17",
	"workspaces": ["packages/*"],
	"devDependencies": {
		"@biomejs/biome": "1.8.3",
		"@types/signale": "^1.4.7",
		"bun-types": "^1.2.12",
		"fast-check": "^4.1.1",
		"signale": "^1.4.0",
		"dts-bundle-generator": "^9.5.1",
		"esbuild": "^0.21.5",
		"esbuild-plugin-tsc": "^0.4.0"
	},
	"scripts": {
		"qc": "biome check .",
		"qa": "biome check . --write",
		"qau": "biome check . --write --unsafe",
		"build": "bun scripts/build all",
		"build:cbor": "bun scripts/build cbor",
		"build:sdk": "bun scripts/build sdk",
		"versions": "bun scripts/versions",
		"publish": "bun scripts/publish",
		"test": "bun run build && cd ./packages/tests && bun run test"
	}
}



================================================
FILE: SECURITY.md
================================================
# Security Policy

## Reporting a Vulnerability

We take the security of SurrealDB code, software, and cloud platform very 
seriously. If you believe you have found a security vulnerability in 
SurrealDB, we encourage you to let us know right away. We will investigate 
all legitimate reports and do our best to quickly fix the problem.

Please report any issues or vulnerabilities to security@surrealdb.com, 
instead of posting a public issue in GitHub. Please include the version 
identifier, and details on how the vulnerability can be exploited.



================================================
FILE: tsconfig.json
================================================
{
	"compilerOptions": {
		"lib": ["ESNext", "DOM"],
		"target": "ESNext",
		"module": "ESNext",
		"moduleDetection": "force",
		"jsx": "react-jsx",

		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"verbatimModuleSyntax": true,
		"emitDeclarationOnly": true,
		"isolatedDeclarations": true,
		"declaration": true,

		"strict": true,
		"skipLibCheck": true,
		"noFallthroughCasesInSwitch": true,

		"noUnusedLocals": false,
		"noUnusedParameters": false,
		"noPropertyAccessFromIndexSignature": false,

		"baseUrl": ".",
		"paths": {
			"surrealdb": ["packages/sdk/src"],
			"@surrealdb/cbor": ["packages/cbor/src"]
		}
	}
}



================================================
FILE: .npmrc
================================================
engine-strict=true



================================================
FILE: packages/cbor/package.json
================================================
{
	"name": "@surrealdb/cbor",
	"version": "2.0.0-alpha.3",
	"type": "module",
	"license": "Apache-2.0",
	"description": "CBOR encoder and decoder for SurrealDB.",
	"keywords": ["surrealdb", "surrealdb.js", "cbor"],
	"repository": {
		"type": "git",
		"url": "git+https://github.com/surrealdb/surrealdb.js.git"
	},
	"homepage": "https://github.com/surrealdb/surrealdb.js",
	"packageManager": "^bun@1.1.17",
	"scripts": {
		"ts": "tsc --watch --noEmit true --emitDeclarationOnly false",
		"build": "bun run scripts/build.ts",
		"jsr": "bun run scripts/jsr.ts"
	},
	"engines": {
		"node": ">=18.0.0"
	},
	"browser": "./dist/index.bundled.mjs",
	"types": "./dist/index.d.ts",
	"main": "./dist/index.mjs",
	"exports": {
		".": {
			"require": "./dist/index.cjs",
			"import": "./dist/index.mjs",
			"types": "./dist/index.d.ts",
			"browser": "./dist/index.bundled.mjs"
		}
	},
	"files": ["dist"]
}



================================================
FILE: packages/cbor/tsconfig.json
================================================
{
	"extends": "../../tsconfig.json"
}



================================================
FILE: packages/cbor/src/constants.ts
================================================
// biome-ignore lint/suspicious/noExplicitAny: We don't know what it will return
export type Replacer = (v: any) => unknown;
export type Major = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;
export const POW_2_53: number = 2 ** 53;
export const POW_2_64: bigint = BigInt(2 ** 64);



================================================
FILE: packages/cbor/src/decoder.ts
================================================
import type { Replacer } from "./constants";
import { CborBreak, CborInvalidMajorError } from "./error";
import { Reader } from "./reader";
import { Tagged } from "./tagged";
import { infiniteBytes } from "./util";

const textDecoder = new TextDecoder();

export interface DecodeOptions {
	map?: "object" | "map";
	tagged?: Record<number, Replacer>;
}

export function decode(
	input: Uint8Array | Reader,
	options: DecodeOptions = {},
	// biome-ignore lint/suspicious/noExplicitAny: We don't know what it will return
): any {
	const r = input instanceof Reader ? input : new Reader(input);
	return decodeValue(r, options);
}

// biome-ignore lint/suspicious/noExplicitAny: We don't know what it will return
function decodeValue(r: Reader, options: DecodeOptions): any {
	const [major, len] = r.readMajor();
	switch (major) {
		case 0:
			return r.readMajorLength(len);
		case 1: {
			const l = r.readMajorLength(len);
			return typeof l === "bigint" ? -(l + 1n) : -(l + 1);
		}
		case 2: {
			if (len !== 31)
				return new Uint8Array(r.readBytes(Number(r.readMajorLength(len))))
					.buffer;
			return infiniteBytes(r, 2);
		}
		case 3: {
			const encoded =
				len !== 31
					? r.readBytes(Number(r.readMajorLength(len)))
					: infiniteBytes(r, 3);

			return textDecoder.decode(encoded);
		}

		case 4: {
			if (len !== 31) {
				const l = r.readMajorLength(len);
				const arr = Array(l);
				for (let i = 0; i < l; i++) arr[i] = decodeValue(r, options);
				return arr;
			}

			const arr = [];
			for (;;) {
				const byte = r.peekUint8();
				if (byte === 0xff) {
					r.skip();
					break;
				}
				arr.push(decodeValue(r, options));
			}

			return arr;
		}

		case 5: {
			if (options.map === "map") {
				const map = new Map<string, unknown>();
				if (len !== 31) {
					const l = r.readMajorLength(len);
					for (let i = 0; i < l; i++) {
						map.set(decodeValue(r, options), decodeValue(r, options));
					}
				} else {
					for (;;) {
						const byte = r.peekUint8();
						if (byte === 0xff) {
							r.skip();
							break;
						}

						map.set(decodeValue(r, options), decodeValue(r, options));
					}
				}

				return map;
			}

			const obj: Record<string, unknown> = {};
			if (len !== 31) {
				const l = r.readMajorLength(len);
				for (let i = 0; i < l; i++) {
					obj[decodeValue(r, options)] = decodeValue(r, options);
				}
			} else {
				for (;;) {
					const byte = r.peekUint8();
					if (byte === 0xff) {
						r.skip();
						break;
					}

					obj[decodeValue(r, options)] = decodeValue(r, options);
				}
			}

			return obj;
		}

		case 6: {
			const tag = Number(r.readMajorLength(len));
			const value = decodeValue(r, options);
			const replacer = options.tagged?.[tag];
			if (replacer) return replacer(value);
			return new Tagged(tag, value);
		}

		case 7: {
			switch (len) {
				case 20:
					return false;
				case 21:
					return true;
				case 22:
					return null;
				case 23:
					return undefined;
				case 25:
					return r.readFloat16();
				case 26:
					return r.readFloat32();
				case 27:
					return r.readFloat64();
				case 31:
					throw new CborBreak();
			}
		}
	}

	throw new CborInvalidMajorError(
		`Unable to decode value with major tag ${major}`,
	);
}



================================================
FILE: packages/cbor/src/encoded.ts
================================================
export class Encoded {
	constructor(readonly encoded: Uint8Array) {}
}



================================================
FILE: packages/cbor/src/encoder.ts
================================================
import { POW_2_53, POW_2_64, type Replacer } from "./constants";
import { Encoded } from "./encoded";
import { CborNumberError, CborPartialDisabled } from "./error";
import { type Fill, Gap } from "./gap";
import { PartiallyEncoded } from "./partial";
import { Tagged } from "./tagged";
import { Writer } from "./writer";

const textEncoder = new TextEncoder();

export interface EncoderOptions<Partial extends boolean = boolean> {
	replacer?: Replacer;
	writer?: Writer;
	partial?: Partial;
	fills?: Fill[];
}

function encode(input: unknown, options?: EncoderOptions<false>): Uint8Array;
function encode(
	input: unknown,
	options?: EncoderOptions<true>,
): PartiallyEncoded;
function encode(
	input: unknown,
	options: EncoderOptions = {},
): PartiallyEncoded | Uint8Array {
	const w = options.writer ?? new Writer();
	const fillsMap = new Map(options.fills ?? []);

	function inner(input: unknown) {
		// biome-ignore lint/style/noParameterAssign:
		input = options.replacer?.(input) ?? input;

		if (input === undefined) return w.writeUint8(0xf7);
		if (input === null) return w.writeUint8(0xf6);
		if (input === true) return w.writeUint8(0xf5);
		if (input === false) return w.writeUint8(0xf4);

		switch (typeof input) {
			case "number": {
				if (Number.isInteger(input)) {
					if (input >= 0 && input <= POW_2_53) {
						w.writeMajor(0, input);
					} else if (input < 0 && input >= -POW_2_53) {
						w.writeMajor(1, -(input + 1));
					} else {
						throw new CborNumberError("Number too big to be encoded");
					}
				} else {
					// Better precision when encoded as 64-bit
					w.writeUint8(0xfb);
					w.writeFloat64(input);
				}

				return;
			}

			case "bigint": {
				if (input >= 0 && input < POW_2_64) {
					w.writeMajor(0, input);
				} else if (input <= 0 && input >= -POW_2_64) {
					w.writeMajor(1, -(input + 1n));
				} else {
					throw new CborNumberError("BigInt too big to be encoded");
				}

				return;
			}

			case "string": {
				const encoded = textEncoder.encode(input);
				w.writeMajor(3, encoded.byteLength);
				w.writeUint8Array(encoded);
				return;
			}

			default: {
				if (Array.isArray(input)) {
					w.writeMajor(4, input.length);
					for (const v of input) {
						inner(v);
					}
					return;
				}

				if (input instanceof Tagged) {
					w.writeMajor(6, input.tag);
					inner(input.value);
					return;
				}

				if (input instanceof Encoded) {
					w.writeUint8Array(input.encoded);
					return;
				}

				if (input instanceof Gap) {
					if (fillsMap.has(input)) {
						inner(fillsMap.get(input));
					} else {
						if (options.partial) {
							w.chunk(input);
						} else {
							throw new CborPartialDisabled();
						}
					}

					return;
				}

				if (input instanceof PartiallyEncoded) {
					const res = options.partial
						? input.build(options.fills ?? [], true)
						: input.build(options.fills ?? [], false);

					if (res instanceof PartiallyEncoded) {
						w.writePartiallyEncoded(res);
					} else {
						w.writeUint8Array(res);
					}

					return;
				}

				if (
					input instanceof Uint8Array ||
					input instanceof Uint16Array ||
					input instanceof Uint32Array ||
					input instanceof Int8Array ||
					input instanceof Int16Array ||
					input instanceof Int32Array ||
					input instanceof Float32Array ||
					input instanceof Float64Array ||
					input instanceof ArrayBuffer
				) {
					const v = input instanceof Uint8Array ? input : new Uint8Array(input);
					w.writeMajor(2, v.byteLength);
					w.writeUint8Array(v);
					return;
				}

				if (input instanceof Map) {
					w.writeMajor(5, input.size);
					for (const [k, v] of input) {
						inner(k);
						inner(v);
					}
				} else {
					const entries = Object.entries(input);
					w.writeMajor(5, entries.length);
					for (const [k, v] of entries) {
						inner(k);
						inner(v);
					}
				}
			}
		}
	}

	inner(input);

	if (options.partial) {
		return w.output(true, options.replacer);
	}

	return w.output(false, options.replacer);
}

export { encode };



================================================
FILE: packages/cbor/src/error.ts
================================================
export abstract class CborError {
	abstract readonly name: string;
	readonly message: string;

	constructor(message: string) {
		this.message = message;
	}
}

export class CborNumberError extends CborError {
	name = "CborNumberError";
}

export class CborRangeError extends CborError {
	name = "CborRangeError";
}

export class CborInvalidMajorError extends CborError {
	name = "CborInvalidMajorError";
}

export class CborBreak extends CborError {
	name = "CborBreak";
	constructor() {
		super("Came across a break which was not intercepted by the decoder");
	}
}

export class CborPartialDisabled extends CborError {
	name = "CborPartialDisabled";
	constructor() {
		super(
			"Tried to insert a Gap into a CBOR value, while partial mode is not enabled",
		);
	}
}

export class CborFillMissing extends CborError {
	name = "CborFillMissing";
	constructor() {
		super("Fill for a gap is missing, and gap has no default");
	}
}



================================================
FILE: packages/cbor/src/gap.ts
================================================
// Why is the default value being stored in an array? undefined, null, false, etc... are all valid defaults,
// and specifying a field on a class as optional will make it undefined by default.

export type Fill<T = unknown> = [Gap<T>, T];
export class Gap<T = unknown> {
	readonly args: [T?] = [];
	constructor(...args: [T?]) {
		this.args = args;
	}

	fill(value: T): Fill<T> {
		return [this, value];
	}

	hasDefault(): boolean {
		return this.args.length === 1;
	}

	get default(): T | undefined {
		return this.args[0];
	}
}



================================================
FILE: packages/cbor/src/index.ts
================================================
export * from "./constants";
export * from "./encoder";
export * from "./decoder";
export * from "./util";
export * from "./reader";
export * from "./writer";
export * from "./tagged";
export * from "./error";
export * from "./gap";
export * from "./partial";
export * from "./encoded";



================================================
FILE: packages/cbor/src/partial.ts
================================================
import type { Replacer } from "./constants";
import { type EncoderOptions, encode } from "./encoder";
import { CborFillMissing } from "./error";
import type { Fill, Gap } from "./gap";
import { Writer } from "./writer";

export class PartiallyEncoded {
	constructor(
		readonly chunks: [Uint8Array, Gap][],
		readonly end: Uint8Array,
		readonly replacer: Replacer | undefined,
	) {}

	build(fills: Fill[], partial?: false): Uint8Array;
	build(fills: Fill[], partial: true): PartiallyEncoded;
	build(fills: Fill[], partial?: boolean): PartiallyEncoded | Uint8Array {
		const writer = new Writer();
		const map = new Map(fills);

		for (const [buffer, gap] of this.chunks) {
			const hasValue = map.has(gap) || gap.hasDefault();
			if (!partial && !hasValue) throw new CborFillMissing();
			writer.writeUint8Array(buffer);

			if (hasValue) {
				const data = map.get(gap) ?? gap.default;
				encode(data, {
					writer,
					replacer: this.replacer,
				});
			} else {
				writer.chunk(gap);
			}
		}

		writer.writeUint8Array(this.end);
		if (partial) {
			return writer.output(true, this.replacer);
		}

		return writer.output(false, this.replacer);
	}
}

export function partiallyEncodeObject(
	object: Record<string, unknown>,
	options?: EncoderOptions<true>,
): Record<string, PartiallyEncoded> {
	return Object.fromEntries(
		Object.entries(object).map(([k, v]) => [
			k,
			encode(v, { ...options, partial: true }),
		]),
	);
}



================================================
FILE: packages/cbor/src/reader.ts
================================================
import { type Major, POW_2_53 } from "./constants";
import { CborInvalidMajorError, CborRangeError } from "./error";

// Float16 constants
const F16_SIGN_MASK = 0x8000;
const F16_EXP_MASK = 0x7c00;
const F16_FRAC_MASK = 0x03ff;
const F16_EXP_SHIFT = 10;
const F16_EXP_BIAS = 15;
const F16_EXP_INF_NAN = 0x1f;
const F16_FRAC_SCALE = 1024;
const F16_SUBNORMAL_SCALE = 2 ** -14;

// Optional: Precomputed exponent powers for float16
const FLOAT16_EXP_LUT = Array.from(
	{ length: 31 },
	(_, e) => 2 ** (e - F16_EXP_BIAS),
);

export class Reader {
	private _view: DataView;
	private _byte: Uint8Array;
	private _pos = 0;

	constructor(buffer: Uint8Array) {
		this._byte = buffer;
		this._view = new DataView(
			buffer.buffer,
			buffer.byteOffset,
			buffer.byteLength,
		);
	}

	skip(amount = 1): void {
		const pos = this._pos;
		if (this._byte.length - pos < amount)
			throw new CborRangeError("Tried to read 1 byte beyond buffer bounds");
		this._pos = pos + amount;
	}

	peekUint8(): number {
		const pos = this._pos;
		if (this._byte.length - pos < 1)
			throw new CborRangeError("Tried to read 1 byte beyond buffer bounds");
		return this._view.getUint8(pos);
	}

	readUint8(): number {
		const pos = this._pos;
		if (this._byte.length - pos < 1)
			throw new CborRangeError("Tried to read 1 byte beyond buffer bounds");
		const val = this._view.getUint8(pos);
		this._pos = pos + 1;
		return val;
	}

	readUint16(): number {
		const pos = this._pos;
		if (this._byte.length - pos < 2)
			throw new CborRangeError("Tried to read 2 bytes beyond buffer bounds");
		const val = this._view.getUint16(pos);
		this._pos = pos + 2;
		return val;
	}

	readUint32(): number {
		const pos = this._pos;
		if (this._byte.length - pos < 4)
			throw new CborRangeError("Tried to read 4 bytes beyond buffer bounds");
		const val = this._view.getUint32(pos);
		this._pos = pos + 4;
		return val;
	}

	readUint64(): bigint {
		const pos = this._pos;
		if (this._byte.length - pos < 8)
			throw new CborRangeError("Tried to read 8 bytes beyond buffer bounds");
		const val = this._view.getBigUint64(pos);
		this._pos = pos + 8;
		return val;
	}

	readFloat16(): number {
		const val = this.readUint16();

		const sign = val & F16_SIGN_MASK ? -1 : 1;
		const exp = (val & F16_EXP_MASK) >> F16_EXP_SHIFT;
		const frac = val & F16_FRAC_MASK;

		if (exp === 0) {
			return sign * (frac / F16_FRAC_SCALE) * F16_SUBNORMAL_SCALE;
		}
		if (exp === F16_EXP_INF_NAN) {
			return frac ? Number.NaN : sign * Number.POSITIVE_INFINITY;
		}
		return sign * (1 + frac / F16_FRAC_SCALE) * FLOAT16_EXP_LUT[exp];
	}

	readFloat32(): number {
		const pos = this._pos;
		if (this._byte.length - pos < 4)
			throw new CborRangeError(
				"Tried to read 4 bytes for float32 beyond buffer bounds",
			);
		const val = this._view.getFloat32(pos);
		this._pos = pos + 4;
		return val;
	}

	readFloat64(): number {
		const pos = this._pos;
		if (this._byte.length - pos < 8)
			throw new CborRangeError(
				"Tried to read 8 bytes for float64 beyond buffer bounds",
			);
		const val = this._view.getFloat64(pos);
		this._pos = pos + 8;
		return val;
	}

	readBytes(amount: number): Uint8Array {
		const pos = this._pos;
		if (this._byte.length - pos < amount)
			throw new CborRangeError(`Tried to read ${amount} bytes beyond buffer`);
		this._pos = pos + amount;
		return this._byte.subarray(pos, this._pos);
	}

	readMajor(): [Major, number] {
		const byte = this.readUint8();
		const major = (byte >> 5) as Major;
		if (major < 0 || major > 7)
			throw new CborInvalidMajorError("Received invalid major type");
		return [major, byte & 0x1f];
	}

	readMajorLength(length: number): number | bigint {
		if (length <= 23) return length;
		if (length === 24) return this.readUint8();
		if (length === 25) return this.readUint16();
		if (length === 26) return this.readUint32();
		if (length === 27) {
			const read = this.readUint64();
			return read > POW_2_53 ? read : Number(read);
		}
		throw new CborRangeError("Expected a final length");
	}
}



================================================
FILE: packages/cbor/src/tagged.ts
================================================
export class Tagged<T = unknown> {
	constructor(
		readonly tag: number | bigint,
		readonly value: T,
	) {}
}



================================================
FILE: packages/cbor/src/util.ts
================================================
import type { Major } from "./constants";
import { CborInvalidMajorError, CborRangeError } from "./error";
import type { Reader } from "./reader";
import { Writer } from "./writer";

export function infiniteBytes(r: Reader, forMajor: Major): ArrayBuffer {
	const w = new Writer();
	while (true) {
		const [major, len] = r.readMajor();

		// Received break signal
		if (major === 7 && len === 31) break;

		// Resource type has to match
		if (major !== forMajor)
			throw new CborInvalidMajorError(
				`Expected a resource of the same major (${forMajor}) while processing an infinite resource`,
			);

		// Cannot have an infinite resource in an infinite resource
		if (len === 31)
			throw new CborRangeError(
				"Expected a finite resource while processing an infinite resource",
			);

		w.writeUint8Array(r.readBytes(Number(r.readMajorLength(len))));
	}

	return w.buffer.buffer as ArrayBuffer;
}



================================================
FILE: packages/cbor/src/writer.ts
================================================
import type { Major, Replacer } from "./constants";
import type { Gap } from "./gap";
import { PartiallyEncoded } from "./partial";

export class Writer {
	private _chunks: [Uint8Array, Gap][] = [];
	private _pos = 0;
	private _buf: ArrayBuffer;
	private _view: DataView;
	private _byte: Uint8Array;

	constructor(readonly byteLength = 256) {
		this._buf = new ArrayBuffer(this.byteLength);
		this._view = new DataView(this._buf);
		this._byte = new Uint8Array(this._buf);
	}

	chunk(gap: Gap): void {
		this._chunks.push([this._byte.subarray(0, this._pos), gap]);
		this._buf = new ArrayBuffer(this.byteLength);
		this._view = new DataView(this._buf);
		this._byte = new Uint8Array(this._buf);
		this._pos = 0;
	}

	get chunks(): [Uint8Array, Gap][] {
		return this._chunks;
	}

	get buffer(): Uint8Array {
		return this._byte.subarray(0, this._pos);
	}

	private claim(length: number): number {
		const pos = this._pos;
		this._pos += length;

		if (this._pos <= this._buf.byteLength) return pos;

		// Resize with exponential growth
		let newLen = this._buf.byteLength << 1;
		while (newLen < this._pos) newLen <<= 1;

		const oldb = this._byte;
		this._buf = new ArrayBuffer(newLen);
		this._view = new DataView(this._buf);
		this._byte = new Uint8Array(this._buf);
		this._byte.set(oldb);

		return pos;
	}

	writeUint8(value: number): void {
		const pos = this.claim(1);
		this._byte[pos] = value;
	}

	writeUint16(value: number): void {
		const pos = this.claim(2);
		this._view.setUint16(pos, value, false);
	}

	writeUint32(value: number): void {
		const pos = this.claim(4);
		this._view.setUint32(pos, value, false);
	}

	writeUint64(value: bigint): void {
		const pos = this.claim(8);
		this._view.setBigUint64(pos, value, false);
	}

	writeFloat32(value: number): void {
		const pos = this.claim(4);
		this._view.setFloat32(pos, value, false);
	}

	writeFloat64(value: number): void {
		const pos = this.claim(8);
		this._view.setFloat64(pos, value, false);
	}

	writeUint8Array(data: Uint8Array): void {
		if (data.byteLength === 0) return;
		const pos = this.claim(data.byteLength);
		this._byte.set(data, pos);
	}

	writePartiallyEncoded(data: PartiallyEncoded): void {
		for (const [buf, gap] of data.chunks) {
			this.writeUint8Array(buf);
			this.chunk(gap);
		}

		this.writeUint8Array(data.end);
	}

	writeMajor(type: Major, length: number | bigint): void {
		const base = type << 5;
		if (typeof length === "number") {
			if (length < 24) {
				this.writeUint8(base + length);
			} else if (length < 0x100) {
				this.writeUint8(base + 24);
				this.writeUint8(length);
			} else if (length < 0x10000) {
				this.writeUint8(base + 25);
				this.writeUint16(length);
			} else if (length < 0x100000000) {
				this.writeUint8(base + 26);
				this.writeUint32(length);
			} else {
				this.writeUint8(base + 27);
				this.writeUint64(BigInt(length));
			}
		} else {
			// bigint path
			if (length < 24n) {
				this.writeUint8(base + Number(length));
			} else if (length < 0x100n) {
				this.writeUint8(base + 24);
				this.writeUint8(Number(length));
			} else if (length < 0x10000n) {
				this.writeUint8(base + 25);
				this.writeUint16(Number(length));
			} else if (length < 0x100000000n) {
				this.writeUint8(base + 26);
				this.writeUint32(Number(length));
			} else {
				this.writeUint8(base + 27);
				this.writeUint64(length);
			}
		}
	}

	output(partial?: false, replacer?: Replacer): Uint8Array;
	output(partial: true, replacer?: Replacer): PartiallyEncoded;
	output(partial = false, replacer?: Replacer): Uint8Array | PartiallyEncoded {
		if (partial) {
			return new PartiallyEncoded(this._chunks, this.buffer, replacer);
		}
		return this.buffer;
	}
}



================================================
FILE: packages/sdk/package.json
================================================
{
	"name": "surrealdb",
	"version": "2.0.0-alpha.3",
	"type": "module",
	"license": "Apache-2.0",
	"description": "The official SurrealDB SDK for JavaScript.",
	"keywords": ["surrealdb", "surrealdb.js", "javascript", "typescript"],
	"repository": {
		"type": "git",
		"url": "git+https://github.com/surrealdb/surrealdb.js.git"
	},
	"homepage": "https://github.com/surrealdb/surrealdb.js",
	"packageManager": "^bun@1.1.17",
	"devDependencies": {
		"@types/bun": "latest",
		"compare-versions": "^6.1.1"
	},
	"peerDependencies": {
		"typescript": "^5.0.0",
		"tslib": "^2.6.3"
	},
	"dependencies": {
		"@surrealdb/cbor": "workspace:*",
		"uuidv7": "^1.0.1"
	},
	"scripts": {
		"ts": "tsc --watch --noEmit true --emitDeclarationOnly false",
		"qc": "biome check .",
		"qa": "biome check . --write",
		"qau": "biome check . --write --unsafe",
		"build": "bun run scripts/build.ts",
		"jsr": "bun run scripts/jsr.ts"
	},
	"engines": {
		"node": ">=18.0.0"
	},
	"browser": "./dist/index.bundled.mjs",
	"types": "./dist/index.d.ts",
	"main": "./dist/index.mjs",
	"exports": {
		".": {
			"require": "./dist/index.cjs",
			"import": "./dist/index.mjs",
			"types": "./dist/index.d.ts",
			"browser": "./dist/index.bundled.mjs"
		}
	},
	"files": ["dist", "README.md", "LICENCE", "SECURITY.md"]
}



================================================
FILE: packages/sdk/tsconfig.json
================================================
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"isolatedDeclarations": false
	}
}



================================================
FILE: packages/sdk/src/errors.ts
================================================
import type { RpcErrorResponse } from "./types";

export class SurrealError extends Error {}

/**
 * Thrown when an operation depends on an active connection
 */
export class NoActiveConnection extends SurrealError {
	name = "NoActiveConnection";
	message =
		"You must call the connect() method before performing this operation";
}

/**
 * Thrown when an engine received an unexpected response
 */
export class UnexpectedResponse extends SurrealError {
	name = "UnexpectedResponse";
	message =
		"The returned response from the SurrealDB instance is in an unexpected format. Unable to process response!";
}

/**
 * Thrown when a provided connection URL is unsupported
 */
export class InvalidURLProvided extends SurrealError {
	name = "InvalidURLProvided";
	message =
		"The provided string is either not a URL or is a URL but with an invalid protocol!";
}

/**
 * Thrown when an engine disconnected from a datastore
 */
export class EngineDisconnected extends SurrealError {
	name = "EngineDisconnected";
	message = "The engine reported the connection to SurrealDB has dropped";
}

/**
 * Thrown when reconnect attempts have been exhausted
 */
export class ReconnectExhaustion extends SurrealError {
	name = "ReconnectExhaustion";
	message = "The engine failed exhausted all reconnect attempts";
}

/**
 * Thrown when a reconnect iterator fails to iterate
 */
export class ReconnectIterationError extends SurrealError {
	name = "ReconnectIterationError";
	message = "The reconnect iterator failed to iterate";
}

/**
 * Thriwn when an unexpected response is received from the server
 */
export class UnexpectedServerResponse extends SurrealError {
	name = "UnexpectedServerResponse";

	constructor(public readonly response: unknown) {
		super();
		this.message = `${response}`;
	}
}

/**
 * Thrown when an unexpected connection error occurs
 */
export class UnexpectedConnectionError extends SurrealError {
	name = "UnexpectedConnectionError";
	message = "An unexpected connection error occurred";

	constructor(cause: unknown) {
		super();
		this.cause = cause;
	}
}

/**
 * Thrown when an engine is not supported
 */
export class UnsupportedEngine extends SurrealError {
	name = "UnsupportedEngine";
	message =
		"The engine you are trying to connect to is not supported or configured";

	constructor(public readonly engine: string) {
		super();
	}
}

/**
 * Thrown when a feature is not available for the current engine
 */
export class FeatureUnavailableForEngine extends SurrealError {
	name = "FeatureUnavailableForEngine";
	message = "The feature you are trying to use is not available on this engine";
}

/**
 * Thrown when there is no connection available
 */
export class ConnectionUnavailable extends SurrealError {
	name = "ConnectionUnavailable";
	message = "There is no connection available at this moment";
}

/**
 * Thrown when there is no namespace and/or database selected
 */
export class MissingNamespaceDatabase extends SurrealError {
	name = "MissingNamespaceDatabase";
	message = "There is no namespace and/or database selected";
}

/**
 * Thrown when a connection to the server fails
 */
export class HttpConnectionError extends SurrealError {
	name = "HttpConnectionError";

	constructor(
		public readonly message: string,
		public readonly status: number,
		public readonly statusText: string,
		public readonly buffer: ArrayBuffer,
	) {
		super();
	}
}

/**
 * Thrown when a response from the server is not as expected
 */
export class ResponseError extends SurrealError {
	name = "ResponseError";

	constructor(public readonly message: string) {
		super();
	}
}

/**
 * Thrown when a namespace was not specified
 *
 * TODO Replace with `MissingNamespaceDatabase`
 */
export class NoNamespaceSpecified extends SurrealError {
	name = "NoNamespaceSpecified";
	message = "Please specify a namespace to use";
}

/**
 * Thrown when a database was not specified
 *
 * TODO Replace with `MissingNamespaceDatabase`
 */
export class NoDatabaseSpecified extends SurrealError {
	name = "NoDatabaseSpecified";
	message = "Please specify a database to use";
}

/**
 * Thrown when a token was not returned
 */
export class NoTokenReturned extends SurrealError {
	name = "NoTokenReturned";
	message = "Did not receive an authentication token";
}

/**
 * Thrown when authentication fails
 */
export class AuthenticationFailed extends SurrealError {
	name = "AuthenticationFailed";
	message = "Authentication did not succeed";

	constructor(cause: unknown) {
		super();
		this.cause = cause;
	}
}

/**
 * Thrown when a live subscription fails to listen
 */
export class LiveSubscriptionFailed extends SurrealError {
	name = "LiveSubscriptionFailed";
	message = "Live subscription failed to listen";

	constructor(public readonly response: RpcErrorResponse) {
		super();
		this.message = response.error.message;
	}
}

/**
 * Thrown when the version of the remote datastore is not supported
 */
export class UnsupportedVersion extends SurrealError {
	name = "UnsupportedVersion";
	version: string;
	supportedRange: string;

	constructor(version: string, supportedRange: string) {
		super();
		this.version = version;
		this.supportedRange = supportedRange;
		this.message = `The version "${version}" reported by the engine is not supported by this library, expected a version that satisfies "${supportedRange}"`;
	}
}

/**
 * Thrown when version checking is unsuccessful
 */
export class VersionCheckFailure extends SurrealError {
	name = "VersionCheckFailure";
	message = "Failed to check version compatibility with the SurrealDB instance";

	constructor(
		readonly error?: Error | undefined,
		readonly response?: {
			code: number;
			message: string;
		},
	) {
		super();
	}
}



================================================
FILE: packages/sdk/src/index.ts
================================================
export * from "./value";
export * from "./errors";
export * from "./surreal";
export * from "./engine";
export * from "./cbor";
export * from "./utils";
export * from "./types";

export { Surreal as default } from "./surreal";



================================================
FILE: packages/sdk/src/cbor/index.ts
================================================
export { encodeCbor, decodeCbor } from "./replacer.ts";



================================================
FILE: packages/sdk/src/cbor/replacer.ts
================================================
import { type Replacer, Tagged, decode, encode } from "@surrealdb/cbor";
import { BoundExcluded, BoundIncluded } from "../utils/range";
import {
	Decimal,
	Duration,
	Future,
	GeometryCollection,
	GeometryLine,
	GeometryMultiLine,
	GeometryMultiPoint,
	GeometryMultiPolygon,
	GeometryPoint,
	GeometryPolygon,
	Range,
	RecordId,
	RecordIdRange,
	StringRecordId,
	Table,
	Uuid,
} from "../value";
import {
	cborCustomDateToDate,
	cborToRange,
	dateToCborCustomDate,
	rangeToCbor,
} from "./utils";

// Tags from the spec - https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml
const TAG_SPEC_DATETIME = 0;
const TAG_SPEC_UUID = 37;

// Custom tags
const TAG_NONE = 6;
const TAG_TABLE = 7;
const TAG_RECORDID = 8;
const TAG_STRING_UUID = 9;
const TAG_STRING_DECIMAL = 10;
// const TAG_BINARY_DECIMAL = 11;
const TAG_CUSTOM_DATETIME = 12;
const TAG_STRING_DURATION = 13;
const TAG_CUSTOM_DURATION = 14;
const TAG_FUTURE = 15;

// Ranges
export const TAG_RANGE = 49;
export const TAG_BOUND_INCLUDED = 50;
export const TAG_BOUND_EXCLUDED = 51;

// Custom Geometries
const TAG_GEOMETRY_POINT = 88;
const TAG_GEOMETRY_LINE = 89;
const TAG_GEOMETRY_POLYGON = 90;
const TAG_GEOMETRY_MULTIPOINT = 91;
const TAG_GEOMETRY_MULTILINE = 92;
const TAG_GEOMETRY_MULTIPOLYGON = 93;
const TAG_GEOMETRY_COLLECTION = 94;

/**
 * The cbor replacer for SurrealDB values
 */
export const REPLACER = {
	encode(v: unknown): unknown {
		if (v instanceof Date) {
			return new Tagged(TAG_CUSTOM_DATETIME, dateToCborCustomDate(v));
		}
		if (v === undefined) return new Tagged(TAG_NONE, null);
		if (v instanceof Uuid) {
			return new Tagged(TAG_SPEC_UUID, v.toBuffer());
		}
		if (v instanceof Decimal) {
			return new Tagged(TAG_STRING_DECIMAL, v.toString());
		}
		if (v instanceof Duration) {
			return new Tagged(TAG_CUSTOM_DURATION, v.toCompact());
		}
		if (v instanceof RecordId) {
			return new Tagged(TAG_RECORDID, [v.table.name, v.id]);
		}
		if (v instanceof StringRecordId) {
			return new Tagged(TAG_RECORDID, v.rid);
		}
		if (v instanceof RecordIdRange) {
			return new Tagged(TAG_RECORDID, [
				v.table.name,
				new Tagged(TAG_RANGE, rangeToCbor([v.beg, v.end])),
			]);
		}
		if (v instanceof Table) return new Tagged(TAG_TABLE, v.name);
		if (v instanceof Future) return new Tagged(TAG_FUTURE, v.inner);
		if (v instanceof Range)
			return new Tagged(TAG_RANGE, rangeToCbor([v.beg, v.end]));
		if (v instanceof GeometryPoint) {
			return new Tagged(TAG_GEOMETRY_POINT, v.point);
		}
		if (v instanceof GeometryLine) {
			return new Tagged(TAG_GEOMETRY_LINE, v.line);
		}
		if (v instanceof GeometryPolygon) {
			return new Tagged(TAG_GEOMETRY_POLYGON, v.polygon);
		}
		if (v instanceof GeometryMultiPoint) {
			return new Tagged(TAG_GEOMETRY_MULTIPOINT, v.points);
		}
		if (v instanceof GeometryMultiLine) {
			return new Tagged(TAG_GEOMETRY_MULTILINE, v.lines);
		}
		if (v instanceof GeometryMultiPolygon) {
			return new Tagged(TAG_GEOMETRY_MULTIPOLYGON, v.polygons);
		}
		if (v instanceof GeometryCollection) {
			return new Tagged(TAG_GEOMETRY_COLLECTION, v.collection);
		}
		return v;
	},
	decode: {
		[TAG_SPEC_DATETIME]: (v) => new Date(v),
		[TAG_SPEC_UUID]: (v) => new Uuid(v),
		[TAG_STRING_UUID]: (v) => new Uuid(v),
		[TAG_CUSTOM_DATETIME]: cborCustomDateToDate,
		[TAG_NONE]: (v) => undefined,
		[TAG_STRING_DECIMAL]: (v) => new Decimal(v),
		[TAG_STRING_DURATION]: (v) => new Duration(v),
		[TAG_CUSTOM_DURATION]: (v) => Duration.fromCompact(v),
		[TAG_TABLE]: (v) => new Table(v),
		[TAG_FUTURE]: (v) => new Future(v),
		[TAG_RANGE]: (v) => new Range(...cborToRange(v)),
		[TAG_BOUND_INCLUDED]: (v) => new BoundIncluded(v),
		[TAG_BOUND_EXCLUDED]: (v) => new BoundExcluded(v),
		[TAG_RECORDID]: (v) => {
			if (v[1] instanceof Range) {
				return new RecordIdRange(v[0], v[1].beg, v[1].end);
			}
			return new RecordId(v[0], v[1]);
		},
		[TAG_GEOMETRY_POINT]: (v) => new GeometryPoint(v),
		[TAG_GEOMETRY_LINE]: (v) => new GeometryLine(v),
		[TAG_GEOMETRY_POLYGON]: (v) => new GeometryPolygon(v),
		[TAG_GEOMETRY_MULTIPOINT]: (v) => new GeometryMultiPoint(v),
		[TAG_GEOMETRY_MULTILINE]: (v) => new GeometryMultiLine(v),
		[TAG_GEOMETRY_MULTIPOLYGON]: (v) => new GeometryMultiPolygon(v),
		[TAG_GEOMETRY_COLLECTION]: (v) => new GeometryCollection(v),
	} satisfies Record<number, Replacer>,
};

Object.freeze(REPLACER);

/**
 * Recursively encode any supported SurrealQL value into a binary CBOR representation
 *
 * @param data - The input value
 * @returns CBOR binary representation
 */
export function encodeCbor<T>(data: T): Uint8Array {
	return encode(data, {
		replacer: REPLACER.encode,
		partial: false,
	});
}

/**
 * Decode a CBOR encoded SurrealQL value into object representation
 *
 * @param data - The encoded SurrealQL value
 * @returns The parsed SurrealQL value
 */
export function decodeCbor<T>(data: Uint8Array): T {
	return decode(data, {
		tagged: REPLACER.decode,
	});
}



================================================
FILE: packages/sdk/src/cbor/utils.ts
================================================
import { Tagged } from "@surrealdb/cbor";
import { SurrealError } from "../errors";
import { type Bound, BoundExcluded, BoundIncluded } from "../utils/range";
import { TAG_BOUND_EXCLUDED, TAG_BOUND_INCLUDED } from "./replacer";

type DecodedBound = BoundIncluded<unknown> | BoundExcluded<unknown> | null;

export function dateToCborCustomDate(date: Date): [number, number] {
	const s = Math.floor(date.getTime() / 1000);
	const ms = date.getTime() - s * 1000;
	return [s, ms * 1000000];
}

export function cborCustomDateToDate([s, ns]: [number, number]): Date {
	const date = new Date(0);
	date.setUTCSeconds(Number(s));
	date.setMilliseconds(Math.floor(Number(ns) / 1000000));
	return date;
}

export function rangeToCbor([beg, end]: [Bound<unknown>, Bound<unknown>]): [
	Tagged | null,
	Tagged | null,
] {
	function encodeBound(bound: Bound<unknown>): Tagged | null {
		if (bound instanceof BoundIncluded)
			return new Tagged(TAG_BOUND_INCLUDED, bound.value);
		if (bound instanceof BoundExcluded)
			return new Tagged(TAG_BOUND_EXCLUDED, bound.value);
		return null;
	}

	return [encodeBound(beg), encodeBound(end)];
}

export function cborToRange(
	range: [DecodedBound | null, DecodedBound | null],
): [Bound<unknown>, Bound<unknown>] {
	function decodeBound(bound: DecodedBound | null): Bound<unknown> {
		if (bound === null) return undefined;
		if (bound instanceof BoundIncluded) return bound;
		if (bound instanceof BoundExcluded) return bound;
		throw new SurrealError("Expected the bounds to be decoded already");
	}

	return [decodeBound(range[0]), decodeBound(range[1])];
}



================================================
FILE: packages/sdk/src/controller/index.ts
================================================
import type {
	AnyAuth,
	AuthOrToken,
	AuthProvider,
	AuthRenewer,
	AuthResponse,
	ConnectOptions,
	ConnectionState,
	ConnectionStatus,
	DriverContext,
	EngineImpl,
	EventPublisher,
	ExportOptions,
	LiveHandler,
	LiveMessage,
	LivePayload,
	RpcRequest,
	RpcResponse,
	SurrealEngine,
	Token,
} from "../types";

import {
	AuthenticationFailed,
	ConnectionUnavailable,
	SurrealError,
	UnsupportedEngine,
	VersionCheckFailure,
} from "../errors";

import { HttpEngine, WebSocketEngine } from "../engine";
import { ReconnectContext } from "../internal/reconnect";
import { fastParseJwt } from "../internal/tokens";
import { versionCheck } from "../utils";
import { Publisher } from "../utils/publisher";
import type { Uuid } from "../value";

const DEFAULT_ENGINES: Record<string, EngineImpl> = {
	ws: WebSocketEngine,
	wss: WebSocketEngine,
	http: HttpEngine,
	https: HttpEngine,
};

type ConnectionEvents = {
	connecting: [];
	connected: [];
	disconnected: [];
	reconnecting: [];
	error: [Error];
	authenticated: [Token];
	invalidated: [];
};

type LiveChannels = Record<string, LivePayload>;
type ConvertedAuth = Record<string, unknown> | Token;

export class ConnectionController implements EventPublisher<ConnectionEvents> {
	#eventPublisher = new Publisher<ConnectionEvents>();
	#livePublisher = new Publisher<LiveChannels>();
	#context: DriverContext;
	#state: ConnectionState | undefined;
	#engine: SurrealEngine | undefined;
	#status: ConnectionStatus = "disconnected";
	#authProvider: AuthProvider | undefined;
	#authRenewal: ReturnType<typeof setTimeout> | undefined;
	#renewAccess: AuthRenewer = false;
	#checkVersion = true;

	subscribe<K extends keyof ConnectionEvents>(
		event: K,
		listener: (...payload: ConnectionEvents[K]) => void,
	): () => void {
		return this.#eventPublisher.subscribe(event, listener);
	}

	constructor(context: DriverContext) {
		this.#context = context;
	}

	public async connect(url: URL, options: ConnectOptions): Promise<true> {
		if (this.#engine) {
			await this.#engine.close();
		}

		const engineMap = { ...DEFAULT_ENGINES, ...this.#context.options.engines };
		const protocol = url.protocol.slice(0, -1);
		const Engine = engineMap[protocol];

		if (!Engine) {
			throw new UnsupportedEngine(protocol);
		}

		this.#engine = new Engine(this.#context);
		this.#authProvider = options.authentication;
		this.#checkVersion = options.versionCheck ?? true;
		this.#renewAccess = options.renewAccess ?? true;
		this.#state = {
			url,
			variables: {},
			namespace: options.namespace,
			database: options.database,
			accessToken: undefined,
			reconnect: new ReconnectContext(options.reconnect),
		};

		this.#engine.subscribe("connecting", () => this.onConnecting());
		this.#engine.subscribe("connected", () => this.onConnected());
		this.#engine.subscribe("disconnected", () => this.onDisconnected());
		this.#engine.subscribe("reconnecting", () => this.onReconnecting());
		this.#engine.subscribe("live", (msg) => this.onLiveMessage(msg));

		this.#engine.open(this.#state);

		await this.ready();

		return true;
	}

	public async disconnect(): Promise<true> {
		if (this.#engine) {
			await this.#engine.close();
		}

		return true;
	}

	public async rpc<
		Method extends string,
		Params extends unknown[] | undefined,
		Result,
	>(request: RpcRequest<Method, Params>): Promise<RpcResponse<Result>> {
		if (!this.#state || !this.#engine) {
			throw new ConnectionUnavailable();
		}

		// Synchronize with local state
		switch (request.method) {
			case "use": {
				const [ns, db] = request.params as [
					string | null | undefined,
					string | null | undefined,
				];

				if (ns === null) this.#state.namespace = undefined;
				if (db === null) this.#state.database = undefined;
				if (ns) this.#state.namespace = ns;
				if (db) this.#state.database = db;
				break;
			}
			case "let": {
				const [key, value] = request.params as [string, unknown];
				this.#state.variables[key] = value;
				break;
			}
			case "unset": {
				const [key] = request.params as [string];
				delete this.#state.variables[key];
				break;
			}
		}

		// Send the request to the underlying engine
		const response: RpcResponse<Result> = await this.#engine.send(request);

		// Update authentication state
		if ("result" in response) {
			switch (request.method) {
				case "signin":
				case "signup": {
					const result = response.result as string | AuthResponse;

					if (typeof result === "string") {
						this.#state.accessToken = result;
					} else {
						this.#state.accessToken = result.token;
						this.#state.refreshToken = result.refresh;
					}

					this.handleAuthUpdate();
					break;
				}
				case "authenticate": {
					const [token] = request.params as [string];
					this.#state.accessToken = token;

					this.handleAuthUpdate();
					break;
				}
				case "invalidate": {
					this.handleAuthInvalidate();
					break;
				}
				case "reset": {
					this.#state.namespace = undefined;
					this.#state.database = undefined;
					this.#state.variables = {};
					this.handleAuthInvalidate();
					break;
				}
			}
		}

		return response;
	}

	public get state(): ConnectionState | undefined {
		return this.#state;
	}

	public get status(): ConnectionStatus {
		return this.#status;
	}

	public liveSubscribe(id: Uuid, handler: LiveHandler): () => void {
		return this.#livePublisher.subscribe(id.toString(), (...payload) =>
			handler(...payload),
		);
	}

	public async ready(): Promise<void> {
		if (this.#status === "disconnected") {
			throw new ConnectionUnavailable();
		}

		if (this.#status === "connected") {
			return;
		}

		const [error] = await this.#eventPublisher.subscribeFirst(
			"connected",
			"error",
		);

		if (error) {
			throw error;
		}
	}

	public async import(data: string): Promise<void> {
		if (!this.#engine) {
			throw new ConnectionUnavailable();
		}

		return this.#engine.import(data);
	}

	public async export(options?: Partial<ExportOptions>): Promise<string> {
		if (!this.#engine) {
			throw new ConnectionUnavailable();
		}

		return this.#engine.export(options);
	}

	public buildAuth(auth: AnyAuth): Record<string, unknown> {
		if (!this.#state) {
			throw new ConnectionUnavailable();
		}

		if ("key" in auth) {
			return {
				ns: auth.namespace,
				db: auth.database,
				ac: auth.access,
				key: auth.key,
			};
		}

		// Record user authentication
		if ("variables" in auth) {
			const namespace = auth.namespace ?? this.#state.namespace;
			const database = auth.database ?? this.#state.database;

			if (!database || !namespace) {
				throw new SurrealError(
					"Namespace and database must be provided or selected for record authentication",
				);
			}

			return {
				...auth.variables,
				ac: auth.access,
				ns: namespace,
				db: database,
			};
		}

		// System authentication
		const access = "access" in auth ? auth.access : undefined;
		const namespace = "namespace" in auth ? auth.namespace : undefined;
		const database = "database" in auth ? auth.database : undefined;
		const result: Record<string, unknown> = {
			user: auth.username,
			pass: auth.password,
		};

		if (database && !namespace) {
			throw new SurrealError(
				"Database authentication requires a namespace to be provided",
			);
		}

		if (access) result.ac = access;
		if (namespace) result.ns = namespace;
		if (database) result.db = database;

		return result;
	}

	private onConnecting(): void {
		this.#status = "connecting";
		this.#eventPublisher.publish("connecting");
	}

	private async onConnected(): Promise<void> {
		try {
			// Perform version check
			if (this.#checkVersion) {
				const version: RpcResponse<string> = await this.rpc({
					method: "version",
				});

				if (version.result) {
					versionCheck(version.result);
				} else {
					throw new VersionCheckFailure(undefined, version.error);
				}
			}

			// Apply selected namespace and database
			if (this.#state?.namespace || this.#state?.database) {
				await this.rpc({
					method: "use",
					params: [this.#state.namespace, this.#state.database],
				});
			}

			// Apply authentication details
			await this.applyAuthProvider();

			this.#status = "connected";
			this.#eventPublisher.publish("connected");
		} catch (err: unknown) {
			this.#eventPublisher.publish("error", err as Error);
			this.#engine?.close();
			return;
		}
	}

	private onDisconnected(): void {
		this.#state = undefined;
		this.#engine = undefined;
		this.#status = "disconnected";
		this.#eventPublisher.publish("disconnected");
		this.cancelAuthRenewal();
	}

	private onReconnecting(): void {
		this.#status = "reconnecting";
		this.#eventPublisher.publish("reconnecting");
	}

	private onLiveMessage(msg: LiveMessage): void {
		if (msg.action === "KILLED") {
			this.#livePublisher.publish(msg.id.toString(), "CLOSED", "KILLED");
		} else {
			this.#livePublisher.publish(
				msg.id.toString(),
				msg.action,
				msg.result,
				msg.record,
			);
		}
	}

	private async applyAuthOrToken(auth: AuthOrToken): Promise<void> {
		const request: RpcRequest =
			typeof auth === "string"
				? { method: "authenticate", params: [auth] }
				: { method: "signin", params: [this.buildAuth(auth)] };

		await this.rpc(request);
	}

	private async applyAuthProvider(): Promise<void> {
		const provider = this.#authProvider;
		if (!provider) return;

		await this.applyAuthOrToken(
			typeof provider === "function" ? await provider() : provider,
		);
	}

	private handleAuthUpdate(): void {
		if (!this.#state || !this.#state.accessToken) return;

		this.cancelAuthRenewal();
		this.#eventPublisher.publish("authenticated", this.#state.accessToken);

		const token = this.#state.accessToken;
		const payload = fastParseJwt(token);

		// Check expirey existance
		if (!payload || !payload.exp) return;

		// Renew 60 seconds before expiry
		const now = Math.floor(Date.now() / 1000);
		const delay = Math.max((payload.exp - now - 60) * 1000, 0);

		// Schedule next renewal or invalidation
		this.#authRenewal = setTimeout(() => {
			this.renewAuth().catch((err) => {
				this.#eventPublisher.publish("error", new AuthenticationFailed(err));
			});
		}, delay);
	}

	private async renewAuth(): Promise<void> {
		if (this.#renewAccess === false) {
			this.handleAuthInvalidate();
			return;
		}

		if (this.#renewAccess === true) {
			await this.applyAuthProvider();
			return;
		}

		const auth = await this.#renewAccess();

		await this.applyAuthOrToken(auth);
	}

	private handleAuthInvalidate(): void {
		if (!this.#state) return;
		this.#state.accessToken = undefined;
		this.#state.refreshToken = undefined;
		this.cancelAuthRenewal();
		this.#eventPublisher.publish("invalidated");
	}

	private cancelAuthRenewal(): void {
		if (this.#authRenewal === undefined) return;
		clearTimeout(this.#authRenewal);
		this.#authRenewal = undefined;
	}
}



================================================
FILE: packages/sdk/src/engine/http.ts
================================================
import { ConnectionUnavailable, MissingNamespaceDatabase } from "../errors";
import { getIncrementalID } from "../internal/get-incremental-id";
import { postEndpoint } from "../internal/http";
import type { ExportOptions } from "../types/export";
import type { RpcRequest, RpcResponse } from "../types/rpc";
import type {
	ConnectionState,
	DriverContext,
	EngineEvents,
	SurrealEngine,
} from "../types/surreal";
import { Publisher } from "../utils/publisher";

const ALWAYS_ALLOW = new Set([
	"signin",
	"signup",
	"authenticate",
	"version",
	"query",
	"info",
	"ping",
]);

/**
 * An engine that communicates by sending individual HTTP requests
 */
export class HttpEngine implements SurrealEngine {
	#publisher = new Publisher<EngineEvents>();
	#state: ConnectionState | undefined;
	#context: DriverContext;

	subscribe<K extends keyof EngineEvents>(
		event: K,
		listener: (...payload: EngineEvents[K]) => void,
	): () => void {
		return this.#publisher.subscribe(event, listener);
	}

	constructor(context: DriverContext) {
		this.#context = context;
	}

	open(state: ConnectionState): void {
		this.#publisher.publish("connecting");
		this.#state = state;
		this.#publisher.publish("connected");
	}

	async close(): Promise<void> {
		this.#state = undefined;
		this.#publisher.publish("disconnected");
	}

	async import(data: string): Promise<void> {
		if (!this.#state) {
			throw new ConnectionUnavailable();
		}

		const endpoint = new URL(this.#state.url);
		const basepath = endpoint.pathname.slice(0, -4);

		endpoint.pathname = `${basepath}/import`;

		await postEndpoint(this.#context, this.#state, data, endpoint, {
			Accept: "application/json",
		});
	}

	async export(options?: Partial<ExportOptions>): Promise<string> {
		if (!this.#state) {
			throw new ConnectionUnavailable();
		}

		const endpoint = new URL(this.#state.url);
		const basepath = endpoint.pathname.slice(0, -4);

		endpoint.pathname = `${basepath}/export`;

		const buffer = await postEndpoint(
			this.#context,
			this.#state,
			options ?? {},
			endpoint,
			{
				Accept: "plain/text",
			},
		);

		return new TextDecoder("utf-8").decode(buffer);
	}

	async send<
		Method extends string,
		Params extends unknown[] | undefined,
		Result,
	>(request: RpcRequest<Method, Params>): Promise<RpcResponse<Result>> {
		if (!this.#state) {
			throw new ConnectionUnavailable();
		}

		switch (request.method) {
			case "use":
			case "let":
			case "unset":
			case "reset":
			case "invalidate": {
				return { result: null as Result };
			}
		}

		if (
			(!this.#state.namespace || !this.#state.database) &&
			!ALWAYS_ALLOW.has(request.method)
		) {
			throw new MissingNamespaceDatabase();
		}

		switch (request.method) {
			case "query": {
				request.params = [
					request.params?.[0],
					{
						...this.#state.variables,
						...(request.params?.[1] ?? {}),
					},
				] as Params;
				break;
			}
		}

		const id = getIncrementalID();
		const buffer = await postEndpoint(this.#context, this.#state, {
			id,
			...request,
		});

		return this.#context.decode<RpcResponse<Result>>(new Uint8Array(buffer));
	}
}



================================================
FILE: packages/sdk/src/engine/index.ts
================================================
export { HttpEngine } from "./http";
export { WebSocketEngine } from "./websocket";



================================================
FILE: packages/sdk/src/engine/websocket.ts
================================================
import {
	ConnectionUnavailable,
	EngineDisconnected,
	ReconnectExhaustion,
	UnexpectedConnectionError,
	UnexpectedServerResponse,
} from "../errors";

import type {
	ConnectionState,
	DriverContext,
	EngineEvents,
	SurrealEngine,
} from "../types/surreal";

import { getIncrementalID } from "../internal/get-incremental-id";
import { postEndpoint } from "../internal/http";
import type { ExportOptions } from "../types/export";
import { isLiveMessage } from "../types/live";
import type { RpcRequest, RpcResponse } from "../types/rpc";
import { Publisher } from "../utils/publisher";

type Interval = Parameters<typeof clearInterval>[0];
type Response = Record<string, unknown>;

interface Call<T> {
	request: object;
	resolve: (value: RpcResponse<T>) => void;
	reject: (error: Error) => void;
}

/**
 * An engine that communicates over WebSocket protocol
 */
export class WebSocketEngine implements SurrealEngine {
	#publisher = new Publisher<EngineEvents>();
	#state: ConnectionState | undefined;
	#socket: WebSocket | undefined;
	#calls = new Map<string, Call<unknown>>();
	#context: DriverContext;
	#pinger: Interval;
	#active = false;
	#terminated = false;

	subscribe<K extends keyof EngineEvents>(
		event: K,
		listener: (...payload: EngineEvents[K]) => void,
	): () => void {
		return this.#publisher.subscribe(event, listener);
	}

	constructor(context: DriverContext) {
		this.#context = context;
	}

	open(state: ConnectionState): void {
		this.#publisher.publish("connecting");
		this.#terminated = false;
		this.#state = state;

		const { reconnect } = state;

		(async () => {
			while (true) {
				// Open a new socket and await until closure
				const error = await this.createSocket(() => {
					this.#active = true;
					reconnect.reset();

					for (const { request } of this.#calls.values()) {
						this.#socket?.send(this.#context.encode(request));
					}

					this.#publisher.publish("connected");
				});

				this.#socket = undefined;

				if (error) {
					this.#publisher.publish("error", error);
				}

				// Check if we should continue to iterate and reconnect
				if (this.#terminated || !reconnect.enabled || !reconnect.allowed) {
					// Propagate reconnect exhaustion
					if (reconnect.enabled && !reconnect.allowed) {
						this.#publisher.publish("error", new ReconnectExhaustion());
					}

					// Optionally terminate pending calls
					if (!this.#terminated) {
						for (const { reject } of this.#calls.values()) {
							reject(new EngineDisconnected());
						}
					}

					this.#state = undefined;
					this.#active = false;
					this.#calls.clear();
					this.#publisher.publish("disconnected");

					break;
				}

				// Propagate caught errors
				if (error) {
					reconnect.propagate(error);
				}

				this.#publisher.publish("reconnecting");

				// Perform a reconnect iteration cooldown
				await reconnect.iterate();
			}
		})();
	}

	async close(): Promise<void> {
		this.#state = undefined;
		this.#terminated = true;
		this.#socket?.close();

		if (this.#active) {
			await this.#publisher.subscribeFirst("disconnected");
		}
	}

	async import(data: string): Promise<void> {
		if (!this.#state) {
			throw new ConnectionUnavailable();
		}

		const endpoint = new URL(this.#state.url);
		const basepath = endpoint.pathname.slice(0, -4);

		endpoint.pathname = `${basepath}/import`;

		await postEndpoint(this.#context, this.#state, data, endpoint, {
			Accept: "application/json",
		});
	}

	async export(options?: Partial<ExportOptions>): Promise<string> {
		if (!this.#state) {
			throw new ConnectionUnavailable();
		}

		const endpoint = new URL(this.#state.url);
		const basepath = endpoint.pathname.slice(0, -4);

		endpoint.pathname = `${basepath}/export`;

		const buffer = await postEndpoint(
			this.#context,
			this.#state,
			options ?? {},
			endpoint,
			{
				Accept: "plain/text",
			},
		);

		return new TextDecoder("utf-8").decode(buffer);
	}

	send<Method extends string, Params extends unknown[] | undefined, Result>(
		request: RpcRequest<Method, Params>,
	): Promise<RpcResponse<Result>> {
		return new Promise((resolve, reject) => {
			if (!this.#active) {
				reject(new ConnectionUnavailable());
				return;
			}

			const id = getIncrementalID();
			const call: Call<Result> = {
				request: { id, ...request },
				resolve,
				reject,
			};

			this.#calls.set(id, call as Call<unknown>);
			this.#socket?.send(this.#context.encode(call.request));
		});
	}

	private async createSocket(onConnected: () => void): Promise<Error | null> {
		return new Promise((resolve, reject) => {
			if (!this.#state) {
				reject(new ConnectionUnavailable());
				return;
			}

			// Open a new connection
			const WebSocketImpl = this.#context.options.websocketImpl ?? WebSocket;
			const socket = new WebSocketImpl(this.#state.url.toString(), "cbor");

			this.#socket = socket;

			// Store connection errors
			let caughtError: Error | null = null;

			// Wait for the connection to open
			socket.addEventListener("open", () => {
				try {
					onConnected();

					this.#pinger = setInterval(() => {
						try {
							this.send({ method: "ping" });
						} catch {
							// we are not interested in the result
						}
					}, 30_000);
				} catch (err: unknown) {
					caughtError = err as Error;
					socket.close();
				}
			});

			// Handle any errors
			socket.addEventListener("error", (e) => {
				const error = new UnexpectedConnectionError(
					"detail" in e && e.detail
						? e.detail
						: "message" in e && e.message
							? e.message
							: "error" in e && e.error
								? e.error
								: "An unexpected error occurred",
				);

				caughtError = error;
			});

			// Handle connection closure
			socket.addEventListener("close", () => {
				clearInterval(this.#pinger);
				resolve(caughtError);
			});

			// Handle any messages
			socket.addEventListener("message", async ({ data }) => {
				try {
					const buffer = await this.parseBuffer(data);
					const decoded = this.#context.decode<Response>(buffer);

					if (
						typeof decoded === "object" &&
						decoded != null &&
						Object.getPrototypeOf(decoded) === Object.prototype
					) {
						this.handleRpcResponse(decoded);
					} else {
						throw new UnexpectedServerResponse(decoded);
					}
				} catch (detail) {
					socket.dispatchEvent(new CustomEvent("error", { detail }));
				}
			});
		});
	}

	private async parseBuffer(data: unknown) {
		if (data instanceof Uint8Array) {
			return data;
		}

		if (data instanceof ArrayBuffer) {
			return new Uint8Array(data);
		}

		if (data instanceof Blob) {
			return await data.bytes();
		}

		throw new UnexpectedServerResponse(data);
	}

	private handleRpcResponse({ id, ...res }: Response) {
		if (typeof id === "string") {
			try {
				const { resolve } = this.#calls.get(id) ?? {};
				resolve?.(res as RpcResponse<unknown>);
			} finally {
				this.#calls.delete(id);
			}

			return;
		}

		if (isLiveMessage(res.result)) {
			this.#publisher.publish("live", res.result);
			return;
		}

		this.#publisher.publish("error", new UnexpectedServerResponse(res));
	}
}



================================================
FILE: packages/sdk/src/internal/get-incremental-id.ts
================================================
let id = 0;
export function getIncrementalID(): string {
	id = (id + 1) % Number.MAX_SAFE_INTEGER;
	return id.toString();
}



================================================
FILE: packages/sdk/src/internal/http.ts
================================================
import { HttpConnectionError } from "../errors";
import type { ConnectionState, DriverContext } from "../types/surreal";

export async function postEndpoint(
	context: DriverContext,
	state: ConnectionState,
	body: unknown,
	url?: URL,
	headers?: Record<string, string>,
): Promise<Uint8Array> {
	const endpoint = new URL(url ?? state.url);
	const headerMap: Record<string, string> = {
		"Content-Type": "application/cbor",
		Accept: "application/cbor",
		...headers,
	};

	if (state.namespace) {
		headerMap["Surreal-NS"] = state.namespace;
	}

	if (state.database) {
		headerMap["Surreal-DB"] = state.database;
	}

	if (state.accessToken) {
		headerMap.Authorization = `Bearer ${state.accessToken}`;
	}

	endpoint.protocol = endpoint.protocol.replace("ws", "http");

	const raw = await fetch(endpoint, {
		method: "POST",
		headers: headerMap,
		body: context.encode(body),
	});

	const buffer = await raw.arrayBuffer();

	if (raw.status === 200) {
		return new Uint8Array(buffer);
	}

	const dec = new TextDecoder("utf-8");

	throw new HttpConnectionError(
		dec.decode(buffer),
		raw.status,
		raw.statusText,
		buffer,
	);
}

export function parseEndpoint(value: string | URL): URL {
	const url = new URL(value);

	if (!url.pathname.endsWith("/rpc")) {
		if (!url.pathname.endsWith("/")) url.pathname += "/";
		url.pathname += "rpc";
	}

	return url;
}



================================================
FILE: packages/sdk/src/internal/output.ts
================================================
import type { AnyRecordId } from "../types";
import { RecordId, StringRecordId } from "../value";

export type Output<T, S> = S extends AnyRecordId ? T : T[];

export function output<T, S>(subject: S, input: T | T[]): Output<T, S> {
	if (subject instanceof RecordId || subject instanceof StringRecordId) {
		return (Array.isArray(input) ? input[0] : input) as Output<T, S>;
	}

	return (Array.isArray(input) ? input : [input]) as Output<T, S>;
}



================================================
FILE: packages/sdk/src/internal/rand.ts
================================================
export function rand(min: number, max: number): number {
	return Math.random() * (max - min) + min;
}



================================================
FILE: packages/sdk/src/internal/range.ts
================================================
import { type Bound, BoundExcluded, BoundIncluded } from "../utils/range";

export function getRangeJoin(beg: Bound<unknown>, end: Bound<unknown>): string {
	let output = "";
	if (beg instanceof BoundExcluded) output += ">";
	output += "..";
	if (end instanceof BoundIncluded) output += "=";
	return output;
}



================================================
FILE: packages/sdk/src/internal/reconnect.ts
================================================
import { ReconnectIterationError } from "../errors";
import type { ReconnectOptions } from "../types/surreal";
import { rand } from "./rand";

export const DEFAULT_RECONNECT_OPTIONS: ReconnectOptions = {
	enabled: true,
	attempts: 5,
	retryDelay: 1000,
	retryDelayMax: 60000,
	retryDelayMultiplier: 2,
	retryDelayJitter: 0.1,
};

export class ReconnectContext {
	#attempts = 0;

	readonly options: ReconnectOptions;

	// Process options as passed by the user
	constructor(input: undefined | Partial<ReconnectOptions> | boolean) {
		if (!input) {
			this.options = {
				...DEFAULT_RECONNECT_OPTIONS,
				enabled: false,
			};
		} else if (input === true) {
			this.options = DEFAULT_RECONNECT_OPTIONS;
		} else {
			this.options = {
				...DEFAULT_RECONNECT_OPTIONS,
				...input,
			};
		}
	}

	get attempts(): number {
		return this.#attempts;
	}

	get enabled(): boolean {
		return this.options.enabled;
	}

	get allowed(): boolean {
		// Check if reconnecting is enabled
		if (!this.options.enabled) return false;

		// Check if the maximum number of attempts has been reached
		if (
			this.options.attempts !== -1 &&
			this.#attempts >= this.options.attempts
		) {
			return false;
		}

		return true;
	}

	reset(): void {
		this.#attempts = 0;
	}

	propagate(error: Error): void {
		this.options.catch?.(error);
	}

	async iterate(): Promise<void> {
		// Restrict reconnect attempts and propagate ReconnectFailed error
		if (!this.allowed) {
			throw new ReconnectIterationError();
		}

		// Bump iteration
		this.#attempts++;

		// Compute the next reconnect delay
		const multiplier = this.options.retryDelayMultiplier ** this.attempts;
		const adjustedDelay = this.options.retryDelay * multiplier;
		const jitterModifier = rand(
			-this.options.retryDelayJitter,
			this.options.retryDelayJitter,
		);

		const nextDelay = Math.min(
			adjustedDelay * (1 + jitterModifier),
			this.options.retryDelayMax,
		);

		// Wait for the next iteration
		await new Promise<void>((r) => setTimeout(r, nextDelay));
	}
}



================================================
FILE: packages/sdk/src/internal/tokens.ts
================================================
export function fastParseJwt(token: string) {
	try {
		const parts = token.split(".");

		if (parts.length !== 3) {
			return null;
		}

		return JSON.parse(atob(parts[1]));
	} catch {
		return null;
	}
}



================================================
FILE: packages/sdk/src/internal/validation.ts
================================================
import { type Bound, BoundExcluded, BoundIncluded } from "../utils/range";
import { type RecordIdValue, Table, Uuid } from "../value";

export function isValidIdPart(v: unknown): v is RecordIdValue {
	if (v instanceof Uuid) return true;

	switch (typeof v) {
		case "string":
		case "number":
		case "bigint":
			return true;
		case "object":
			return Array.isArray(v) || v !== null;
		default:
			return false;
	}
}

export function isValidIdBound(bound: unknown): bound is Bound<RecordIdValue> {
	return bound instanceof BoundIncluded || bound instanceof BoundExcluded
		? isValidIdPart(bound.value)
		: true;
}

export function isValidTable(tb: unknown): tb is string | Table {
	return tb instanceof Table || typeof tb === "string";
}



================================================
FILE: packages/sdk/src/surreal/index.ts
================================================
import type { DriverOptions } from "../types";
import { SurrealV2 } from "./v2";

export * from "./v1";
export * from "./v2";

/**
 * The Surreal class serves as the main entry point for interacting with a Surreal database.
 *
 * By default the Surreal class supports endpoints with the `http`, `https`,
 * `ws`, and `wss` protocols. The constructor accepts an options object that can be used to configure additional engines,
 * such as those provided by the `@surrealdb/wasm` package.
 *
 * Compatible with the SurrealDB RPC v2 protocol
 */
export class Surreal extends SurrealV2 {
	constructor(options: DriverOptions = {}) {
		super(options);
	}
}



================================================
FILE: packages/sdk/src/surreal/v1.ts
================================================
import type {
	AccessRecordAuth,
	ActionResult,
	AnyAuth,
	ConnectOptions,
	ConnectionStatus,
	Doc,
	DriverOptions,
	EventPublisher,
	ExportOptions,
	LiveResource,
	Patch,
	Prettify,
	RelateInOut,
	RpcResponse,
	Token,
} from "../types";

import {
	type LiveSubscription,
	ManagedLiveSubscription,
	UnmanagedLiveSubscription,
} from "../utils/live";

import { type Fill, partiallyEncodeObject } from "@surrealdb/cbor";
import { decodeCbor, encodeCbor } from "../cbor";
import { REPLACER } from "../cbor/replacer";
import { ConnectionController } from "../controller";
import { NoTokenReturned, ResponseError, SurrealError } from "../errors";
import { parseEndpoint } from "../internal/http";
import { output } from "../internal/output";
import type { MapQueryResult } from "../types/query";
import { PreparedQuery } from "../utils";
import { Publisher } from "../utils/publisher";
import { type RecordId, type RecordIdRange, Table, type Uuid } from "../value";

export type SurrealV1Events = {
	connecting: [];
	connected: [];
	reconnecting: [];
	disconnected: [];
	error: [Error];
	authenticated: [Token];
	invalidated: [];
};

/**
 * An interface for communicating to SurrealDB over the v1 RPC protocol
 */
export class SurrealV1 implements EventPublisher<SurrealV1Events> {
	readonly #publisher = new Publisher<SurrealV1Events>();
	readonly #connection: ConnectionController;

	subscribe<K extends keyof SurrealV1Events>(
		event: K,
		listener: (...payload: SurrealV1Events[K]) => void,
	): () => void {
		return this.#publisher.subscribe(event, listener);
	}

	constructor(options: DriverOptions = {}) {
		this.#connection = new ConnectionController({
			options,
			encode: encodeCbor,
			decode: decodeCbor,
		});

		this.#connection.subscribe("connecting", () =>
			this.#publisher.publish("connecting"),
		);

		this.#connection.subscribe("connected", () =>
			this.#publisher.publish("connected"),
		);

		this.#connection.subscribe("disconnected", () =>
			this.#publisher.publish("disconnected"),
		);

		this.#connection.subscribe("reconnecting", () =>
			this.#publisher.publish("reconnecting"),
		);

		this.#connection.subscribe("error", (error) =>
			this.#publisher.publish("error", error),
		);

		this.#connection.subscribe("authenticated", (token) =>
			this.#publisher.publish("authenticated", token),
		);

		this.#connection.subscribe("invalidated", () =>
			this.#publisher.publish("invalidated"),
		);
	}

	/**
	 * Connect to a local or remote SurrealDB instance using the provided URL
	 *
	 * @param url The endpoint to connect to
	 * @param opts Options to configure the connection
	 */
	async connect(url: string | URL, opts: ConnectOptions = {}): Promise<true> {
		return this.#connection.connect(parseEndpoint(url), opts);
	}

	/**
	 * Disconnect from the active SurrealDB instance
	 */
	async close(): Promise<true> {
		return this.#connection.disconnect();
	}

	/**
	 * Returns the active selected namespace
	 */
	get namespace(): string | undefined {
		return this.#connection.state?.namespace;
	}

	/**
	 * Returns the active selected database
	 */
	get database(): string | undefined {
		return this.#connection.state?.database;
	}

	/**
	 * Returns the currently used authentication access token
	 */
	get accessToken(): string | undefined {
		return this.#connection.state?.accessToken;
	}

	/**
	 * Returns the parameters currently defined on the connection
	 */
	get parameters(): Record<string, unknown> {
		return this.#connection.state?.variables ?? {};
	}

	/**
	 * Returns the status of the connection
	 */
	get status(): ConnectionStatus {
		return this.#connection.status;
	}

	/**
	 * Returns whether the connection is considered connected
	 *
	 * Equivalent to `this.status === "connected"`
	 */
	get isConnected(): boolean {
		return this.#connection.status === "connected";
	}

	/**
	 * A promise which resolves when the connection is ready, or rejects
	 * if a connection error occurs.
	 */
	get ready(): Promise<void> {
		return this.#connection.ready();
	}

	/**
	 * Send a raw RPC message to the SurrealDB instance
	 *
	 * @param method Type of message to send
	 * @param params Optional parameters for the message
	 */
	public rpc<Result>(
		method: string,
		params?: unknown[],
	): Promise<RpcResponse<Result>> {
		return this.#connection.rpc({
			method,
			params,
		});
	}

	/**
	 * Ping the connected SurrealDB instance
	 */
	async ping(): Promise<true> {
		const { error } = await this.rpc("ping");
		if (error) throw new ResponseError(error.message);
		return true;
	}

	/**
	 * Switch to the specified {@link https://surrealdb.com/docs/surrealdb/introduction/concepts/namespace|namespace}
	 * and {@link https://surrealdb.com/docs/surrealdb/introduction/concepts/database|database}
	 *
	 * @param database Switches to a specific namespace
	 * @param db Switches to a specific database
	 */
	async use({
		namespace,
		database,
	}: {
		namespace?: string | null;
		database?: string | null;
	}): Promise<true> {
		await this.ready;

		if (namespace === null && database !== null)
			throw new SurrealError(
				"Cannot unset namespace without unsetting database",
			);

		const { error } = await this.rpc("use", [namespace, database]);
		if (error) throw new ResponseError(error.message);
		return true;
	}

	/**
	 * Sign up to the SurrealDB instance as a new
	 * {@link https://surrealdb.com/docs/surrealdb/security/authentication#record-users|record user}.
	 *
	 * @param auth The authentication details to use.
	 * @return The authentication token.
	 */
	async signup(auth: AccessRecordAuth): Promise<Token> {
		await this.ready;

		const converted = this.#connection.buildAuth(auth);
		const res = await this.rpc<Token>("signup", [converted]);

		if (res.error) throw new ResponseError(res.error.message);
		if (!res.result) throw new NoTokenReturned();

		return res.result;
	}

	/**
	 * Authenticate with the SurrealDB using the provided authentication details.
	 *
	 * @param auth The authentication details to use.
	 * @return The authentication token.
	 */
	async signin(auth: AnyAuth): Promise<Token> {
		await this.ready;

		const converted = this.#connection.buildAuth(auth);
		const res = await this.rpc<Token>("signin", [converted]);

		if (res.error) throw new ResponseError(res.error.message);
		if (!res.result) throw new NoTokenReturned();

		return res.result;
	}

	/**
	 * Authenticates the current connection with a JWT token.
	 *
	 * @param token The JWT authentication token.
	 */
	async authenticate(token: Token): Promise<true> {
		await this.ready;
		const res = await this.rpc<string>("authenticate", [token]);
		if (res.error) throw new ResponseError(res.error.message);
		return true;
	}

	/**
	 * Invalidates the authentication for the current connection.
	 */
	async invalidate(): Promise<true> {
		await this.ready;
		const res = await this.rpc("invalidate");
		if (res.error) throw new ResponseError(res.error.message);
		return true;
	}

	/**
	 * Selects everything from the [$auth](https://surrealdb.com/docs/surrealql/parameters) variable.
	 *
	 * This is equivalent to running:
	 * ```sql
	 * SELECT * FROM $auth;
	 * ```
	 * Make sure the user actually has the permission to select their own record, otherwise you'll get back an empty result
	 *
	 * @return The record linked to the record ID used for authentication
	 */
	async info<T extends Doc>(): Promise<ActionResult<T> | undefined> {
		await this.ready;
		const res = await this.rpc<ActionResult<T> | undefined>("info");
		if (res.error) throw new ResponseError(res.error.message);
		return res.result ?? undefined;
	}

	/**
	 * Specify a variable for the current socket connection
	 *
	 * @param key Specifies the name of the variable
	 * @param val Assigns the value to the variable name
	 */
	async let(variable: string, value: unknown): Promise<true> {
		await this.ready;
		const res = await this.rpc("let", [variable, value]);
		if (res.error) throw new ResponseError(res.error.message);
		return true;
	}

	/**
	 * Remove a variable from the current socket connection
	 *
	 * @param key Specifies the name of the variable.
	 */
	async unset(variable: string): Promise<true> {
		await this.ready;
		const res = await this.rpc("unset", [variable]);
		if (res.error) throw new ResponseError(res.error.message);
		return true;
	}

	/**
	 * Create a new live subscription to a specific table, record id, or record id range
	 *
	 * @param what The table, record id, or record id range to subscribe to
	 * @returns A new live subscription object
	 */
	async live(what: LiveResource, diff?: boolean): Promise<LiveSubscription> {
		await this.ready;
		return new ManagedLiveSubscription(
			this.#publisher,
			this.#connection,
			what,
			diff ?? false,
		);
	}

	/**
	 * Manually subscribe to an existing live subscription using the provided ID
	 *
	 * **NOTE:** This function is for use with live select queries that are not managed by the driver.
	 *
	 * @param id The ID of the live subscription to subscribe to
	 * @returns A new unmanaged live subscription object
	 */
	async liveOf(id: Uuid): Promise<LiveSubscription> {
		await this.ready;
		return new UnmanagedLiveSubscription(this.#connection, id);
	}

	/**
	 * Runs a set of SurrealQL statements against the database, returning the first error
	 * if any of the statements result in an error
	 *
	 * @param query Specifies the SurrealQL statements
	 * @param bindings Assigns variables which can be used in the query
	 */
	async query<T extends unknown[]>(
		query: string,
		bindings?: Record<string, unknown>,
	): Promise<Prettify<T>>;

	/**
	 * Runs a set of SurrealQL statements against the database, returning the first error
	 * if any of the statements result in an error
	 *
	 * @param prepared Specifies the prepared query to run
	 * @param gaps Assigns values to gaps present in the prepared query
	 */
	async query<T extends unknown[]>(
		prepared: PreparedQuery,
		gaps?: Fill[],
	): Promise<Prettify<T>>;

	// Shadow implementation
	async query<T extends unknown[]>(
		preparedOrQuery: string | PreparedQuery,
		gapsOrBinds?: Record<string, unknown> | Fill[],
	): Promise<Prettify<T>> {
		const response = await this.#queryImpl<T>(preparedOrQuery, gapsOrBinds);

		return response.map(({ status, result }) => {
			if (status === "ERR") throw new ResponseError(result);
			return result;
		}) as T;
	}

	/**
	 * Runs a set of SurrealQL statements against the database
	 *
	 * @param query Specifies the SurrealQL statements
	 * @param bindings Assigns variables which can be used in the query
	 */
	async queryRaw<T extends unknown[]>(
		query: string,
		bindings?: Record<string, unknown>,
	): Promise<Prettify<MapQueryResult<T>>>;

	/**
	 * Runs a set of SurrealQL statements against the database
	 *
	 * @param prepared Specifies the prepared query to run
	 * @param gaps Assigns values to gaps present in the prepared query
	 */
	async queryRaw<T extends unknown[]>(
		prepared: PreparedQuery,
		gaps?: Fill[],
	): Promise<Prettify<MapQueryResult<T>>>;

	// Shadow implementation
	async queryRaw<T extends unknown[]>(
		preparedOrQuery: string | PreparedQuery,
		gapsOrBinds?: Record<string, unknown> | Fill[],
	): Promise<Prettify<MapQueryResult<T>>> {
		return this.#queryImpl(preparedOrQuery, gapsOrBinds);
	}

	// Internal implementation
	async #queryImpl<T extends unknown[]>(
		preparedOrQuery: string | PreparedQuery,
		gapsOrBinds?: Record<string, unknown> | Fill[],
	) {
		await this.ready;

		let params: unknown[];

		if (preparedOrQuery instanceof PreparedQuery) {
			params = [
				preparedOrQuery.query,
				partiallyEncodeObject(preparedOrQuery.bindings, {
					fills: gapsOrBinds as Fill[],
					replacer: REPLACER.encode,
				}),
			];
		} else {
			params = [preparedOrQuery, gapsOrBinds];
		}

		const res = await this.rpc<MapQueryResult<T>>("query", params);
		if (res.error) throw new ResponseError(res.error.message);
		return res.result;
	}

	/**
	 * Select all fields from a specific record based on the provied Record ID
	 *
	 * @param recordId The record ID to select
	 */
	async select<T extends Doc>(recordId: RecordId): Promise<ActionResult<T>>;

	/**
	 * Select all records based on the provided Record ID range
	 *
	 * @param range The range of record IDs to select
	 */
	async select<T extends Doc>(range: RecordIdRange): Promise<ActionResult<T>[]>;

	/**
	 * Select all records present in the specified table
	 *
	 * @param recordId The record ID to select
	 */
	async select<T extends Doc>(table: Table): Promise<ActionResult<T>[]>;

	// Shadow implementation
	async select<T extends Doc>(what: RecordId | RecordIdRange | Table) {
		await this.ready;
		const res = await this.rpc<ActionResult<T>>("select", [what]);
		if (res.error) throw new ResponseError(res.error.message);
		return output(what, res.result);
	}

	/**
	 * Create a new record in the database
	 *
	 * @param recordId The record id of the record to create
	 * @param data The record data to insert
	 */
	async create<T extends Doc, U extends Doc = T>(
		recordId: RecordId,
		data?: U,
	): Promise<ActionResult<T>>;

	/**
	 * Create a new record in the specified table
	 *
	 * @param table The table to create a record in
	 * @param data The record data to insert
	 */
	async create<T extends Doc, U extends Doc = T>(
		table: Table,
		data?: U,
	): Promise<ActionResult<T>[]>;

	// Shadow implementation
	async create<T extends Doc, U extends Doc = T>(
		what: RecordId | Table,
		data?: U,
	) {
		await this.ready;
		const res = await this.rpc<ActionResult<T>>("create", [what, data]);
		if (res.error) throw new ResponseError(res.error.message);
		return output(what, res.result);
	}

	/**
	 * Create a graph edge between the from record(s) and the to record(s) using a specific edge record id
	 *
	 * @param from The in property on the edge record
	 * @param edge The id of the edge record
	 * @param to  The out property on the edge record
	 * @param data The optional record data to store on the edge
	 */
	async relate<T extends Doc, U extends Doc = T>(
		from: RelateInOut,
		edge: RecordId,
		to: RelateInOut,
		data?: U,
	): Promise<T>;

	/**
	 * Create a graph edge between the from record(s) and the to record(s) on the specified edge table
	 *
	 * @param from The in property on the edge record
	 * @param edge The edge table to create the relation in
	 * @param to  The out property on the edge record
	 * @param data The optional record data to store on the edge
	 */
	async relate<T extends Doc, U extends Doc = T>(
		from: RelateInOut,
		edge: Table,
		to: RelateInOut,
		data?: U,
	): Promise<T[]>;

	// Shadow implementation
	async relate<T extends Doc, U extends Doc = T>(
		from: RelateInOut,
		thing: Table | RecordId,
		to: RelateInOut,
		data?: U,
	) {
		await this.ready;
		const res = await this.rpc("relate", [from, thing, to, data]);
		if (res.error) throw new ResponseError(res.error.message);
		return output(thing, res.result);
	}

	/**
	 * Inserts one or multiple records into the database
	 *
	 * @param data One or more records to insert
	 */
	async insert<T extends Doc, U extends Doc = T>(
		data?: U | U[],
	): Promise<ActionResult<T>[]>;

	/**
	 * Inserts one or multiple records into the database
	 *
	 * @param table The table to insert the record into
	 * @param data One or more records to insert
	 */
	async insert<T extends Doc, U extends Doc = T>(
		table: Table,
		data?: U | U[],
	): Promise<ActionResult<T>[]>;

	// Shadow implementation
	async insert<T extends Doc, U extends Doc = T>(
		arg1: Table | U | U[],
		arg2?: U | U[],
	) {
		await this.ready;
		const params = arg1 instanceof Table ? [arg1, arg2] : [undefined, arg1];
		const res = await this.rpc<ActionResult<T>>("insert", params);
		if (res.error) throw new ResponseError(res.error.message);
		return res.result;
	}

	/**
	 * Inserts one or multiple relations in the database
	 *
	 * @param data One or more relations to insert
	 */
	async insertRelation<T extends Doc, U extends Doc = T>(
		data?: U | U[],
	): Promise<ActionResult<T>[]>;

	/**
	 * Inserts one or multiple relations in the database
	 *
	 * @param table The table to insert the relation into
	 * @param data One or more relations to insert
	 */
	async insertRelation<T extends Doc, U extends Doc = T>(
		table: Table,
		data?: U | U[],
	): Promise<ActionResult<T>[]>;

	// Shadow implementation
	async insertRelation<T extends Doc, U extends Doc = T>(
		arg1: Table | U | U[],
		arg2?: U | U[],
	) {
		await this.ready;
		const params = arg1 instanceof Table ? [arg1, arg2] : [undefined, arg1];
		const res = await this.rpc<ActionResult<T>>("insert_relation", params);
		if (res.error) throw new ResponseError(res.error.message);
		return res.result;
	}

	/**
	 * Updates a single record based on the provided Record ID
	 *
	 * ***NOTE: This function replaces the existing record data with the specified data***
	 *
	 * @param recordId The record ID to update
	 * @param data The record data to update
	 */
	async update<T extends Doc, U extends Doc = T>(
		recordId: RecordId,
		data?: U,
	): Promise<ActionResult<T>>;

	/**
	 * Updates all records based on the provided Record ID range
	 *
	 * ***NOTE: This function replaces the existing record data with the specified data***
	 *
	 * @param range The range of record IDs to update
	 * @param data The record data to update
	 */
	async update<T extends Doc, U extends Doc = T>(
		range: RecordIdRange,
		data?: U,
	): Promise<ActionResult<T>[]>;

	/**
	 * Updates all records present in the specified table
	 *
	 * ***NOTE: This function replaces the existing record data with the specified data***
	 *
	 * @param table The table to update
	 * @param data The record data to update
	 */
	async update<T extends Doc, U extends Doc = T>(
		range: Table,
		data?: U,
	): Promise<ActionResult<T>[]>;

	// Shadow implementation
	async update<T extends Doc, U extends Doc = T>(
		thing: RecordId | RecordIdRange | Table,
		data?: U,
	) {
		await this.ready;
		const res = await this.rpc<ActionResult<T>>("update", [thing, data]);
		if (res.error) throw new ResponseError(res.error.message);
		return output(thing, res.result);
	}

	/**
	 * Upserts a single record based on the provided Record ID
	 *
	 * ***NOTE: This function replaces the existing record data with the specified data**
	 *
	 * @param recordId The record ID to upsert
	 * @param data The record data to upsert
	 */
	async upsert<T extends Doc, U extends Doc = T>(
		recordId: RecordId,
		data?: U,
	): Promise<ActionResult<T>>;

	/**
	 * Upserts all records based on the provided Record ID range
	 *
	 * ***NOTE: This function replaces the existing record data with the specified data**
	 *
	 * @param range The range of record IDs to upsert
	 * @param data The record data to upsert
	 */
	async upsert<T extends Doc, U extends Doc = T>(
		thing: RecordIdRange,
		data?: U,
	): Promise<ActionResult<T>[]>;

	/**
	 * Upserts all records present in the specified table
	 *
	 * ***NOTE: This function replaces the existing record data with the specified data**
	 *
	 * @param table The table to upsert
	 * @param data The record data to upsert
	 */
	async upsert<T extends Doc, U extends Doc = T>(
		thing: Table,
		data?: U,
	): Promise<ActionResult<T>[]>;

	// Shadow implementation
	async upsert<T extends Doc, U extends Doc = T>(
		thing: RecordId | RecordIdRange | Table,
		data?: U,
	) {
		await this.ready;
		const res = await this.rpc<ActionResult<T>>("upsert", [thing, data]);
		if (res.error) throw new ResponseError(res.error.message);
		return output(thing, res.result);
	}

	/**
	 * Merges a single record based on the provided Record ID
	 *
	 * @param recordId The record ID to merge
	 * @param data The record data to merge
	 */
	async merge<T extends Doc, U extends Doc = Partial<T>>(
		thing: RecordId,
		data?: U,
	): Promise<ActionResult<T>>;

	/**
	 * Merges all records based on the provided Record ID range
	 *
	 * @param range The range of record IDs to merge
	 * @param data The record data to merge
	 */
	async merge<T extends Doc, U extends Doc = Partial<T>>(
		thing: RecordIdRange,
		data?: U,
	): Promise<ActionResult<T>[]>;

	/**
	 * Merges all records present in the specified table
	 *
	 * @param table The table to merge
	 * @param data The record data to merge
	 */
	async merge<T extends Doc, U extends Doc = Partial<T>>(
		thing: Table,
		data?: U,
	): Promise<ActionResult<T>[]>;

	// Shadow implementation
	async merge<T extends Doc, U extends Doc = Partial<T>>(
		thing: RecordId | RecordIdRange | Table,
		data?: U,
	) {
		await this.ready;
		const res = await this.rpc<ActionResult<T>>("merge", [thing, data]);
		if (res.error) throw new ResponseError(res.error.message);
		return output(thing, res.result);
	}

	/**
	 * Applies JSON Patch changes to all records, or a specific record, in the database
	 *
	 * ***NOTE: This function patches the existing record data with the specified JSON Patch operations***
	 *
	 * @param what The table name, record ID range, or specifc record ID to patch
	 * @param data The JSON Patch operations to apply
	 */
	async patch<T extends Doc>(
		what: RecordId,
		data?: Patch[],
		diff?: false,
	): Promise<ActionResult<T>>;
	async patch<T extends Doc>(
		what: RecordIdRange | Table,
		data?: Patch[],
		diff?: false,
	): Promise<ActionResult<T>[]>;
	async patch<T extends Doc>(
		what: RecordId,
		data: undefined | Patch[],
		diff: true,
	): Promise<Patch[]>;
	async patch<T extends Doc>(
		what: RecordIdRange | Table,
		data: undefined | Patch[],
		diff: true,
	): Promise<Patch[][]>;
	async patch(
		what: RecordId | RecordIdRange | Table,
		data?: Patch[],
		diff?: boolean,
	) {
		await this.ready;
		const res = await this.rpc<unknown>("patch", [what, data, diff]);
		if (res.error) throw new ResponseError(res.error.message);
		return diff ? res.result : output(what, res.result);
	}

	/**
	 * Deletes a single record from the database based on the provided Record ID
	 *
	 * @param recordId The record ID to delete
	 */
	async delete<T extends Doc>(recordId: RecordId): Promise<ActionResult<T>>;

	/**
	 * Deletes all records based on the provided Record ID range
	 *
	 * @param range The range of record IDs to delete
	 */
	async delete<T extends Doc>(thing: RecordIdRange): Promise<ActionResult<T>[]>;

	/**
	 * Deletes all records present in the specified table
	 *
	 * @param table The table to delete
	 */
	async delete<T extends Doc>(table: Table): Promise<ActionResult<T>[]>;

	// Shadow implementation
	async delete<T extends Doc>(thing: RecordId | RecordIdRange | Table) {
		await this.ready;
		const res = await this.rpc<ActionResult<T>>("delete", [thing]);
		if (res.error) throw new ResponseError(res.error.message);
		return output(thing, res.result);
	}

	/**
	 * Retrieves the version of the connected SurrealDB instance
	 *
	 * @example `surrealdb-2.1.0`
	 */
	async version(): Promise<string> {
		await this.ready;
		const res = await this.rpc<string>("version");
		if (res.error) throw new ResponseError(res.error.message);
		return res.result;
	}

	/**
	 * Run a SurrealQL function and return the result
	 *
	 * @param name The full name of the function to run
	 * @param args The arguments supplied to the function
	 */
	async run<T>(name: string, args?: unknown[]): Promise<T>;

	/**
	 * Run a SurrealML function with the specified version and return the result
	 *
	 * @param name The full name of the function to run
	 * @param version The version of the function to use
	 * @param args The arguments supplied to the function
	 */
	async run<T>(name: string, version: string, args?: unknown[]): Promise<T>;

	// Shadow implementation
	async run(name: string, arg2?: string | unknown[], arg3?: unknown[]) {
		await this.ready;
		const [version, args] = Array.isArray(arg2)
			? [undefined, arg2]
			: [arg2, arg3];

		const res = await this.rpc("run", [name, version, args]);
		if (res.error) throw new ResponseError(res.error.message);
		return res.result;
	}

	/**
	 * Export the database and return the result as a string
	 *
	 * @param options Optional export options
	 */
	public async export(options?: Partial<ExportOptions>): Promise<string> {
		await this.ready;
		return this.#connection.export(options);
	}

	/**
	 * Import an existing export into the database
	 *
	 * @param input The data to import
	 */
	public async import(input: string): Promise<void> {
		await this.ready;
		return this.#connection.import(input);
	}
}



================================================
FILE: packages/sdk/src/surreal/v2.ts
================================================
import type {
	AccessRecordAuth,
	ActionResult,
	AnyAuth,
	AuthResponse,
	ConnectOptions,
	ConnectionStatus,
	Doc,
	DriverOptions,
	EventPublisher,
	ExportOptions,
	LiveResource,
	Patch,
	Prettify,
	RelateInOut,
	RpcResponse,
	Token,
} from "../types";

import {
	type LiveSubscription,
	ManagedLiveSubscription,
	UnmanagedLiveSubscription,
} from "../utils/live";

import { type Fill, partiallyEncodeObject } from "@surrealdb/cbor";
import { decodeCbor, encodeCbor } from "../cbor";
import { REPLACER } from "../cbor/replacer";
import { ConnectionController } from "../controller";
import { NoTokenReturned, ResponseError, SurrealError } from "../errors";
import { parseEndpoint } from "../internal/http";
import { output } from "../internal/output";
import type { MapQueryResult } from "../types/query";
import { PreparedQuery } from "../utils";
import { Publisher } from "../utils/publisher";
import { type RecordId, type RecordIdRange, Table, type Uuid } from "../value";

export type SurrealV2Events = {
	connecting: [];
	connected: [];
	reconnecting: [];
	disconnected: [];
	error: [Error];
	authenticated: [Token];
	invalidated: [];
};

/**
 * An interface for communicating to SurrealDB over the v2 RPC protocol
 */
export class SurrealV2 implements EventPublisher<SurrealV2Events> {
	readonly #publisher = new Publisher<SurrealV2Events>();
	readonly #connection: ConnectionController;

	subscribe<K extends keyof SurrealV2Events>(
		event: K,
		listener: (...payload: SurrealV2Events[K]) => void,
	): () => void {
		return this.#publisher.subscribe(event, listener);
	}

	constructor(options: DriverOptions = {}) {
		this.#connection = new ConnectionController({
			options,
			encode: encodeCbor,
			decode: decodeCbor,
		});

		this.#connection.subscribe("connecting", () =>
			this.#publisher.publish("connecting"),
		);

		this.#connection.subscribe("connected", () =>
			this.#publisher.publish("connected"),
		);

		this.#connection.subscribe("disconnected", () =>
			this.#publisher.publish("disconnected"),
		);

		this.#connection.subscribe("reconnecting", () =>
			this.#publisher.publish("reconnecting"),
		);

		this.#connection.subscribe("error", (error) =>
			this.#publisher.publish("error", error),
		);

		this.#connection.subscribe("authenticated", (token) =>
			this.#publisher.publish("authenticated", token),
		);

		this.#connection.subscribe("invalidated", () =>
			this.#publisher.publish("invalidated"),
		);
	}

	/**
	 * Connect to a local or remote SurrealDB instance using the provided URL
	 *
	 * @param url The endpoint to connect to
	 * @param opts Options to configure the connection
	 */
	async connect(url: string | URL, opts: ConnectOptions = {}): Promise<true> {
		return this.#connection.connect(parseEndpoint(url), opts);
	}

	/**
	 * Disconnect from the active SurrealDB instance
	 */
	async close(): Promise<true> {
		return this.#connection.disconnect();
	}

	/**
	 * Returns the active selected namespace
	 */
	get namespace(): string | undefined {
		return this.#connection.state?.namespace;
	}

	/**
	 * Returns the active selected database
	 */
	get database(): string | undefined {
		return this.#connection.state?.database;
	}

	/**
	 * Returns the currently used authentication access token
	 */
	get accessToken(): string | undefined {
		return this.#connection.state?.accessToken;
	}

	/**
	 * Returns the parameters currently defined on the connection
	 */
	get parameters(): Record<string, unknown> {
		return this.#connection.state?.variables ?? {};
	}

	/**
	 * Returns the status of the connection
	 */
	get status(): ConnectionStatus {
		return this.#connection.status;
	}

	/**
	 * Returns whether the connection is considered connected
	 *
	 * Equivalent to `this.status === "connected"`
	 */
	get isConnected(): boolean {
		return this.#connection.status === "connected";
	}

	/**
	 * A promise which resolves when the connection is ready, or rejects
	 * if a connection error occurs.
	 */
	get ready(): Promise<void> {
		return this.#connection.ready();
	}

	/**
	 * Send a raw RPC message to the SurrealDB instance
	 *
	 * @param method Type of message to send
	 * @param params Optional parameters for the message
	 */
	public rpc<Result>(
		method: string,
		params?: unknown[],
	): Promise<RpcResponse<Result>> {
		return this.#connection.rpc({
			method,
			params,
		});
	}

	/**
	 * Ping the connected SurrealDB instance
	 */
	async ping(): Promise<true> {
		const { error } = await this.rpc("ping");
		if (error) throw new ResponseError(error.message);
		return true;
	}

	/**
	 * Switch to the specified {@link https://surrealdb.com/docs/surrealdb/introduction/concepts/namespace|namespace}
	 * and {@link https://surrealdb.com/docs/surrealdb/introduction/concepts/database|database}
	 *
	 * @param database Switches to a specific namespace
	 * @param db Switches to a specific database
	 */
	async use({
		namespace,
		database,
	}: {
		namespace?: string | null;
		database?: string | null;
	}): Promise<true> {
		await this.ready;

		if (namespace === null && database !== null)
			throw new SurrealError(
				"Cannot unset namespace without unsetting database",
			);

		const { error } = await this.rpc("use", [namespace, database]);
		if (error) throw new ResponseError(error.message);
		return true;
	}

	/**
	 * Sign up to the SurrealDB instance as a new
	 * {@link https://surrealdb.com/docs/surrealdb/security/authentication#record-users|record user}.
	 *
	 * @param auth The authentication details to use.
	 * @return The authentication token.
	 */
	async signup(auth: AccessRecordAuth): Promise<AuthResponse> {
		await this.ready;

		const converted = this.#connection.buildAuth(auth);
		const res = await this.rpc<AuthResponse>("signup", [converted]);

		if (res.error) throw new ResponseError(res.error.message);
		if (!res.result.token) throw new NoTokenReturned();

		return res.result;
	}

	/**
	 * Authenticate with the SurrealDB using the provided authentication details.
	 *
	 * @param auth The authentication details to use.
	 * @return The authentication token.
	 */
	async signin(auth: AnyAuth): Promise<AuthResponse> {
		await this.ready;

		const converted = this.#connection.buildAuth(auth);
		const res = await this.rpc<AuthResponse>("signin", [converted]);

		if (res.error) throw new ResponseError(res.error.message);
		if (!res.result.token) throw new NoTokenReturned();

		return res.result;
	}

	/**
	 * Authenticates the current connection with a JWT token.
	 *
	 * @param token The JWT authentication token.
	 */
	async authenticate(token: Token): Promise<true> {
		await this.ready;
		const res = await this.rpc<string>("authenticate", [token]);
		if (res.error) throw new ResponseError(res.error.message);
		return true;
	}

	/**
	 * Invalidates the authentication for the current connection.
	 */
	async invalidate(): Promise<true> {
		await this.ready;
		const res = await this.rpc("invalidate");
		if (res.error) throw new ResponseError(res.error.message);
		return true;
	}

	/**
	 * Selects everything from the [$auth](https://surrealdb.com/docs/surrealql/parameters) variable.
	 *
	 * This is equivalent to running:
	 * ```sql
	 * SELECT * FROM $auth;
	 * ```
	 * Make sure the user actually has the permission to select their own record, otherwise you'll get back an empty result
	 *
	 * @return The record linked to the record ID used for authentication
	 */
	async info<T extends Doc>(): Promise<ActionResult<T> | undefined> {
		await this.ready;
		const res = await this.rpc<ActionResult<T> | undefined>("info");
		if (res.error) throw new ResponseError(res.error.message);
		return res.result ?? undefined;
	}

	/**
	 * Specify a variable for the current socket connection
	 *
	 * @param key Specifies the name of the variable
	 * @param val Assigns the value to the variable name
	 */
	async let(variable: string, value: unknown): Promise<true> {
		await this.ready;
		const res = await this.rpc("let", [variable, value]);
		if (res.error) throw new ResponseError(res.error.message);
		return true;
	}

	/**
	 * Remove a variable from the current socket connection
	 *
	 * @param key Specifies the name of the variable.
	 */
	async unset(variable: string): Promise<true> {
		await this.ready;
		const res = await this.rpc("unset", [variable]);
		if (res.error) throw new ResponseError(res.error.message);
		return true;
	}

	/**
	 * Create a new live subscription to a specific table, record id, or record id range
	 *
	 * @param what The table, record id, or record id range to subscribe to
	 * @returns A new live subscription object
	 */
	async live(what: LiveResource, diff?: boolean): Promise<LiveSubscription> {
		await this.ready;
		return new ManagedLiveSubscription(
			this.#publisher,
			this.#connection,
			what,
			diff ?? false,
		);
	}

	/**
	 * Manually subscribe to an existing live subscription using the provided ID
	 *
	 * **NOTE:** This function is for use with live select queries that are not managed by the driver.
	 *
	 * @param id The ID of the live subscription to subscribe to
	 * @returns A new unmanaged live subscription object
	 */
	async liveOf(id: Uuid): Promise<LiveSubscription> {
		await this.ready;
		return new UnmanagedLiveSubscription(this.#connection, id);
	}

	/**
	 * Runs a set of SurrealQL statements against the database, returning the first error
	 * if any of the statements result in an error
	 *
	 * @param query Specifies the SurrealQL statements
	 * @param bindings Assigns variables which can be used in the query
	 */
	async query<T extends unknown[]>(
		query: string,
		bindings?: Record<string, unknown>,
	): Promise<Prettify<T>>;

	/**
	 * Runs a set of SurrealQL statements against the database, returning the first error
	 * if any of the statements result in an error
	 *
	 * @param prepared Specifies the prepared query to run
	 * @param gaps Assigns values to gaps present in the prepared query
	 */
	async query<T extends unknown[]>(
		prepared: PreparedQuery,
		gaps?: Fill[],
	): Promise<Prettify<T>>;

	// Shadow implementation
	async query<T extends unknown[]>(
		preparedOrQuery: string | PreparedQuery,
		gapsOrBinds?: Record<string, unknown> | Fill[],
	): Promise<Prettify<T>> {
		const response = await this.#queryImpl<T>(preparedOrQuery, gapsOrBinds);

		return response.map(({ status, result }) => {
			if (status === "ERR") throw new ResponseError(result);
			return result;
		}) as T;
	}

	/**
	 * Runs a set of SurrealQL statements against the database
	 *
	 * @param query Specifies the SurrealQL statements
	 * @param bindings Assigns variables which can be used in the query
	 */
	async queryRaw<T extends unknown[]>(
		query: string,
		bindings?: Record<string, unknown>,
	): Promise<Prettify<MapQueryResult<T>>>;

	/**
	 * Runs a set of SurrealQL statements against the database
	 *
	 * @param prepared Specifies the prepared query to run
	 * @param gaps Assigns values to gaps present in the prepared query
	 */
	async queryRaw<T extends unknown[]>(
		prepared: PreparedQuery,
		gaps?: Fill[],
	): Promise<Prettify<MapQueryResult<T>>>;

	// Shadow implementation
	async queryRaw<T extends unknown[]>(
		preparedOrQuery: string | PreparedQuery,
		gapsOrBinds?: Record<string, unknown> | Fill[],
	): Promise<Prettify<MapQueryResult<T>>> {
		return this.#queryImpl(preparedOrQuery, gapsOrBinds);
	}

	// Internal implementation
	async #queryImpl<T extends unknown[]>(
		preparedOrQuery: string | PreparedQuery,
		gapsOrBinds?: Record<string, unknown> | Fill[],
	) {
		await this.ready;

		let params: unknown[];

		if (preparedOrQuery instanceof PreparedQuery) {
			params = [
				preparedOrQuery.query,
				partiallyEncodeObject(preparedOrQuery.bindings, {
					fills: gapsOrBinds as Fill[],
					replacer: REPLACER.encode,
				}),
			];
		} else {
			params = [preparedOrQuery, gapsOrBinds];
		}

		const res = await this.rpc<MapQueryResult<T>>("query", params);
		if (res.error) throw new ResponseError(res.error.message);
		return res.result;
	}

	/**
	 * Select all fields from a specific record based on the provied Record ID
	 *
	 * @param recordId The record ID to select
	 */
	async select<T extends Doc>(recordId: RecordId): Promise<ActionResult<T>>;

	/**
	 * Select all records based on the provided Record ID range
	 *
	 * @param range The range of record IDs to select
	 */
	async select<T extends Doc>(range: RecordIdRange): Promise<ActionResult<T>[]>;

	/**
	 * Select all records present in the specified table
	 *
	 * @param recordId The record ID to select
	 */
	async select<T extends Doc>(table: Table): Promise<ActionResult<T>[]>;

	// Shadow implementation
	async select<T extends Doc>(what: RecordId | RecordIdRange | Table) {
		await this.ready;
		const res = await this.rpc<ActionResult<T>>("select", [what]);
		if (res.error) throw new ResponseError(res.error.message);
		return output(what, res.result);
	}

	/**
	 * Create a new record in the database
	 *
	 * @param recordId The record id of the record to create
	 * @param data The record data to insert
	 */
	async create<T extends Doc, U extends Doc = T>(
		recordId: RecordId,
		data?: U,
	): Promise<ActionResult<T>>;

	/**
	 * Create a new record in the specified table
	 *
	 * @param table The table to create a record in
	 * @param data The record data to insert
	 */
	async create<T extends Doc, U extends Doc = T>(
		table: Table,
		data?: U,
	): Promise<ActionResult<T>[]>;

	// Shadow implementation
	async create<T extends Doc, U extends Doc = T>(
		what: RecordId | Table,
		data?: U,
	) {
		await this.ready;
		const res = await this.rpc<ActionResult<T>>("create", [what, data]);
		if (res.error) throw new ResponseError(res.error.message);
		return output(what, res.result);
	}

	/**
	 * Create a graph edge between the from record(s) and the to record(s) using a specific edge record id
	 *
	 * @param from The in property on the edge record
	 * @param edge The id of the edge record
	 * @param to  The out property on the edge record
	 * @param data The optional record data to store on the edge
	 */
	async relate<T extends Doc, U extends Doc = T>(
		from: RelateInOut,
		edge: RecordId,
		to: RelateInOut,
		data?: U,
	): Promise<T>;

	/**
	 * Create a graph edge between the from record(s) and the to record(s) on the specified edge table
	 *
	 * @param from The in property on the edge record
	 * @param edge The edge table to create the relation in
	 * @param to  The out property on the edge record
	 * @param data The optional record data to store on the edge
	 */
	async relate<T extends Doc, U extends Doc = T>(
		from: RelateInOut,
		edge: Table,
		to: RelateInOut,
		data?: U,
	): Promise<T[]>;

	// Shadow implementation
	async relate<T extends Doc, U extends Doc = T>(
		from: RelateInOut,
		thing: Table | RecordId,
		to: RelateInOut,
		data?: U,
	) {
		await this.ready;
		const res = await this.rpc("relate", [from, thing, to, data]);
		if (res.error) throw new ResponseError(res.error.message);
		return output(thing, res.result);
	}

	/**
	 * Inserts one or multiple records into the database
	 *
	 * @param data One or more records to insert
	 */
	async insert<T extends Doc, U extends Doc = T>(
		data?: U | U[],
	): Promise<ActionResult<T>[]>;

	/**
	 * Inserts one or multiple records into the database
	 *
	 * @param table The table to insert the record into
	 * @param data One or more records to insert
	 */
	async insert<T extends Doc, U extends Doc = T>(
		table: Table,
		data?: U | U[],
	): Promise<ActionResult<T>[]>;

	// Shadow implementation
	async insert<T extends Doc, U extends Doc = T>(
		arg1: Table | U | U[],
		arg2?: U | U[],
	) {
		await this.ready;
		const params = arg1 instanceof Table ? [arg1, arg2] : [undefined, arg1];
		const res = await this.rpc<ActionResult<T>>("insert", params);
		if (res.error) throw new ResponseError(res.error.message);
		return res.result;
	}

	/**
	 * Inserts one or multiple relations in the database
	 *
	 * @param data One or more relations to insert
	 */
	async insertRelation<T extends Doc, U extends Doc = T>(
		data?: U | U[],
	): Promise<ActionResult<T>[]>;

	/**
	 * Inserts one or multiple relations in the database
	 *
	 * @param table The table to insert the relation into
	 * @param data One or more relations to insert
	 */
	async insertRelation<T extends Doc, U extends Doc = T>(
		table: Table,
		data?: U | U[],
	): Promise<ActionResult<T>[]>;

	// Shadow implementation
	async insertRelation<T extends Doc, U extends Doc = T>(
		arg1: Table | U | U[],
		arg2?: U | U[],
	) {
		await this.ready;
		const params = arg1 instanceof Table ? [arg1, arg2] : [undefined, arg1];
		const res = await this.rpc<ActionResult<T>>("insert_relation", params);
		if (res.error) throw new ResponseError(res.error.message);
		return res.result;
	}

	/**
	 * Updates a single record based on the provided Record ID
	 *
	 * ***NOTE: This function replaces the existing record data with the specified data***
	 *
	 * @param recordId The record ID to update
	 * @param data The record data to update
	 */
	async update<T extends Doc, U extends Doc = T>(
		recordId: RecordId,
		data?: U,
	): Promise<ActionResult<T>>;

	/**
	 * Updates all records based on the provided Record ID range
	 *
	 * ***NOTE: This function replaces the existing record data with the specified data***
	 *
	 * @param range The range of record IDs to update
	 * @param data The record data to update
	 */
	async update<T extends Doc, U extends Doc = T>(
		range: RecordIdRange,
		data?: U,
	): Promise<ActionResult<T>[]>;

	/**
	 * Updates all records present in the specified table
	 *
	 * ***NOTE: This function replaces the existing record data with the specified data***
	 *
	 * @param table The table to update
	 * @param data The record data to update
	 */
	async update<T extends Doc, U extends Doc = T>(
		range: Table,
		data?: U,
	): Promise<ActionResult<T>[]>;

	// Shadow implementation
	async update<T extends Doc, U extends Doc = T>(
		thing: RecordId | RecordIdRange | Table,
		data?: U,
	) {
		await this.ready;
		const res = await this.rpc<ActionResult<T>>("update", [thing, data]);
		if (res.error) throw new ResponseError(res.error.message);
		return output(thing, res.result);
	}

	/**
	 * Upserts a single record based on the provided Record ID
	 *
	 * ***NOTE: This function replaces the existing record data with the specified data**
	 *
	 * @param recordId The record ID to upsert
	 * @param data The record data to upsert
	 */
	async upsert<T extends Doc, U extends Doc = T>(
		recordId: RecordId,
		data?: U,
	): Promise<ActionResult<T>>;

	/**
	 * Upserts all records based on the provided Record ID range
	 *
	 * ***NOTE: This function replaces the existing record data with the specified data**
	 *
	 * @param range The range of record IDs to upsert
	 * @param data The record data to upsert
	 */
	async upsert<T extends Doc, U extends Doc = T>(
		thing: RecordIdRange,
		data?: U,
	): Promise<ActionResult<T>[]>;

	/**
	 * Upserts all records present in the specified table
	 *
	 * ***NOTE: This function replaces the existing record data with the specified data**
	 *
	 * @param table The table to upsert
	 * @param data The record data to upsert
	 */
	async upsert<T extends Doc, U extends Doc = T>(
		thing: Table,
		data?: U,
	): Promise<ActionResult<T>[]>;

	// Shadow implementation
	async upsert<T extends Doc, U extends Doc = T>(
		thing: RecordId | RecordIdRange | Table,
		data?: U,
	) {
		await this.ready;
		const res = await this.rpc<ActionResult<T>>("upsert", [thing, data]);
		if (res.error) throw new ResponseError(res.error.message);
		return output(thing, res.result);
	}

	/**
	 * Merges a single record based on the provided Record ID
	 *
	 * @param recordId The record ID to merge
	 * @param data The record data to merge
	 */
	async merge<T extends Doc, U extends Doc = Partial<T>>(
		thing: RecordId,
		data?: U,
	): Promise<ActionResult<T>>;

	/**
	 * Merges all records based on the provided Record ID range
	 *
	 * @param range The range of record IDs to merge
	 * @param data The record data to merge
	 */
	async merge<T extends Doc, U extends Doc = Partial<T>>(
		thing: RecordIdRange,
		data?: U,
	): Promise<ActionResult<T>[]>;

	/**
	 * Merges all records present in the specified table
	 *
	 * @param table The table to merge
	 * @param data The record data to merge
	 */
	async merge<T extends Doc, U extends Doc = Partial<T>>(
		thing: Table,
		data?: U,
	): Promise<ActionResult<T>[]>;

	// Shadow implementation
	async merge<T extends Doc, U extends Doc = Partial<T>>(
		thing: RecordId | RecordIdRange | Table,
		data?: U,
	) {
		await this.ready;
		const res = await this.rpc<ActionResult<T>>("merge", [thing, data]);
		if (res.error) throw new ResponseError(res.error.message);
		return output(thing, res.result);
	}

	/**
	 * Applies JSON Patch changes to all records, or a specific record, in the database
	 *
	 * ***NOTE: This function patches the existing record data with the specified JSON Patch operations***
	 *
	 * @param what The table name, record ID range, or specifc record ID to patch
	 * @param data The JSON Patch operations to apply
	 */
	async patch<T extends Doc>(
		what: RecordId,
		data?: Patch[],
		diff?: false,
	): Promise<ActionResult<T>>;
	async patch<T extends Doc>(
		what: RecordIdRange | Table,
		data?: Patch[],
		diff?: false,
	): Promise<ActionResult<T>[]>;
	async patch<T extends Doc>(
		what: RecordId,
		data: undefined | Patch[],
		diff: true,
	): Promise<Patch[]>;
	async patch<T extends Doc>(
		what: RecordIdRange | Table,
		data: undefined | Patch[],
		diff: true,
	): Promise<Patch[][]>;
	async patch(
		what: RecordId | RecordIdRange | Table,
		data?: Patch[],
		diff?: boolean,
	) {
		await this.ready;
		const res = await this.rpc<unknown>("patch", [what, data, diff]);
		if (res.error) throw new ResponseError(res.error.message);
		return diff ? res.result : output(what, res.result);
	}

	/**
	 * Deletes a single record from the database based on the provided Record ID
	 *
	 * @param recordId The record ID to delete
	 */
	async delete<T extends Doc>(recordId: RecordId): Promise<ActionResult<T>>;

	/**
	 * Deletes all records based on the provided Record ID range
	 *
	 * @param range The range of record IDs to delete
	 */
	async delete<T extends Doc>(thing: RecordIdRange): Promise<ActionResult<T>[]>;

	/**
	 * Deletes all records present in the specified table
	 *
	 * @param table The table to delete
	 */
	async delete<T extends Doc>(table: Table): Promise<ActionResult<T>[]>;

	// Shadow implementation
	async delete<T extends Doc>(thing: RecordId | RecordIdRange | Table) {
		await this.ready;
		const res = await this.rpc<ActionResult<T>>("delete", [thing]);
		if (res.error) throw new ResponseError(res.error.message);
		return output(thing, res.result);
	}

	/**
	 * Retrieves the version of the connected SurrealDB instance
	 *
	 * @example `surrealdb-2.1.0`
	 */
	async version(): Promise<string> {
		await this.ready;
		const res = await this.rpc<string>("version");
		if (res.error) throw new ResponseError(res.error.message);
		return res.result;
	}

	/**
	 * Run a SurrealQL function and return the result
	 *
	 * @param name The full name of the function to run
	 * @param args The arguments supplied to the function
	 */
	async run<T>(name: string, args?: unknown[]): Promise<T>;

	/**
	 * Run a SurrealML function with the specified version and return the result
	 *
	 * @param name The full name of the function to run
	 * @param version The version of the function to use
	 * @param args The arguments supplied to the function
	 */
	async run<T>(name: string, version: string, args?: unknown[]): Promise<T>;

	// Shadow implementation
	async run(name: string, arg2?: string | unknown[], arg3?: unknown[]) {
		await this.ready;
		const [version, args] = Array.isArray(arg2)
			? [undefined, arg2]
			: [arg2, arg3];

		const res = await this.rpc("run", [name, version, args]);
		if (res.error) throw new ResponseError(res.error.message);
		return res.result;
	}

	/**
	 * Export the database and return the result as a string
	 *
	 * @param options Optional export options
	 */
	public async export(options?: Partial<ExportOptions>): Promise<string> {
		await this.ready;
		return this.#connection.export(options);
	}

	/**
	 * Import an existing export into the database
	 *
	 * @param input The data to import
	 */
	public async import(input: string): Promise<void> {
		await this.ready;
		return this.#connection.import(input);
	}
}



================================================
FILE: packages/sdk/src/types/auth.ts
================================================
export type RootAuth = {
	username: string;
	password: string;
};

export type NamespaceAuth = {
	namespace: string;
	username: string;
	password: string;
};

export type DatabaseAuth = {
	namespace: string;
	database: string;
	username: string;
	password: string;
};

export type AccessSystemAuth = {
	namespace?: string;
	database?: string;
	username: string;
	password: string;
	access: string;
};

export type AccessBearerAuth = {
	namespace?: string;
	database?: string;
	access: string;
	key: string;
};

export type AccessRecordAuth = {
	namespace?: string;
	database?: string;
	access: string;
	variables: {
		ns?: never;
		db?: never;
		ac?: never;
		[K: string]: unknown;
	};
};

export type AnyAuth =
	| RootAuth
	| NamespaceAuth
	| DatabaseAuth
	| AccessSystemAuth
	| AccessBearerAuth
	| AccessRecordAuth;

export type Token = string;
export type AuthOrToken = AnyAuth | Token;
export type AuthCallable = () => AuthOrToken | Promise<AuthOrToken>;
export type AuthRenewer = boolean | AuthCallable;
export type AuthProvider = AuthOrToken | AuthCallable;

export type AuthResponse = {
	token: Token;
	refresh?: Token;
};



================================================
FILE: packages/sdk/src/types/export.ts
================================================
export interface ExportOptions {
	users: boolean;
	accesses: boolean;
	params: boolean;
	functions: boolean;
	analyzers: boolean;
	versions: boolean;
	tables: boolean | string[];
	records: boolean;
}



================================================
FILE: packages/sdk/src/types/helpers.ts
================================================
import type { RecordId, StringRecordId } from "../value";

export type Version = `${number}.${number}.${number}`;
export type Doc = Prettify<Record<string, unknown>>;

export type AnyRecordId<Tb extends string = string> =
	| RecordId<Tb>
	| StringRecordId;

export type RelateInOut =
	| RecordId
	| RecordId[]
	| StringRecordId
	| StringRecordId[];

export type Prettify<T> = {
	[K in keyof T]: T[K];
} & {};



================================================
FILE: packages/sdk/src/types/index.ts
================================================
export * from "./auth";
export * from "./export";
export * from "./helpers";
export * from "./live";
export * from "./patch";
export * from "./publisher";
export * from "./rpc";
export * from "./surreal";
export * from "./query";



================================================
FILE: packages/sdk/src/types/live.ts
================================================
import { type RecordId, type Table, Uuid } from "../value";
import type { Patch } from "./patch";

export const LIVE_ACTIONS = ["CREATE", "UPDATE", "DELETE", "KILLED"] as const;

export type LiveResource = Table;
export type LiveAction = (typeof LIVE_ACTIONS)[number];
export type LiveMessage = {
	id: Uuid;
	action: LiveAction;
	record: RecordId;
	result: Record<string, unknown>;
};

export type LiveResult = Record<string, unknown> | Patch;

export type LivePayload<Result extends LiveResult = Record<string, unknown>> =
	| LivePayloadUpdate<Result>
	| LivePayloadClosed;

export type LivePayloadUpdate<
	Result extends LiveResult = Record<string, unknown>,
> = [action: Exclude<LiveAction, "KILLED">, result: Result, id: RecordId];

export type LivePayloadClosed = [
	action: "CLOSED",
	reason: "KILLED" | "DISCONNECTED",
];

export type LiveHandler<Result extends LiveResult = Record<string, unknown>> = (
	...[action, result]: LivePayload<Result>
) => unknown;

export function isLiveMessage(v: unknown): v is LiveMessage {
	if (typeof v !== "object") return false;
	if (v === null) return false;
	if (!("id" in v && "action" in v && "result" in v)) return false;

	if (!(v.id instanceof Uuid)) return false;
	if (!LIVE_ACTIONS.includes(v.action as LiveAction)) return false;
	if (typeof v.result !== "object") return false;
	if (v.result === null) return false;

	return true;
}



================================================
FILE: packages/sdk/src/types/patch.ts
================================================
type BasePatch<T = string> = {
	path: T;
};

export type AddPatch<T = string, U = unknown> = BasePatch<T> & {
	op: "add";
	value: U;
};

export type RemovePatch<T = string> = BasePatch<T> & {
	op: "remove";
};

export type ReplacePatch<T = string, U = unknown> = BasePatch<T> & {
	op: "replace";
	value: U;
};

export type ChangePatch<T = string, U = string> = BasePatch<T> & {
	op: "change";
	value: U;
};

export type CopyPatch<T = string, U = string> = BasePatch<T> & {
	op: "copy";
	from: U;
};

export type MovePatch<T = string, U = string> = BasePatch<T> & {
	op: "move";
	from: U;
};

export type TestPatch<T = string, U = unknown> = BasePatch<T> & {
	op: "test";
	value: U;
};

export type Patch =
	| AddPatch
	| RemovePatch
	| ReplacePatch
	| ChangePatch
	| CopyPatch
	| MovePatch
	| TestPatch;



================================================
FILE: packages/sdk/src/types/publisher.ts
================================================
export type EventPayload = Record<string | number | symbol, unknown[]>;

export interface EventPublisher<EventMap extends EventPayload> {
	/**
	 * Subscribe to an event, invoking the provided listener when the event is emitted.
	 *
	 * @param event The event to subscribe to
	 * @param listener The listener to invoke when the event is emitted
	 * @returns A function to unsubscribe from the event
	 */
	subscribe<K extends keyof EventMap>(
		event: K,
		listener: (...payload: EventMap[K]) => void,
	): () => void;
}



================================================
FILE: packages/sdk/src/types/query.ts
================================================
import type { Fill } from "@surrealdb/cbor";
import type { PreparedQuery } from "../utils";

export type QueryParameters =
	| [query: string, bindings?: Record<string, unknown>]
	| [prepared: PreparedQuery, gaps?: Fill[]];

export type QueryResult<T = unknown> = QueryResultOk<T> | QueryResultErr;
export type QueryResultOk<T> = {
	status: "OK";
	time: string;
	result: T;
};

export type QueryResultErr = {
	status: "ERR";
	time: string;
	result: string;
};

export type MapQueryResult<T> = {
	[K in keyof T]: QueryResult<T[K]>;
};



================================================
FILE: packages/sdk/src/types/rpc.ts
================================================
import type { RecordId } from "../value";
import type { Prettify } from "./helpers";

export type RpcRequest<
	Method extends string = string,
	Params extends unknown[] | undefined = unknown[],
> = {
	method: Method;
	params?: Params;
};

export type RpcResponse<Result = unknown> =
	| RpcSuccessResponse<Result>
	| RpcErrorResponse;

export type RpcSuccessResponse<Result = unknown> = {
	result: Result;
	error?: never;
};

export type RpcErrorResponse = {
	result?: never;
	error: {
		code: number;
		message: string;
	};
};

export type ActionResult<T extends Record<string, unknown>> = Prettify<
	T["id"] extends RecordId ? T : { id: RecordId } & T
>;



================================================
FILE: packages/sdk/src/types/surreal.ts
================================================
import type { decodeCbor, encodeCbor } from "../cbor";
import type { ReconnectContext } from "../internal/reconnect";
import type { AuthProvider, AuthRenewer } from "./auth";
import type { ExportOptions } from "./export";
import type { LiveMessage } from "./live";
import type { EventPublisher } from "./publisher";
import type { RpcRequest, RpcResponse } from "./rpc";

export type ConnectionStatus =
	| "disconnected"
	| "connecting"
	| "reconnecting"
	| "connected";

export type EngineImpl = new (context: DriverContext) => SurrealEngine;

export type EngineEvents = {
	connecting: [];
	connected: [];
	reconnecting: [];
	disconnected: [];
	error: [Error];
	live: [LiveMessage];
};

/**
 * An engine responsible for communicating to a SurrealDB datastore
 */
export interface SurrealEngine extends EventPublisher<EngineEvents> {
	open(state: ConnectionState): void;
	close(): Promise<void>;

	export(options?: Partial<ExportOptions>): Promise<string>;
	import(data: string): Promise<void>;

	send<Method extends string, Params extends unknown[] | undefined, Result>(
		request: RpcRequest<Method, Params>,
	): Promise<RpcResponse<Result>>;
}

/**
 * Options used to configure behavior of the SurrealDB driver
 */
export interface DriverOptions {
	engines?: Record<string, EngineImpl>;
	websocketImpl?: typeof WebSocket;
}

/**
 * Options used to customize a specific connection to a SurrealDB datastore
 */
export interface ConnectOptions {
	/**
	 * The namespace to use for this connection.
	 */
	namespace?: string;
	/**
	 * The database to use for this connection.
	 */
	database?: string;
	/**
	 * Authentication details to use when connecting to the datastore. You can provide a static value,
	 * or a function which is called to retrieve the authentication details. Authentication details
	 * may be requested on connect, reconnect, or when the access token expires.
	 */
	authentication?: AuthProvider;
	/**
	 * Automatically check for version compatibility on connect. When the version is not supported,
	 * an error will be thrown and the connection will not be established.
	 *
	 * @default true
	 */
	versionCheck?: boolean;
	/**
	 * Configure automatic session renewal.
	 *
	 * - When set to `false`, the driver will invalidate the session when the access token expires.
	 * - When set to `true`, the driver will renew the session using the configured `authentication` details.
	 * - When set to a function, the function will be called to renew the session.
	 *
	 * @default true
	 */
	renewAccess?: AuthRenewer;
	/**
	 * Configure reconnect behavior for supported engines (WebSocket).
	 *
	 * - When set to `false`, the driver will remain disconnected after a connection is lost.
	 * - When set to `true`, the driver will attempt to reconnect using default options.
	 * - When set to an object, the driver will attempt to reconnect using the provided options.
	 *
	 * @default true
	 */
	reconnect?: boolean | Partial<ReconnectOptions>;
}

/**
 * Options to configure reconnect behavior
 */
export interface ReconnectOptions {
	/** Reconnect after a connection has unexpectedly dropped */
	enabled: boolean;
	/** How many attempts will be made at reconnecting, -1 for unlimited */
	attempts: number;
	/** The minimum amount of time in milliseconds to wait before reconnecting */
	retryDelay: number;
	/** The maximum amount of time in milliseconds to wait before reconnecting */
	retryDelayMax: number;
	/** The amount to multiply the delay by after each failed attempt */
	retryDelayMultiplier: number;
	/** A float percentage to randomly offset each delay by  */
	retryDelayJitter: number;
	/** Handle errors caught during reconnecting */
	catch?: (error: Error) => boolean;
}

/**
 * The current state of a connection to a SurrealDB datastore
 */
export interface ConnectionState {
	url: URL;
	reconnect: ReconnectContext;
	variables: Record<string, unknown>;
	namespace?: string;
	database?: string;
	accessToken?: string;
	refreshToken?: string;
}

/**
 * Context information passed to each controller and engine
 */
export interface DriverContext {
	options: DriverOptions;
	encode: typeof encodeCbor;
	decode: typeof decodeCbor;
}



================================================
FILE: packages/sdk/src/utils/equals.ts
================================================
import { Value } from "../value/value";

/**
 * Recursively compare supported SurrealQL values for equality.
 *
 * @param x The first value to compare
 * @param y The second value to compare
 * @returns Whether the two values are recursively equal
 */
export function equals(x: unknown, y: unknown): boolean {
	if (Object.is(x, y)) return true;
	if (x instanceof Date && y instanceof Date) {
		return x.getTime() === y.getTime();
	}
	if (x instanceof RegExp && y instanceof RegExp) {
		return x.toString() === y.toString();
	}
	if (x instanceof Value && y instanceof Value) {
		return x.equals(y);
	}
	if (
		typeof x !== "object" ||
		x === null ||
		typeof y !== "object" ||
		y === null
	) {
		return false;
	}
	const keysX = Reflect.ownKeys(x as unknown as object) as (keyof typeof x)[];
	const keysY = Reflect.ownKeys(y as unknown as object);
	if (keysX.length !== keysY.length) return false;
	for (let i = 0; i < keysX.length; i++) {
		if (!Reflect.has(y as unknown as object, keysX[i])) return false;
		if (!equals(x[keysX[i]], y[keysX[i]])) return false;
	}
	return true;
}



================================================
FILE: packages/sdk/src/utils/escape.ts
================================================
import { isValidIdPart } from "../internal/validation";
import { Range, type RecordIdValue, Uuid } from "../value";
import type { Bound } from "./range";
import { toSurrealqlString } from "./to-surql-string";

const MAX_i64 = 9223372036854775807n;

function isOnlyNumbers(str: string): boolean {
	return /^[\d_]+$/.test(str);
}

/**
 * Escape a given string to be used as a valid SurrealQL ident
 *
 * @param str - The string to escape
 * @returns Optionally escaped string
 */
export function escapeIdent(str: string): string {
	// String which looks like a number should always be escaped, to prevent it from being parsed as a number
	if (isOnlyNumbers(str)) {
		return `⟨${str}⟩`;
	}

	// Empty string should always be escaped
	if (str === "") {
		return "⟨⟩";
	}

	let code: number;
	let i: number;
	let len: number;

	for (i = 0, len = str.length; i < len; i++) {
		code = str.charCodeAt(i);
		if (
			!(code > 47 && code < 58) && // numeric (0-9)
			!(code > 64 && code < 91) && // upper alpha (A-Z)
			!(code > 96 && code < 123) && // lower alpha (a-z)
			!(code === 95) // underscore (_)
		) {
			return `⟨${str.replaceAll("⟩", "\\⟩")}⟩`;
		}
	}

	return str;
}

/**
 * Escape a number to be used as a valid SurrealQL ident
 *
 * @param num - The number to escape
 * @returns Optionally escaped number
 */
export function escapeNumber(num: number | bigint): string {
	return num <= MAX_i64 ? num.toString() : `⟨${num}⟩`;
}

/**
 * Escape a record id value part
 *
 * @paraord id value part
 * @returns The escaped record id value part
 */
export function escapeIdPart(id: RecordIdValue): string {
	return id instanceof Uuid
		? `u"${id}"`
		: typeof id === "string"
			? escapeIdent(id)
			: typeof id === "bigint" || typeof id === "number"
				? escapeNumber(id)
				: toSurrealqlString(id);
}

/**
 * Escape a range bound value
 *
 * @param bound The range bound containing a value
 * @returns The escaped range bound
 */
export function escapeRangeBound<T>(bound: Bound<T>): string {
	if (bound === undefined) return "";
	const value = bound.value;

	if (isValidIdPart(value)) return escapeIdPart(value);
	if (value instanceof Range) return `(${toSurrealqlString(value)})`;
	return toSurrealqlString(value);
}



================================================
FILE: packages/sdk/src/utils/index.ts
================================================
export * from "./equals";
export * from "./escape";
export * from "./jsonify";
export * from "./prepared-query";
export * from "./publisher";
export * from "./range";
export * from "./string-prefixes";
export * from "./tagged-template";
export * from "./to-surql-string";
export * from "./version";



================================================
FILE: packages/sdk/src/utils/jsonify.ts
================================================
import type {
	Decimal,
	Duration,
	Future,
	Geometry,
	Range,
	RecordId,
	RecordIdRange,
	StringRecordId,
	Table,
	Uuid,
} from "../value";

import { Value } from "../value/value";

export type Jsonify<T> = T extends
	| Date
	| Uuid
	| Decimal
	| Duration
	| Future
	| Range<unknown, unknown>
	| StringRecordId
	? string
	: T extends undefined
		? never
		: T extends Record<string | number | symbol, unknown> | Array<unknown>
			? { [K in keyof T]: Jsonify<T[K]> }
			: T extends Map<infer K, infer V>
				? Map<K, Jsonify<V>>
				: T extends Set<infer V>
					? Set<Jsonify<V>>
					: T extends Geometry
						? ReturnType<T["toJSON"]>
						: T extends RecordId<infer Tb>
							? `${Tb}:${string}`
							: T extends RecordIdRange<infer Tb>
								? `${Tb}:${string}..${string}`
								: T extends Table<infer Tb>
									? `${Tb}`
									: T;
/**
 * Recursively convert any supported SurrealQL value into a serializable JSON representation.
 *
 * @param input The input value
 * @returns JSON-safe representation
 */
export function jsonify<T>(input: T): Jsonify<T> {
	if (typeof input === "object") {
		if (input === null) return null as Jsonify<T>;

		// We only want to process "SurrealQL values"
		if (input instanceof Date || input instanceof Value) {
			return input.toJSON() as Jsonify<T>;
		}

		// We check by prototype, because we do not want to process derivatives of objects and arrays
		switch (Object.getPrototypeOf(input)) {
			case Object.prototype: {
				const entries = Object.entries(input as object);
				const mapped = entries
					.map(([k, v]) => [k, jsonify(v)])
					.filter(([_, v]) => v !== undefined);
				return Object.fromEntries(mapped) as Jsonify<T>;
			}
			case Map.prototype: {
				const entries = Array.from(input as [string, unknown][]);
				const mapped = entries
					.map(([k, v]) => [k, jsonify(v)])
					.filter(([_, v]) => v !== undefined);
				return new Map(mapped as [string, unknown][]) as Jsonify<T>;
			}
			case Array.prototype:
				return (input as []).map(jsonify) as Jsonify<T>;
			case Set.prototype:
				return new Set([...(input as [])].map(jsonify)) as Jsonify<T>;
		}
	}

	return input as Jsonify<T>;
}



================================================
FILE: packages/sdk/src/utils/live.ts
================================================
import type { ConnectionController } from "../controller";
import { ConnectionUnavailable, LiveSubscriptionFailed } from "../errors";
import type {
	LiveHandler,
	LivePayload,
	LiveResource,
	LiveResult,
	RpcResponse,
} from "../types";
import type { Uuid } from "../value";
import type { Publisher } from "./publisher";

type ErrorPublisher = Publisher<{
	error: [Error];
}>;

/**
 * Represents a subscription to a LIVE SELECT query
 */
export abstract class LiveSubscription {
	/*implements AsyncIterable<LivePayload>*/
	/**
	 * The ID of the live subscription. Note that this id might change after
	 * a live query has been restarted.
	 */
	abstract get id(): Uuid;

	/**
	 * Returns whether this LiveQuery is managed by the driver and may be automatically
	 * restarted once the connection is re-established.
	 */
	abstract get isManaged(): boolean;

	/**
	 * The live resource that this subscription is tracking, if any.
	 */
	abstract get resource(): LiveResource | undefined;

	/**
	 * Whether the LiveQuery is considered alive. Although the connection may be
	 * disconnected, the LiveQuery may still be alive if it is managed by the driver.
	 */
	abstract get isAlive(): boolean;

	/**
	 * Subscribe to live updates and invoke the handler when an update is received
	 *
	 * @param handler The handler to invoke when an update is received
	 * @returns A function to unsubscribe from the live updates
	 */
	abstract subscribe(handler: LiveHandler): () => void;

	/**
	 * Kill the live subscription and stop receiving updates
	 */
	abstract kill(): Promise<RpcResponse<unknown>>;

	/**
	 * Iterate over the live subscription using an async iterator
	 */
	iterate<Result extends LiveResult = Record<string, unknown>>(): AsyncIterator<
		LivePayload<Result>
	> {
		const queue: LivePayload<Result>[] = [];
		const waiters: (() => void)[] = [];

		const close = this.subscribe((...args) => {
			if (args[0] === "CLOSED" && this.isAlive) return;

			queue.push(args as LivePayload<Result>);
			const waiter = waiters.shift();
			if (waiter) waiter();
		});

		async function poll(): Promise<LivePayload<Result>> {
			let value = queue.shift();
			if (value) return value;

			const { promise, resolve } = Promise.withResolvers();
			waiters.push(resolve);
			await promise;

			value = queue.shift();
			if (!value)
				throw new Error("A notification was promised, but none was received");
			return value;
		}

		return {
			next: async (): Promise<IteratorResult<LivePayload<Result>>> => {
				const value = await poll();
				return {
					value,
					done: value[0] === "CLOSED",
				};
			},

			return: async () => {
				close();
				while (waiters.length) waiters.shift()?.(); // clean up
				return { done: true, value: undefined };
			},
		};
	}

	[Symbol.asyncIterator]<
		Result extends LiveResult = Record<string, unknown>,
	>(): AsyncIterator<LivePayload<Result>> {
		return this.iterate<Result>();
	}
}

/**
 * A managed live subscription that is automatically restarted when the connection
 * is re-established.
 */
export class ManagedLiveSubscription extends LiveSubscription {
	#currentId!: Uuid;
	#controller: ConnectionController;
	#resource: LiveResource;
	#diff: boolean;
	#killed = false;
	#cleanup: (() => void) | undefined;
	#publisher: ErrorPublisher;
	#reconnector: () => void;
	#listeners: Set<LiveHandler> = new Set();

	constructor(
		publisher: ErrorPublisher,
		controller: ConnectionController,
		resource: LiveResource,
		diff: boolean,
	) {
		super();
		this.#publisher = publisher;
		this.#controller = controller;
		this.#resource = resource;
		this.#diff = diff;

		this.#reconnector = this.#controller.subscribe("connected", () => {
			this.#listen();
		});

		if (this.#controller.status === "connected") {
			this.#listen();
		}
	}

	public get id(): Uuid {
		return this.#currentId;
	}

	public get isManaged(): boolean {
		return true;
	}

	public get resource(): LiveResource {
		return this.#resource;
	}

	public get isAlive(): boolean {
		return !this.#killed;
	}

	public subscribe(handler: LiveHandler): () => void {
		this.#listeners.add(handler);

		return () => {
			this.#listeners.delete(handler);
		};
	}

	public kill(): Promise<RpcResponse<unknown>> {
		this.#killed = true;
		for (const listener of this.#listeners) {
			listener("CLOSED", "KILLED");
		}

		this.#listeners.clear();
		this.#cleanup?.();
		this.#reconnector();

		return this.#controller.rpc({
			method: "kill",
			params: [this.#currentId],
		});
	}

	async #listen(): Promise<void> {
		this.#cleanup?.();

		const response: RpcResponse<Uuid> = await this.#controller.rpc({
			method: "live",
			params: [this.#resource, this.#diff],
		});

		if (response.error) {
			this.#publisher.publish("error", new LiveSubscriptionFailed(response));
			return;
		}

		this.#currentId = response.result;
		this.#cleanup = this.#controller.liveSubscribe(
			response.result,
			(...args) => {
				for (const listener of this.#listeners) {
					listener(...args);
				}
			},
		);

		this.#controller.subscribe("disconnected", () => {
			for (const listener of this.#listeners) {
				listener("CLOSED", "DISCONNECTED");
			}
		});
	}
}

/**
 * An unmanaged live subscription which is constructed with only
 * a known pre-existing ID. This subscription will not be automatically
 * restarted when the connection is re-established.
 */
export class UnmanagedLiveSubscription extends LiveSubscription {
	#id: Uuid;
	#controller: ConnectionController;
	#killed = false;
	#cleanup: () => void;
	#listeners: Set<LiveHandler> = new Set();

	constructor(controller: ConnectionController, id: Uuid) {
		super();
		this.#controller = controller;
		this.#id = id;

		if (this.#controller.status !== "connected") {
			throw new ConnectionUnavailable();
		}

		this.#cleanup = this.#controller.liveSubscribe(id, (...args) => {
			for (const listener of this.#listeners) {
				listener(...args);
			}
		});

		this.#controller.subscribe("disconnected", () => {
			for (const listener of this.#listeners) {
				listener("CLOSED", "DISCONNECTED");
			}
		});
	}

	public get id(): Uuid {
		return this.#id;
	}

	public get isManaged(): boolean {
		return false;
	}

	public get resource(): undefined {
		return undefined;
	}

	public get isAlive(): boolean {
		return !this.#killed;
	}

	public subscribe(handler: LiveHandler): () => void {
		this.#listeners.add(handler);

		return () => {
			this.#listeners.delete(handler);
		};
	}

	public kill(): Promise<RpcResponse<unknown>> {
		this.#killed = true;
		for (const listener of this.#listeners) {
			listener("CLOSED", "KILLED");
		}

		this.#listeners.clear();
		this.#cleanup();

		return this.#controller.rpc({
			method: "kill",
			params: [this.#id],
		});
	}
}



================================================
FILE: packages/sdk/src/utils/prepared-query.ts
================================================
import {
	Encoded,
	type Fill,
	Gap,
	type PartiallyEncoded,
	Writer,
	encode,
	partiallyEncodeObject,
} from "@surrealdb/cbor";

import { REPLACER } from "../cbor/replacer";

let textEncoder: TextEncoder;

/**
 * A prepared query partially encodes a SurrealQL query string
 * and its bindings ahead of tim in order to speed up repeated
 * executions of the same query.
 */
export class PreparedQuery {
	private _query: Uint8Array;
	private _bindings: Record<string, PartiallyEncoded>;
	private length: number;

	constructor(query: string, bindings?: Record<string, unknown>) {
		textEncoder ??= new TextEncoder();
		this._query = textEncoder.encode(query);
		this._bindings = partiallyEncodeObject(bindings ?? {}, {
			replacer: REPLACER.encode,
		});
		this.length = Object.keys(this._bindings).length;
	}

	/**
	 * Retrieves the encoded query string.
	 */
	get query(): Encoded {
		// Up to 9 bytes for the prefix
		const w = new Writer(this._query.byteLength + 9);
		w.writeMajor(3, this._query.byteLength);
		w.writeUint8Array(this._query);
		return new Encoded(w.output(false));
	}

	/**
	 * Retrieves the encoded bindings.
	 */
	get bindings(): Record<string, PartiallyEncoded> {
		return this._bindings;
	}

	/**
	 * Compile this query and its bindings into a single ArrayBuffer, optionally filling gaps.
	 *
	 * @param fills The gap values to fill
	 */
	build(fills?: Fill[]): Uint8Array {
		return encode([this.query, this.bindings], { fills });
	}

	/**
	 * A template literal tag function for appending additional query segments and bindings to the prepared query.
	 *
	 * @param rawQuery The additional query segments to append
	 * @param values The additional interpolated values to append
	 * @example
	 * const query = surrealql`SELECT * FROM person`;
	 *
	 * if (filter) {
	 *   query.append` WHERE name = ${filter}`;
	 * }
	 */
	append(
		rawQuery: string[] | TemplateStringsArray,
		...values: unknown[]
	): PreparedQuery {
		const base = this.length;
		this.length += values.length;

		let reused = 0;
		const gaps = new Map<Gap, number>();
		const mapped_bindings = values.map((v, i) => {
			if (v instanceof Gap) {
				const index = gaps.get(v);
				if (index !== undefined) {
					reused++;
					return [`bind___${index}`, v] as const;
				}

				gaps.set(v, i - reused);
			}

			return [`bind___${base + i - reused}`, v] as const;
		});

		for (const [k, v] of mapped_bindings) {
			this._bindings[k] = encode(v, {
				replacer: REPLACER.encode,
				partial: true,
			});
		}

		const query = rawQuery
			.flatMap((segment, i) => {
				const variable = mapped_bindings[i]?.[0];
				return [segment, ...(variable ? [`$${variable}`] : [])];
			})
			.join("");

		textEncoder ??= new TextEncoder();
		const current = new Uint8Array(this._query);
		const added = textEncoder.encode(query);
		this._query = new Uint8Array(current.byteLength + added.byteLength);
		this._query.set(current);
		this._query.set(added, current.byteLength);
		return this;
	}
}



================================================
FILE: packages/sdk/src/utils/publisher.ts
================================================
import type { EventPayload, EventPublisher } from "../types/publisher";

export class Publisher<T extends EventPayload> implements EventPublisher<T> {
	#subscriptions: Partial<{
		[K in keyof T]: Set<(...event: T[K]) => void>;
	}> = {};

	subscribe<K extends keyof T>(
		event: K,
		listener: (...event: T[K]) => void,
	): () => void {
		this.#subscriptions[event] ??= new Set();
		this.#subscriptions[event]?.add(listener);

		return () => {
			const subscriptions = this.#subscriptions[event];

			if (subscriptions?.delete(listener) && subscriptions.size === 0) {
				delete this.#subscriptions[event];
			}
		};
	}

	subscribeFirst<K extends keyof T>(...events: K[]): Promise<T[K]> {
		const subscriptions: (() => void)[] = [];

		return new Promise((resolve) => {
			for (const event of events) {
				const unsubscribe = this.subscribe(event, (...payload: T[K]) => {
					for (const subscription of subscriptions) {
						subscription();
					}

					resolve(payload);
				});

				subscriptions.push(unsubscribe);
			}
		});
	}

	publish<K extends keyof T>(event: K, ...payload: T[K]): void {
		const subscriptions = this.#subscriptions[event];

		if (!subscriptions) {
			return;
		}

		for (const subscription of subscriptions) {
			subscription(...payload);
		}
	}
}



================================================
FILE: packages/sdk/src/utils/range.ts
================================================
/**
 * Represents a range bound which includes the value within the range
 */
export class BoundIncluded<T> {
	constructor(readonly value: T) {}
}

/**
 * Represents a range bound which excludes the value from the range
 */
export class BoundExcluded<T> {
	constructor(readonly value: T) {}
}

/**
 * Represents a Bound which can represent the start or end of a range
 */
export type Bound<T> = BoundIncluded<T> | BoundExcluded<T> | undefined;



================================================
FILE: packages/sdk/src/utils/string-prefixes.ts
================================================
import { StringRecordId, Uuid } from "../value";

/**
 * A template literal tag function for parsing a string type.
 *
 * @param string The string to parse
 * @param values The interpolated values
 * @returns The parsed string
 */
export function s(
	string: string[] | TemplateStringsArray,
	...values: unknown[]
): string {
	return string.reduce(
		(prev, curr, i) => `${prev}${curr}${values[i] ?? ""}`,
		"",
	);
}

/**
 * A template literal tag function for parsing a string into a Date.
 *
 * @param string The string to parse
 * @param values The interpolated values
 * @returns The parsed Date
 */
export function d(
	string: string[] | TemplateStringsArray,
	...values: unknown[]
): Date {
	return new Date(s(string, values));
}

/**
 * A template literal tag function for parsing a string into a StringRecordId.
 *
 * @param string The string to parse
 * @param values The interpolated values
 * @returns The parsed StringRecordId
 */
export function r(
	string: string[] | TemplateStringsArray,
	...values: unknown[]
): StringRecordId {
	return new StringRecordId(s(string, values));
}

/**
 * A template literal tag function for parsing a string into a Uuid.
 *
 * @param string The string to parse
 * @param values The interpolated values
 * @returns The parsed Uuid
 */
export function u(
	string: string[] | TemplateStringsArray,
	...values: unknown[]
): Uuid {
	return new Uuid(s(string, values));
}



================================================
FILE: packages/sdk/src/utils/tagged-template.ts
================================================
import { Gap } from "@surrealdb/cbor";
import { PreparedQuery } from "./prepared-query.ts";

/**
 * A template literal tag function for creating prepared queries from query strings.
 * Interpolated values are automatically stored as bindings.
 * @param query_raw - The raw query string
 * @param values - The interpolated values
 * @example const query = surrealql`SELECT * FROM ${id}`;
 * @returns A PreparedQuery instance
 */
export function surrealql(
	rawQuery: string[] | TemplateStringsArray,
	...values: unknown[]
): PreparedQuery {
	let reused = 0;
	const gaps = new Map<Gap, number>();
	const mapped_bindings = values.map((v, i) => {
		if (v instanceof Gap) {
			const index = gaps.get(v);
			if (index !== undefined) {
				reused++;
				return [`bind___${index}`, v] as const;
			}

			gaps.set(v, i - reused);
		}

		return [`bind___${i - reused}`, v] as const;
	});

	const bindings = mapped_bindings.reduce<Record<`bind___${number}`, unknown>>(
		(prev, [k, v]) => {
			prev[k] = v;
			return prev;
		},
		{},
	);

	const query = rawQuery
		.flatMap((segment, i) => {
			const variable = mapped_bindings[i]?.[0];
			return [segment, ...(variable ? [`$${variable}`] : [])];
		})
		.join("");

	return new PreparedQuery(query, bindings);
}

export { surrealql as surql };



================================================
FILE: packages/sdk/src/utils/to-surql-string.ts
================================================
import {
	Decimal,
	Duration,
	Future,
	Geometry,
	Range,
	RecordId,
	StringRecordId,
	Table,
	Uuid,
} from "../value";

/**
 * Recursively convert any supported SurrealQL value into a string representation.
 *
 * @param input The input value
 * @returns Stringified SurrealQL representation
 */
export function toSurqlString(input: unknown): string {
	if (typeof input === "string") return `s${JSON.stringify(input)}`;
	if (input === null) return "NULL";
	if (input === undefined) return "NONE";

	if (typeof input === "object") {
		if (input instanceof Date) return `d${JSON.stringify(input.toISOString())}`;
		if (input instanceof Uuid) return `u${JSON.stringify(input.toString())}`;
		if (input instanceof RecordId || input instanceof StringRecordId)
			return `r${JSON.stringify(input.toString())}`;

		if (input instanceof Geometry) return toSurqlString(input.toJSON());

		if (
			input instanceof Decimal ||
			input instanceof Duration ||
			input instanceof Future ||
			input instanceof Range ||
			input instanceof Table
		) {
			return input.toJSON();
		}

		// We check by prototype, because we do not want to process derivatives of objects and arrays
		switch (Object.getPrototypeOf(input)) {
			case Object.prototype: {
				let output = "{ ";
				const entries = Object.entries(input as object);
				for (const [i, [k, v]] of entries.entries()) {
					output += `${JSON.stringify(k)}: ${toSurqlString(v)}`;
					if (i < entries.length - 1) output += ", ";
				}
				output += " }";
				return output;
			}
			case Map.prototype: {
				let output = "{ ";
				const entries = Array.from((input as Map<unknown, unknown>).entries());
				for (const [i, [k, v]] of entries.entries()) {
					output += `${JSON.stringify(k)}: ${toSurqlString(v)}`;
					if (i < entries.length - 1) output += ", ";
				}
				output += " }";
				return output;
			}
			case Array.prototype: {
				const array = (input as unknown[]).map(toSurqlString);
				return `[ ${array.join(", ")} ]`;
			}
			case Set.prototype: {
				const set = [...(input as [])].map(toSurqlString);
				return `[ ${set.join(", ")} ]`;
			}
		}
	}

	return `${input}`;
}

export { toSurqlString as toSurrealqlString };



================================================
FILE: packages/sdk/src/utils/version.ts
================================================
import { UnsupportedVersion } from "../errors.ts";
import type { Version } from "../types";

export const MINIMUM_VERSION: Version = "2.0.0";
export const MAXIMUM_VERSION: Version = "4.0.0";
export const VERSION_SUPPORT_RANGE: string = `>= ${MINIMUM_VERSION} < ${MAXIMUM_VERSION}`;

/**
 * Check if the current driver version is compatible with the provided
 * version of SurrealDB.
 *
 * @param version The version of SurrealDB to check against
 * @param min Custom minimum version to check against
 * @param until Custom maximum version to check against
 * @throws UnsupportedVersion if the version is not supported
 */
export function versionCheck(
	version: string,
	min: Version = MINIMUM_VERSION,
	until: Version = MAXIMUM_VERSION,
): true {
	if (!isVersionSupported(version, min, until)) {
		throw new UnsupportedVersion(version, `>= ${min} < ${until}`);
	}

	return true;
}

/**
 * Returns whether the current driver version is compatible with the provided
 * version of SurrealDB.
 *
 * @param version The version of SurrealDB to check against
 * @param min Custom minimum version to check against
 * @param until Custom maximum version to check against
 * @returns true if the version is supported, false otherwise
 */
export function isVersionSupported(
	version: string,
	min: Version = MINIMUM_VERSION,
	until: Version = MAXIMUM_VERSION,
): boolean {
	const trimmed = version.replace("surrealdb-", "").trim();

	return (
		min.localeCompare(trimmed, undefined, {
			numeric: true,
		}) <= 0 &&
		until.localeCompare(trimmed, undefined, {
			numeric: true,
		}) === 1
	);
}



================================================
FILE: packages/sdk/src/value/decimal.ts
================================================
import { Value } from "./value";

/**
 * Represents a high-precision decimal number with an integer and fractional part.
 * Useful for financial and scientific calculations that require precision beyond JavaScript's native number type.
 */
export class Decimal extends Value {
	#int: bigint;
	#frac: bigint;
	#scale: number;

	/**
	 * Constructs a Decimal from various types.
	 * @param input - The input to construct from: string, number, bigint, Decimal, or a tuple [int, frac, scale].
	 */
	constructor(
		input: string | number | bigint | Decimal | [bigint, bigint, number],
	) {
		super();

		if (input instanceof Decimal) {
			// Clone from another Decimal
			this.#int = input.#int;
			this.#frac = input.#frac;
			this.#scale = input.#scale;
			return;
		}

		if (typeof input === "bigint") {
			// Treat bigint as integer with no fractional part
			this.#int = input;
			this.#frac = 0n;
			this.#scale = 0;
			return;
		}

		if (Array.isArray(input)) {
			// Unpack int, frac, and scale and normalize overflow in fractional part
			let [int, frac, scale] = input;
			const maxFrac = 10n ** BigInt(scale);
			if (frac >= maxFrac) {
				int += frac / maxFrac;
				frac %= maxFrac;
			}
			this.#int = int;
			this.#frac = frac;
			this.#scale = scale;
			return;
		}

		if (typeof input === "string" && /e/i.test(input)) {
			// Parse scientific notation like "1.23e4"
			const dec = Decimal.fromScientificNotation(input);
			this.#int = dec.#int;
			this.#frac = dec.#frac;
			this.#scale = dec.#scale;
			return;
		}

		// Convert string/number to string and trim whitespace
		const str = input.toString().trim();
		const isNegative = str.startsWith("-");
		const clean = isNegative ? str.slice(1) : str;
		const [intStrRaw, fracStrRaw = ""] = clean.split(".");

		// Sanitize int/frac parts
		const safeInt = /^\d+$/.test(intStrRaw) ? intStrRaw : "0";
		const safeFrac = /^\d+$/.test(fracStrRaw) ? fracStrRaw : "0";

		const intStr = safeInt || "0";
		const fracStr = safeFrac.padEnd(safeFrac.length || 1, "0");

		// Parse parts to bigint
		const absInt = BigInt(intStr);
		const absFrac = BigInt(fracStr);

		// Apply sign
		this.#int = isNegative ? -absInt : absInt;
		this.#frac = isNegative ? -absFrac : absFrac;
		this.#scale = safeFrac.length;
	}

	/** Returns the integer part of the number. */
	get int(): bigint {
		return this.#int;
	}

	/** Returns the fractional part of the number. */
	get frac(): bigint {
		return this.#frac;
	}

	/** Returns the scale (number of decimal places). */
	get scale(): number {
		return this.#scale;
	}

	/**
	 * Returns the string representation of the decimal.
	 * Trailing zeros in fractional part are trimmed.
	 * @returns The canonical string format.
	 */
	toString(): string {
		const sign = this.#int < 0n || this.#frac < 0n ? "-" : "";
		const absInt = this.#int < 0n ? -this.#int : this.#int;
		const absFrac = this.#frac < 0n ? -this.#frac : this.#frac;

		if (this.#scale === 0) {
			return `${sign}${absInt}`;
		}

		// Convert frac to string and pad it to match the scale
		let fracStr = absFrac.toString().padStart(this.#scale, "0");

		// Trim trailing zeros without regex (avoids ReDoS)
		let end = fracStr.length;
		while (end > 0 && fracStr.charCodeAt(end - 1) === 48) {
			// 48 === '0'
			end--;
		}
		fracStr = fracStr.slice(0, end);

		return fracStr === "" ? `${sign}${absInt}` : `${sign}${absInt}.${fracStr}`;
	}

	/**
	 * Serializes the Decimal to JSON string format.
	 * @returns String form.
	 */
	toJSON(): string {
		return this.toString();
	}

	/**
	 * Checks equality between this and another Decimal.
	 * @param other - Another Decimal to compare against.
	 * @returns True if numerically equal.
	 */
	equals(other: unknown): boolean {
		if (!(other instanceof Decimal)) return false;
		const a = this.toBigIntWithScale();
		const b = other.toBigIntWithScale();
		const scale = Math.max(a.scale, b.scale);
		const aVal = a.value * 10n ** BigInt(scale - a.scale);
		const bVal = b.value * 10n ** BigInt(scale - b.scale);
		return aVal === bVal;
	}

	/**
	 * Adds another Decimal to this one.
	 * @param other - The Decimal to add.
	 * @returns A new Decimal representing the sum.
	 */
	add(other: Decimal): Decimal {
		const a = this.toBigIntWithScale();
		const b = other.toBigIntWithScale();
		const scale = Math.max(a.scale, b.scale);
		const scaleDiffA = BigInt(scale - a.scale);
		const scaleDiffB = BigInt(scale - b.scale);
		const valA = a.value * 10n ** scaleDiffA;
		const valB = b.value * 10n ** scaleDiffB;
		const sum = valA + valB;
		const intPart = sum / 10n ** BigInt(scale);
		const fracPart = sum % 10n ** BigInt(scale);
		return new Decimal([intPart, fracPart, scale]);
	}

	/**
	 * Subtracts another Decimal from this one.
	 * @param other - The Decimal to subtract.
	 * @returns A new Decimal representing the difference.
	 */
	sub(other: Decimal): Decimal {
		const a = this.toBigIntWithScale();
		const b = other.toBigIntWithScale();
		const scale = Math.max(a.scale, b.scale);
		const factorA = 10n ** BigInt(scale - a.scale);
		const factorB = 10n ** BigInt(scale - b.scale);
		const valA = a.value * factorA;
		const valB = b.value * factorB;
		const result = valA - valB;
		const intPart = result / 10n ** BigInt(scale);
		const fracPart = result % 10n ** BigInt(scale);
		return new Decimal([intPart, fracPart, scale]);
	}

	/**
	 * Multiplies this Decimal by another.
	 * @param other - The Decimal to multiply by.
	 * @returns A new Decimal representing the product.
	 */
	mul(other: Decimal): Decimal {
		const a = this.toBigIntWithScale();
		const b = other.toBigIntWithScale();
		const result = a.value * b.value;
		const scale = a.scale + b.scale;
		const intPart = result / 10n ** BigInt(scale);
		const fracPart = result % 10n ** BigInt(scale);
		return new Decimal([intPart, fracPart, scale]);
	}

	/**
	 * Divides this Decimal by another, with fixed precision.
	 * @param other - The Decimal to divide by.
	 * @returns A new Decimal representing the quotient.
	 */
	div(other: Decimal): Decimal {
		const a = this.toBigIntWithScale();
		const b = other.toBigIntWithScale();
		if (b.value === 0n) throw new Error("Division by zero");
		const targetScale = 38;
		const scaleDiff = BigInt(targetScale + b.scale - a.scale);
		const scaledA = a.value * 10n ** scaleDiff;
		const result = scaledA / b.value;
		const intPart = result / 10n ** BigInt(targetScale);
		const fracPart = result % 10n ** BigInt(targetScale);
		return new Decimal([intPart, fracPart, targetScale]);
	}

	/**
	 * Computes the remainder of this Decimal divided by another.
	 * @param other - The divisor Decimal.
	 * @returns A new Decimal representing the remainder.
	 */
	mod(other: Decimal): Decimal {
		const a = this.toBigIntWithScale();
		const b = other.toBigIntWithScale();

		if (b.value === 0n) throw new Error("Modulo by zero");

		const scale = Math.max(a.scale, b.scale);
		const scaleDiffA = BigInt(scale - a.scale);
		const scaleDiffB = BigInt(scale - b.scale);

		const valA = a.value * 10n ** scaleDiffA;
		const valB = b.value * 10n ** scaleDiffB;

		const result = valA % valB;
		const intPart = result / 10n ** BigInt(scale);
		const fracPart = result % 10n ** BigInt(scale);

		return new Decimal([intPart, fracPart, scale]);
	}

	/**
	 * Returns the absolute value of this Decimal.
	 * @returns A new Decimal with non-negative components.
	 */
	abs(): Decimal {
		return this.#int < 0n || this.#frac < 0n
			? new Decimal([
					this.#int < 0n ? -this.#int : this.#int,
					this.#frac < 0n ? -this.#frac : this.#frac,
					this.#scale,
				])
			: this;
	}

	/**
	 * Returns the negated value of this Decimal.
	 * @returns A new Decimal with inverted sign.
	 */
	neg(): Decimal {
		return new Decimal([-this.#int, -this.#frac, this.#scale]);
	}

	/**
	 * Checks if the value is exactly zero.
	 * @returns True if both int and frac parts are zero.
	 */
	isZero(): boolean {
		return this.#int === 0n && this.#frac === 0n;
	}

	/**
	 * Checks if the value is negative.
	 * @returns True if negative.
	 */
	isNegative(): boolean {
		return this.#int < 0n || (this.#int === 0n && this.#frac < 0n);
	}

	/**
	 * Compares this Decimal with another.
	 * @param other - The Decimal to compare with.
	 * @returns -1 if less, 0 if equal, 1 if greater.
	 */
	compare(other: Decimal): number {
		const a = this.toBigIntWithScale();
		const b = other.toBigIntWithScale();
		const scale = Math.max(a.scale, b.scale);
		const aVal = a.value * 10n ** BigInt(scale - a.scale);
		const bVal = b.value * 10n ** BigInt(scale - b.scale);
		if (aVal < bVal) return -1;
		if (aVal > bVal) return 1;
		return 0;
	}

	/**
	 * Rounds the Decimal to a fixed number of decimal places.
	 * @param precision - Number of digits to keep after the decimal point.
	 * @returns A new rounded Decimal.
	 */
	round(precision: number): Decimal {
		if (precision < 0) throw new Error("Precision must be >= 0");

		const full = this.toBigIntWithScale();

		// If current scale is already less than or equal to target precision
		if (this.#scale <= precision) {
			const factor = 10n ** BigInt(precision - this.#scale);
			const newValue = full.value * factor;
			const intPart = newValue / 10n ** BigInt(precision);
			const fracPart = newValue % 10n ** BigInt(precision);
			return new Decimal([intPart, fracPart, precision]);
		}

		// Round by removing digits past target precision
		const factor = 10n ** BigInt(this.#scale - precision);
		const half = factor / 2n;
		const rounded =
			full.value >= 0n
				? (full.value + half) / factor
				: (full.value - half) / factor;
		const intPart = rounded / 10n ** BigInt(precision);
		const fracPart = rounded % 10n ** BigInt(precision);
		return new Decimal([intPart, fracPart, precision]);
	}

	/**
	 * Converts the number to fixed-point notation string.
	 * @param precision - Number of digits after the decimal point.
	 * @returns A string representation with fixed decimals.
	 */
	toFixed(precision: number): string {
		const rounded = this.round(precision);
		const sign = rounded.int < 0n || rounded.frac < 0n ? "-" : "";
		const absInt = rounded.int < 0n ? -rounded.int : rounded.int;

		if (precision === 0) {
			return `${sign}${absInt}`;
		}

		const absFrac = rounded.frac < 0n ? -rounded.frac : rounded.frac;
		const fracStr = absFrac.toString().padStart(precision, "0");
		return `${sign}${absInt}.${fracStr}`;
	}

	/**
	 * Converts the Decimal to a native JavaScript number.
	 * @returns A number approximation (may lose precision).
	 */
	toFloat(): number {
		return Number(this.toString());
	}

	/**
	 * Converts to bigint by truncating the fractional part.
	 * @returns An integer approximation.
	 */
	toBigInt(): bigint {
		if (this.#int >= 0n) return this.#int;
		if (this.#frac !== 0n) return this.#int - 1n;
		return this.#int;
	}

	/**
	 * Returns the raw parts of the Decimal.
	 * @returns An object with int, frac, and scale.
	 */
	toParts(): { int: bigint; frac: bigint; scale: number } {
		return {
			int: this.#int,
			frac: this.#frac,
			scale: this.#scale,
		};
	}

	/**
	 * Converts to scientific notation string (e.g., "1.23e4").
	 * @returns Scientific string representation.
	 */
	toScientific(): string {
		if (this.isZero()) return "0e0";

		const negative = this.isNegative();
		const abs = negative ? this.neg() : this;
		const str = abs.toString();
		const [intPart, fracPart = ""] = str.split(".");
		const raw = (intPart + fracPart).replace(/^0+/, "");
		const firstSig = raw.search(/[1-9]/);
		if (firstSig === -1) return "0e0";

		let exponent: number;
		if (intPart !== "0") {
			exponent = intPart.length - 1;
		} else {
			let leading = 0;
			while (leading < fracPart.length && fracPart.charCodeAt(leading) === 48)
				leading++;
			exponent = -leading - 1;
		}

		let end = raw.length;
		while (end > 0 && raw.charCodeAt(end - 1) === 48) end--;
		const digits = raw.slice(0, end);
		const mantissa =
			digits.length > 1 ? `${digits[0]}.${digits.slice(1)}` : digits[0];
		return `${negative ? "-" : ""}${mantissa}e${exponent}`;
	}

	/**
	 * Parses a number in scientific notation into a Decimal.
	 * @param input - The scientific notation string.
	 * @returns A Decimal instance.
	 */
	static fromScientificNotation(input: string): Decimal {
		const trimmed = input.trim();

		// Cheap validation: basic format check without overlapping quantifiers
		if (!/^[+-]?\d+(\.\d+)?[eE][+-]?\d+$/.test(trimmed)) {
			throw new Error(`Invalid scientific notation: ${input}`);
		}

		// Safe and predictable manual split
		const [baseStr, expStr] = trimmed.split(/[eE]/);
		const exp = Number.parseInt(expStr, 10);
		const negative = baseStr.startsWith("-");
		const [intPart, fracPart = ""] = baseStr.replace(/^[-+]/, "").split(".");

		const raw = intPart + fracPart;
		let start = 0;
		while (start < raw.length && raw.charCodeAt(start) === 48) start++;
		const digits = raw.slice(start) || "0";

		const pointIndex = intPart.length;
		const newPointIndex = pointIndex + exp;

		let result: string;
		if (newPointIndex <= 0) {
			result = `0.${"0".repeat(-newPointIndex)}${digits}`;
		} else if (newPointIndex >= digits.length) {
			result = digits + "0".repeat(newPointIndex - digits.length);
		} else {
			result = `${digits.slice(0, newPointIndex)}.${digits.slice(newPointIndex)}`;
		}

		return new Decimal(negative ? `-${result}` : result);
	}

	private toBigIntWithScale(): { value: bigint; scale: number } {
		return {
			value: this.#int * 10n ** BigInt(this.#scale) + this.#frac,
			scale: this.#scale,
		};
	}
}



================================================
FILE: packages/sdk/src/value/duration.ts
================================================
/**
 * SurrealQL Duration class supporting nanosecond precision.
 * Represents a time span, serializable and compatible with arithmetic operations.
 */
import { SurrealError } from "../errors";
import { Value } from "./value";

// Time unit definitions in nanoseconds
const NANOSECOND = 1n;
const MICROSECOND = 1000n * NANOSECOND;
const MILLISECOND = 1000n * MICROSECOND;
const SECOND = 1000n * MILLISECOND;
const MINUTE = 60n * SECOND;
const HOUR = 60n * MINUTE;
const DAY = 24n * HOUR;
const WEEK = 7n * DAY;

// Unit string to nanosecond mapping
const units = new Map([
	["ns", NANOSECOND],
	["\u00b5s", MICROSECOND], // micro (Greek letter mu)
	["\u03bcs", MICROSECOND], // micro (Greek letter mu variant)
	["us", MICROSECOND], // ASCII fallback
	["ms", MILLISECOND],
	["s", SECOND],
	["m", MINUTE],
	["h", HOUR],
	["d", DAY],
	["w", WEEK],
]);

// Reverse map: nanoseconds to unit string
const unitsReverse = Array.from(units).reduce((map, [unit, size]) => {
	map.set(size, unit);
	return map;
}, new Map<bigint, string>());

// Regex for parsing duration parts like "3h" or "15ms"
const escapeRegex = (str: string) =>
	str.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");

const durationPartRegex = new RegExp(
	`^(\\d+)(${Array.from(units.keys()).map(escapeRegex).join("|")})`,
);

/**
 * A high-precision duration class supporting parsing, formatting, and arithmetic.
 */
export class Duration extends Value {
	readonly #seconds: bigint;
	readonly #nanoseconds: bigint;

	/**
	 * Constructs a new Duration.
	 * @param {Duration | [number|bigint, number|bigint] | string} input - Duration input
	 */
	constructor(input: Duration | [number | bigint, number | bigint] | string) {
		super();

		if (input instanceof Duration) {
			// Clone from existing duration
			this.#seconds = input.#seconds;
			this.#nanoseconds = input.#nanoseconds;
		} else if (typeof input === "string") {
			// Parse from a human-readable string like "1h30m"
			const [s, ns] = Duration.parseString(input);
			this.#seconds = s;
			this.#nanoseconds = ns;
		} else {
			// Construct from tuple [seconds, nanoseconds]
			const s =
				typeof input[0] === "bigint"
					? input[0]
					: BigInt(Math.floor(input[0] ?? 0));

			const ns =
				typeof input[1] === "bigint"
					? input[1]
					: BigInt(Math.floor(input[1] ?? 0));

			const total = s * SECOND + ns;
			// Normalize total into separate seconds and nanoseconds fields
			this.#seconds = total / SECOND;
			this.#nanoseconds = total % SECOND;
		}
	}

	/**
	 * Creates a duration from a compact array form.
	 * @param {[number|bigint, number|bigint] | [number|bigint] | []} param0 - Tuple input
	 * @returns {Duration} New duration
	 */
	static fromCompact([s, ns]:
		| [number | bigint, number | bigint]
		| [number | bigint]
		| []): Duration {
		return new Duration([s ?? 0n, ns ?? 0n]);
	}

	/**
	 * Compares two durations.
	 * @param {unknown} other - Another value
	 * @returns {boolean} True if equal
	 */
	equals(other: unknown): boolean {
		if (!(other instanceof Duration)) return false;
		return (
			this.#seconds === other.#seconds &&
			this.#nanoseconds === other.#nanoseconds
		);
	}

	/**
	 * Converts the duration to a tuple.
	 * @returns {[bigint, bigint] | [bigint] | []} Compact form
	 */
	toCompact(): [bigint, bigint] | [bigint] | [] {
		return this.#nanoseconds > 0n
			? [this.#seconds, this.#nanoseconds]
			: this.#seconds > 0n
				? [this.#seconds]
				: [];
	}

	/**
	 * Formats the duration as a human-readable string.
	 * @returns {string} Duration string
	 */
	toString(): string {
		let remainingSeconds = this.#seconds;
		let result = "";

		// Convert seconds into largest possible whole units (≥ 1s)
		for (const [size, unit] of Array.from(unitsReverse).reverse()) {
			if (size >= SECOND) {
				const amount = remainingSeconds / (size / SECOND);
				if (amount > 0n) {
					remainingSeconds %= size / SECOND;
					result += `${amount}${unit}`;
				}
			}
		}

		// Convert remaining seconds to nanoseconds
		let remainingNanoseconds = remainingSeconds * SECOND + this.#nanoseconds;

		// Convert sub-second nanoseconds to units < 1s
		for (const [size, unit] of Array.from(unitsReverse).reverse()) {
			if (size < SECOND) {
				const amount = remainingNanoseconds / size;
				if (amount > 0n) {
					remainingNanoseconds %= size;
					result += `${amount}${unit}`;
				}
			}
		}

		return result;
	}

	/**
	 * Serializes duration to a JSON string.
	 * @returns {string}
	 */
	toJSON(): string {
		return this.toString();
	}

	/**
	 * Parses a duration string like "1h30m".
	 * @param {string} input - Input string
	 * @returns {[bigint, bigint]} [seconds, nanoseconds]
	 */
	static parseString(input: string): [bigint, bigint] {
		let seconds = 0n;
		let nanoseconds = 0n;
		let left = input;

		// Loop through string and extract valid duration parts
		while (left !== "") {
			const match = left.match(durationPartRegex);
			if (match) {
				const amount = BigInt(match[1]);
				const unit = match[2];
				const factor = units.get(unit);
				if (!factor) throw new SurrealError(`Invalid duration unit: ${unit}`);

				if (factor >= SECOND) {
					// Accumulate seconds
					seconds += amount * (factor / SECOND);
				} else {
					// Accumulate nanoseconds
					nanoseconds += amount * factor;
				}

				// Slice the processed segment off
				left = left.slice(match[0].length);
			} else {
				throw new SurrealError("Could not match a next duration part");
			}
		}

		// Normalize: convert overflow nanoseconds to seconds
		seconds += nanoseconds / SECOND;
		nanoseconds %= SECOND;
		return [seconds, nanoseconds];
	}

	/**
	 * Adds two durations together.
	 * @param {Duration} other - The duration to add
	 * @returns {Duration} The resulting duration
	 */
	add(other: Duration): Duration {
		let sec = this.#seconds + other.#seconds;
		let ns = this.#nanoseconds + other.#nanoseconds;
		if (ns >= SECOND) {
			sec += 1n;
			ns -= SECOND;
		}
		return new Duration([sec, ns]);
	}

	/**
	 * Subtracts another duration from this one.
	 * @param {Duration} other - The duration to subtract
	 * @returns {Duration} The resulting duration
	 */
	sub(other: Duration): Duration {
		let sec = this.#seconds - other.#seconds;
		let ns = this.#nanoseconds - other.#nanoseconds;
		if (ns < 0n) {
			sec -= 1n;
			ns += SECOND;
		}
		return new Duration([sec, ns]);
	}

	/**
	 * Multiplies the duration by a scalar.
	 * @param {number | bigint} factor - The factor to multiply by
	 * @returns {Duration} The resulting duration
	 */
	mul(factor: number | bigint): Duration {
		const factorBig =
			typeof factor === "bigint" ? factor : BigInt(Math.floor(factor));
		const totalNs = this.#seconds * SECOND + this.#nanoseconds;
		const resultNs = totalNs * factorBig;
		return new Duration([resultNs / SECOND, resultNs % SECOND]);
	}

	/**
	 * Divides the duration.
	 * @param {Duration | number | bigint} divisor - The duration or scalar to divide by
	 * @returns {Duration | bigint} A new Duration or ratio (unitless bigint)
	 */
	div(divisor: Duration): bigint;
	div(divisor: number | bigint): Duration;
	div(divisor: number | bigint | Duration): bigint | Duration {
		if (typeof divisor === "object" && divisor instanceof Duration) {
			const a = this.#seconds * SECOND + this.#nanoseconds;
			const b = divisor.#seconds * SECOND + divisor.#nanoseconds;
			if (b === 0n) throw new SurrealError("Division by zero duration");
			return a / b;
		}
		const divisorBig =
			typeof divisor === "bigint" ? divisor : BigInt(Math.floor(divisor));
		if (divisorBig === 0n) throw new SurrealError("Division by zero");
		const totalNs = this.#seconds * SECOND + this.#nanoseconds;
		const resultNs = totalNs / divisorBig;
		return new Duration([resultNs / SECOND, resultNs % SECOND]);
	}

	/**
	 * Computes the remainder after division.
	 * @param {Duration} mod - The divisor
	 * @returns {Duration} The remainder duration
	 */
	mod(mod: Duration): Duration {
		const a = this.#seconds * SECOND + this.#nanoseconds;
		const b = mod.#seconds * SECOND + mod.#nanoseconds;
		if (b === 0n) throw new SurrealError("Modulo by zero duration");
		const resultNs = a % b;
		return new Duration([resultNs / SECOND, resultNs % SECOND]);
	}

	/**
	 * @returns {bigint} Total nanoseconds in this duration
	 */
	get nanoseconds(): bigint {
		return this.#seconds * SECOND + this.#nanoseconds;
	}

	/**
	 * @returns {bigint} Total microseconds
	 */
	get microseconds(): bigint {
		return this.nanoseconds / MICROSECOND;
	}

	/**
	 * @returns {bigint} Total milliseconds
	 */
	get milliseconds(): bigint {
		return this.nanoseconds / MILLISECOND;
	}

	/**
	 * @returns {bigint} Whole seconds in the duration
	 */
	get seconds(): bigint {
		return this.#seconds;
	}

	/**
	 * @returns {bigint} Total whole minutes in the duration
	 */
	get minutes(): bigint {
		return this.#seconds / (MINUTE / SECOND);
	}

	/**
	 * @returns {bigint} Total whole hours in the duration
	 */
	get hours(): bigint {
		return this.#seconds / (HOUR / SECOND);
	}

	/**
	 * @returns {bigint} Total whole days in the duration
	 */
	get days(): bigint {
		return this.#seconds / (DAY / SECOND);
	}

	/**
	 * @returns {bigint} Total whole weeks in the duration
	 */
	get weeks(): bigint {
		return this.#seconds / (WEEK / SECOND);
	}

	/**
	 * Creates a Duration from nanoseconds.
	 * @param {number | bigint} ns - Nanoseconds value
	 * @returns {Duration} The resulting duration
	 */
	static nanoseconds(ns: number | bigint): Duration {
		const n = typeof ns === "bigint" ? ns : BigInt(Math.floor(ns));
		return new Duration([n / SECOND, n % SECOND]);
	}

	/**
	 * Creates a Duration from microseconds.
	 * @param {number | bigint} µs - Microseconds value
	 * @returns {Duration} The resulting duration
	 */
	static microseconds(µs: numbe| bigint): Duration {
		const n = typeof µs === "bigint" ? µs : BigInt(Math.floor(µs));
		return Duration.nanoseconds(n * MICROSECOND);
	}

	/**
	 * Creates a Duration from milliseconds.
	 * @param {number | bigint} ms - Milliseconds value
	 * @returns {Duration} The resulting duration
	 */
	static milliseconds(ms: number | bigint): Duration {
		const n = typeof ms === "bigint" ? ms : BigInt(Math.floor(ms));
		return Duration.nanoseconds(n * MILLISECOND);
	}

	/**
	 * Creates a Duration from seconds.
	 * @param {number | bigint} s - Seconds value
	 * @returns {Duration} The resulting duration
	 */
	static seconds(s: number | bigint): Duration {
		const n = typeof s === "bigint" ? s : BigInt(Math.floor(s));
		return new Duration([n, 0n]);
	}

	/**
	 * Creates a Duration from minutes.
	 * @param {number | bigint} m - Minutes value
	 * @returns {Duration} The resulting duration
	 */
	static minutes(m: number | bigint): Duration {
		const n = typeof m === "bigint" ? m : BigInt(Math.floor(m));
		return new Duration([n * (MINUTE / SECOND), 0n]);
	}

	/**
	 * Creates a Duration from hours.
	 * @param {number | bigint} h - Hours value
	 * @returns {Duration} The resulting duration
	 */
	static hours(h: number | bigint): Duration {
		const n = typeof h === "bigint" ? h : BigInt(Math.floor(h));
		return new Duration([n * (HOUR / SECOND), 0n]);
	}

	/**
	 * Creates a Duration from days.
	 * @param {number | bigint} d - Days value
	 * @returns {Duration} The resulting duration
	 */
	static days(d: number | bigint): Duration {
		const n = typeof d === "bigint" ? d : BigInt(Math.floor(d));
		return new Duration([n * (DAY / SECOND), 0n]);
	}

	/**
	 * Creates a Duration from weeks.
	 * @param {number | bigint} w - Weeks value
	 * @returns {Duration} The resulting duration
	 */
	static weeks(w: number | bigint): Duration {
		const n = typeof w === "bigint" ? w : BigInt(Math.floor(w));
		return new Duration([n * (WEEK / SECOND), 0n]);
	}
}



================================================
FILE: packages/sdk/src/value/future.ts
================================================
import { Value } from "./value";

/**
 * An uncomputed SurrealQL future value.
 */
export class Future extends Value {
	public readonly inner: string;

	constructor(inner: string) {
		super();
		this.inner = inner;
	}

	equals(other: unknown): boolean {
		if (!(other instanceof Future)) return false;
		return this.inner === other.inner;
	}

	toJSON(): string {
		return this.toString();
	}

	toString(): string {
		return `<future> ${this.inner}`;
	}
}



================================================
FILE: packages/sdk/src/value/geometry.ts
================================================
import { Decimal } from "./decimal.ts";
import { Value } from "./value.ts";

/**
 * A SurrealQL geometry value.
 */
export abstract class Geometry extends Value {
	abstract toJSON(): GeoJson;
	abstract is(geometry: Geometry): boolean;
	abstract clone(): Geometry;

	equals(other: unknown): boolean {
		if (!(other instanceof Geometry)) return false;
		return this.is(other);
	}

	toString(): string {
		return JSON.stringify(this.toJSON());
	}
}

function f(num: number | Decimal) {
	if (num instanceof Decimal) return num.toFloat();
	return num;
}

/**
 * A SurrealQL point geometry value.
 */
export class GeometryPoint extends Geometry {
	readonly point: [number, number];

	constructor(point: [number | Decimal, number | Decimal] | GeometryPoint) {
		super();
		if (point instanceof GeometryPoint) {
			this.point = point.clone().point;
		} else {
			this.point = [f(point[0]), f(point[1])];
		}
	}

	toJSON(): GeoJsonPoint {
		return {
			type: "Point" as const,
			coordinates: this.coordinates,
		};
	}

	get coordinates(): GeoJsonPoint["coordinates"] {
		return this.point;
	}

	is(geometry: Geometry): geometry is GeometryPoint {
		if (!(geometry instanceof GeometryPoint)) return false;
		return (
			this.point[0] === geometry.point[0] && this.point[1] === geometry.point[1]
		);
	}

	clone(): GeometryPoint {
		return new GeometryPoint([...this.point]);
	}
}

/**
 * A SurrealQL line geometry value.
 */
export class GeometryLine extends Geometry {
	readonly line: [GeometryPoint, GeometryPoint, ...GeometryPoint[]];

	// SurrealDB only has the concept of a "Line", which by spec is two points.
	// SurrealDB's "Line" however, is actually a "LineString" under the hood, which accepts two or more points
	constructor(
		line: [GeometryPoint, GeometryPoint, ...GeometryPoint[]] | GeometryLine,
	) {
		super();
		this.line = line instanceof GeometryLine ? line.clone().line : line;
	}

	toJSON(): GeoJsonLineString {
		return {
			type: "LineString" as const,
			coordinates: this.coordinates,
		};
	}

	get coordinates(): GeoJsonLineString["coordinates"] {
		return this.line.map(
			(g) => g.coordinates,
		) as GeoJsonLineString["coordinates"];
	}

	close(): void {
		if (!this.line[0].is(this.line.at(-1) as GeometryPoint)) {
			this.line.push(this.line[0]);
		}
	}

	is(geometry: Geometry): geometry is GeometryLine {
		if (!(geometry instanceof GeometryLine)) return false;
		if (this.line.length !== geometry.line.length) return false;
		for (let i = 0; i < this.line.length; i++) {
			if (!this.line[i].is(geometry.line[i])) return false;
		}

		return true;
	}

	clone(): GeometryLine {
		return new GeometryLine(
			this.line.map((p) => p.clone()) as [
				GeometryPoint,
				GeometryPoint,
				...GeometryPoint[],
			],
		);
	}
}

/**
 * A SurrealQL polygon geometry value.
 */
export class GeometryPolygon extends Geometry {
	readonly polygon: [GeometryLine, ...GeometryLine[]];

	constructor(polygon: [GeometryLine, ...GeometryLine[]] | GeometryPolygon) {
		super();
		this.polygon =
			polygon instanceof GeometryPolygon
				? polygon.clone().polygon
				: (polygon.map((l) => {
						const line = l.clone();
						line.close();
						return line;
					}) as [GeometryLine, ...GeometryLine[]]);
	}

	toJSON(): GeoJsonPolygon {
		return {
			type: "Polygon" as const,
			coordinates: this.coordinates,
		};
	}

	get coordinates(): GeoJsonPolygon["coordinates"] {
		return this.polygon.map(
			(g) => g.coordinates,
		) as GeoJsonPolygon["coordinates"];
	}

	is(geometry: Geometry): geometry is GeometryPolygon {
		if (!(geometry instanceof GeometryPolygon)) return false;
		if (this.polygon.length !== geometry.polygon.length) return false;
		for (let i = 0; i < this.polygon.length; i++) {
			if (!this.polygon[i].is(geometry.polygon[i])) return false;
		}

		return true;
	}

	clone(): GeometryPolygon {
		return new GeometryPolygon(
			this.polygon.map((p) => p.clone()) as [GeometryLine, ...GeometryLine[]],
		);
	}
}

/**
 * A SurrealQL multi-point geometry value.
 */
export class GeometryMultiPoint extends Geometry {
	readonly points: [GeometryPoint, ...GeometryPoint[]];

	constructor(
		points: [GeometryPoint, ...GeometryPoint[]] | GeometryMultiPoint,
	) {
		super();
		this.points = points instanceof GeometryMultiPoint ? points.points : points;
	}

	toJSON(): GeoJsonMultiPoint {
		return {
			type: "MultiPoint" as const,
			coordinates: this.coordinates,
		};
	}

	get coordinates(): GeoJsonMultiPoint["coordinates"] {
		return this.points.map(
			(g) => g.coordinates,
		) as GeoJsonMultiPoint["coordinates"];
	}

	is(geometry: Geometry): geometry is GeometryMultiPoint {
		if (!(geometry instanceof GeometryMultiPoint)) return false;
		if (this.points.length !== geometry.points.length) return false;
		for (let i = 0; i < this.points.length; i++) {
			if (!this.points[i].is(geometry.points[i])) return false;
		}

		return true;
	}

	clone(): GeometryMultiPoint {
		return new GeometryMultiPoint(
			this.points.map((p) => p.clone()) as [GeometryPoint, ...GeometryPoint[]],
		);
	}
}

/**
 * A SurrealQL multi-line geometry value.
 */
export class GeometryMultiLine extends Geometry {
	readonly lines: [GeometryLine, ...GeometryLine[]];

	constructor(lines: [GeometryLine, ...GeometryLine[]] | GeometryMultiLine) {
		super();
		this.lines = lines instanceof GeometryMultiLine ? lines.lines : lines;
	}

	toJSON(): GeoJsonMultiLineString {
		return {
			type: "MultiLineString" as const,
			coordinates: this.coordinates,
		};
	}

	get coordinates(): GeoJsonMultiLineString["coordinates"] {
		return this.lines.map(
			(g) => g.coordinates,
		) as GeoJsonMultiLineString["coordinates"];
	}

	is(geometry: Geometry): geometry is GeometryMultiLine {
		if (!(geometry instanceof GeometryMultiLine)) return false;
		if (this.lines.length !== geometry.lines.length) return false;
		for (let i = 0; i < this.lines.length; i++) {
			if (!this.lines[i].is(geometry.lines[i])) return false;
		}

		return true;
	}

	clone(): GeometryMultiLine {
		return new GeometryMultiLine(
			this.lines.map((p) => p.clone()) as [GeometryLine, ...GeometryLine[]],
		);
	}
}

/**
 * A SurrealQL multi-polygon geometry value.
 */
export class GeometryMultiPolygon extends Geometry {
	readonly polygons: [GeometryPolygon, ...GeometryPolygon[]];

	constructor(
		polygons: [GeometryPolygon, ...GeometryPolygon[]] | GeometryMultiPolygon,
	) {
		super();
		this.polygons =
			polygons instanceof GeometryMultiPolygon ? polygons.polygons : polygons;
	}

	toJSON(): GeoJsonMultiPolygon {
		return {
			type: "MultiPolygon" as const,
			coordinates: this.coordinates,
		};
	}

	get coordinates(): GeoJsonMultiPolygon["coordinates"] {
		return this.polygons.map(
			(g) => g.coordinates,
		) as GeoJsonMultiPolygon["coordinates"];
	}

	is(geometry: Geometry): geometry is GeometryMultiPolygon {
		if (!(geometry instanceof GeometryMultiPolygon)) return false;
		if (this.polygons.length !== geometry.polygons.length) return false;
		for (let i = 0; i < this.polygons.length; i++) {
			if (!this.polygons[i].is(geometry.polygons[i])) return false;
		}

		return true;
	}

	clone(): GeometryMultiPolygon {
		return new GeometryMultiPolygon(
			this.polygons.map((p) => p.clone()) as [
				GeometryPolygon,
				...GeometryPolygon[],
			],
		);
	}
}

/**
 * A SurrealQL geometry collection value.
 */
export class GeometryCollection extends Geometry {
	readonly collection: [Geometry, ...Geometry[]];

	constructor(collection: [Geometry, ...Geometry[]] | GeometryCollection) {
		super();
		this.collection =
			collection instanceof GeometryCollection
				? collection.collection
				: collection;
	}

	toJSON(): GeoJsonCollection {
		return {
			type: "GeometryCollection" as const,
			geometries: this.geometries,
		};
	}

	get geometries(): GeoJsonCollection["geometries"] {
		return this.collection.map((g) =>
			g.toJSON(),
		) as GeoJsonCollection["geometries"];
	}

	is(geometry: Geometry): geometry is GeometryCollection {
		if (!(geometry instanceof GeometryCollection)) return false;
		if (this.collection.length !== geometry.collection.length) return false;
		for (let i = 0; i < this.collection.length; i++) {
			if (!this.collection[i].is(geometry.collection[i])) return false;
		}

		return true;
	}

	clone(): GeometryCollection {
		return new GeometryCollection(
			this.collection.map((p) => p.clone()) as [Geometry, ...Geometry[]],
		);
	}
}

// Geo Json Types

type GeoJson =
	| GeoJsonPoint
	| GeoJsonLineString
	| GeoJsonPolygon
	| GeoJsonMultiPoint
	| GeoJsonMultiLineString
	| GeoJsonMultiPolygon
	| GeoJsonCollection;

export type GeoJsonPoint = {
	type: "Point";
	coordinates: [number, number];
};

export type GeoJsonLineString = {
	type: "LineString";
	coordinates: [
		GeoJsonPoint["coordinates"],
		GeoJsonPoint["coordinates"],
		...GeoJsonPoint["coordinates"][],
	];
};

export type GeoJsonPolygon = {
	type: "Polygon";
	coordinates: [
		GeoJsonLineString["coordinates"],
		...GeoJsonLineString["coordinates"][],
	];
};

export type GeoJsonMultiPoint = {
	type: "MultiPoint";
	coordinates: [GeoJsonPoint["coordinates"], ...GeoJsonPoint["coordinates"][]];
};

export type GeoJsonMultiLineString = {
	type: "MultiLineString";
	coordinates: [
		GeoJsonLineString["coordinates"],
		...GeoJsonLineString["coordinates"][],
	];
};

export type GeoJsonMultiPolygon = {
	type: "MultiPolygon";
	coordinates: [
		GeoJsonPolygon["coordinates"],
		...GeoJsonPolygon["coordinates"][],
	];
};

export type GeoJsonCollection = {
	type: "GeometryCollection";
	geometries: GeoJson[];
};



================================================
FILE: packages/sdk/src/value/index.ts
================================================
export {
	Geometry,
	GeometryCollection,
	GeometryLine,
	GeometryMultiLine,
	GeometryMultiPoint,
	GeometryMultiPolygon,
	GeometryPoint,
	GeometryPolygon,
} from "./geometry.ts";

export { RecordId, type RecordIdValue } from "./record-id.ts";
export { RecordIdRange } from "./record-id-range.ts";
export { Range } from "./range.ts";
export { StringRecordId } from "./string-record-id.ts";
export { Future } from "./future.ts";
export { Uuid } from "./uuid.ts";
export { Duration } from "./duration.ts";
export { Decimal } from "./decimal.ts";
export { Table } from "./table.ts";



================================================
FILE: packages/sdk/src/value/range.ts
================================================
import { getRangeJoin } from "../internal/range";
import { equals } from "../utils/equals";
import { escapeRangeBound } from "../utils/escape";
import type { Bound } from "../utils/range";
import { Value } from "./value";

/**
 * A SurrealQL range value.
 */
export class Range<Beg, End> extends Value {
	public readonly beg: Bound<Beg>;
	public readonly end: Bound<End>;

	constructor(beg: Bound<Beg>, end: Bound<End>) {
		super();
		this.beg = beg;
		this.end = end;
	}

	equals(other: unknown): boolean {
		if (!(other instanceof Range)) return false;
		if (this.beg?.constructor !== other.beg?.constructor) return false;
		if (this.end?.constructor !== other.end?.constructor) return false;

		return (
			equals(this.beg?.value, other.beg?.value) &&
			equals(this.end?.value, other.end?.value)
		);
	}

	toJSON(): string {
		return this.toString();
	}

	toString(): string {
		const beg = escapeRangeBound(this.beg);
		const end = escapeRangeBound(this.end);
		return `${beg}${getRangeJoin(this.beg, this.end)}${end}`;
	}
}



================================================
FILE: packages/sdk/src/value/record-id-range.ts
================================================
import { SurrealError } from "../errors";
import { getRangeJoin } from "../internal/range";
import { isValidIdBound, isValidTable } from "../internal/validation";
import { equals } from "../utils/equals";
import { escapeIdent, escapeRangeBound } from "../utils/escape";
import type { Bound } from "../utils/range";
import type { RecordIdValue } from "./record-id";
import { Table } from "./table";
import { Value } from "./value";

/**
 * A SurrealQL record ID range value.
 */
export class RecordIdRange<Tb extends string = string> extends Value {
	public readonly table: Table<Tb>;
	public readonly beg: Bound<RecordIdValue>;
	public readonly end: Bound<RecordIdValue>;

	constructor(
		table: Tb | Table<Tb>,
		beg: Bound<RecordIdValue>,
		end: Bound<RecordIdValue>,
	) {
		super();

		if (!isValidTable(table)) throw new SurrealError("tb part is not valid");
		if (!isValidIdBound(beg)) throw new SurrealError("Begin part is not valid");
		if (!isValidIdBound(end)) throw new SurrealError("End part is not valid");

		this.table = table instanceof Table ? table : new Table(table);
		this.beg = beg;
		this.end = end;
	}

	equals(other: unknown): boolean {
		if (!(other instanceof RecordIdRange)) return false;
		if (this.beg?.constructor !== other.beg?.constructor) return false;
		if (this.end?.constructor !== other.end?.constructor) return false;

		return (
			this.table.equals(other.table) &&
			equals(this.beg?.value, other.beg?.value) &&
			equals(this.end?.value, other.end?.value)
		);
	}

	toJSON(): string {
		return this.toString();
	}

	toString(): string {
		const tb = escapeIdent(this.table.name);
		const beg = escapeRangeBound(this.beg);
		const end = escapeRangeBound(this.end);
		return `${tb}:${beg}${getRangeJoin(this.beg, this.end)}${end}`;
	}
}



================================================
FILE: packages/sdk/src/value/record-id.ts
================================================
import { SurrealError } from "../errors";
import { isValidIdPart, isValidTable } from "../internal/validation";
import { equals } from "../utils/equals";
import { escapeIdPart, escapeIdent } from "../utils/escape";
import { Table } from "./table";
import type { Uuid } from "./uuid";
import { Value } from "./value";

export type RecordIdValue =
	| string
	| number
	| Uuid
	| bigint
	| unknown[]
	| Record<string, unknown>;

/**
 * A SurrealQL record ID value.
 */
export class RecordId<Tb extends string = string> extends Value {
	public readonly table: Table<Tb>;
	public readonly id: RecordIdValue;

	constructor(table: Tb | Table<Tb>, id: RecordIdValue) {
		super();

		if (!isValidTable(table)) throw new SurrealError("tb part is not valid");
		if (!isValidIdPart(id)) throw new SurrealError("id part is not valid");

		this.table = table instanceof Table ? table : new Table(table);
		this.id = id;
	}

	equals(other: unknown): boolean {
		if (!(other instanceof RecordId)) return false;
		return this.table.equals(other.table) && equals(this.id, other.id);
	}

	toJSON(): string {
		return this.toString();
	}

	toString(): string {
		const tb = escapeIdent(this.table.name);
		const id = escapeIdPart(this.id);
		return `${tb}:${id}`;
	}
}



================================================
FILE: packages/sdk/src/value/string-record-id.ts
================================================
import { SurrealError } from "../errors";
import { RecordId } from "./record-id";
import { Value } from "./value";

/**
 * A SurrealQL string-represented record ID value.
 */
export class StringRecordId extends Value {
	public readonly rid: string;

	constructor(rid: string | StringRecordId | RecordId) {
		super();

		// In some cases the same method may be used with different data sources
		// this can cause this method to be called with an already instanced class object.
		if (rid instanceof StringRecordId) {
			this.rid = rid.rid;
		} else if (rid instanceof RecordId) {
			this.rid = rid.toString();
		} else if (typeof rid === "string") {
			this.rid = rid;
		} else {
			throw new SurrealError("String Record ID must be a string");
		}
	}

	equals(other: unknown): boolean {
		if (!(other instanceof StringRecordId)) return false;
		return this.rid === other.rid;
	}

	toJSON(): string {
		return this.rid;
	}

	toString(): string {
		return this.rid;
	}
}



================================================
FILE: packages/sdk/src/value/table.ts
================================================
import { SurrealError } from "../errors";
import { escapeIdent } from "../utils";
import { Value } from "./value";

/**
 * A SurrealQL table value.
 */
export class Table<Tb extends string = string> extends Value {
	public readonly name: Tb;

	constructor(tb: Tb) {
		super();
		if (typeof tb !== "string")
			throw new SurrealError("Table must be a string");
		this.name = tb;
	}

	equals(other: unknown): boolean {
		if (!(other instanceof Table)) return false;
		return this.name === other.name;
	}

	toJSON(): string {
		return this.toString();
	}

	toString(): string {
		return escapeIdent(this.name);
	}
}



================================================
FILE: packages/sdk/src/value/uuid.ts
================================================
import { UUID, uuidv4obj, uuidv7obj } from "uuidv7";
import { Value } from "./value";

/**
 * A SurrealQL UUID value.
 */
export class Uuid extends Value {
	private readonly inner: UUID;

	constructor(uuid: string | ArrayBuffer | Uint8Array | Uuid | UUID) {
		super();

		if (uuid instanceof ArrayBuffer) {
			this.inner = UUID.ofInner(new Uint8Array(uuid));
		} else if (uuid instanceof Uint8Array) {
			this.inner = UUID.ofInner(uuid);
		} else if (uuid instanceof Uuid) {
			this.inner = uuid.inner;
		} else if (uuid instanceof UUID) {
			this.inner = uuid;
		} else {
			this.inner = UUID.parse(uuid);
		}
	}

	equals(other: unknown): boolean {
		if (!(other instanceof Uuid)) return false;
		return this.inner.equals(other.inner);
	}

	toString(): string {
		return this.inner.toString();
	}

	toJSON(): string {
		return this.inner.toString();
	}

	toUint8Array(): Uint8Array {
		return this.inner.bytes;
	}

	toBuffer(): ArrayBufferLike {
		return this.inner.bytes.buffer;
	}

	static v4(): Uuid {
		return new Uuid(uuidv4obj());
	}

	static v7(): Uuid {
		return new Uuid(uuidv7obj());
	}
}



================================================
FILE: packages/sdk/src/value/value.ts
================================================
/**
 * A complex SurrealQL value type
 */
export abstract class Value {
	/**
	 * Compare equality with another value.
	 */
	abstract equals(other: unknown): boolean;

	/**
	 * Convert this value to a serializable string
	 */
	abstract toJSON(): unknown;

	/**
	 * Convert this value to a string representation
	 */
	abstract toString(): string;
}



================================================
FILE: packages/tests/import.ts
================================================
export * from "../sdk/src";
export * from "../cbor/src";



================================================
FILE: packages/tests/package.json
================================================
{
	"name": "@surrealdb/tests",
	"version": "0.1.0",
	"type": "module",
	"private": true,
	"scripts": {
		"test": "bun test"
	},
	"dependencies": {
		"@surrealdb/cbor": "workspace:*",
		"surrealdb": "workspace:*",
		"get-port": "^7.1.0"
	}
}



================================================
FILE: packages/tests/tsconfig.json
================================================
{
	"extends": "../../tsconfig.json"
}



================================================
FILE: packages/tests/integration/authentication.test.ts
================================================
import { beforeAll, describe, expect, mock, test } from "bun:test";
import { type AnyAuth, RecordId, ResponseError } from "surrealdb";
import { createAuth, setupServer } from "./__helpers__";

const { createSurreal, createIdleSurreal } = await setupServer();

beforeAll(async () => {
	const surreal = await createSurreal();

	await surreal.query(/* surql */ `
		DEFINE TABLE user PERMISSIONS FOR select WHERE id = $auth;
		DEFINE ACCESS user ON DATABASE TYPE RECORD
			SIGNUP ( CREATE type::thing('user', $id) )
			SIGNIN ( SELECT * FROM type::thing('user', $id) )
			DURATION FOR TOKEN 61s;
	`);

	surreal.close();
});

describe("system auth", async () => {
	const surreal = await createSurreal();

	test("root signin", async () => {
		const res = await surreal.signin(createAuth("root") as AnyAuth);
		expect(typeof res).toBe("string");
	});

	test("invalid credentials", async () => {
		const req = surreal.signin(createAuth("invalid") as AnyAuth);
		expect(req).rejects.toBeInstanceOf(ResponseError);
	});
});

describe("record auth", async () => {
	const surreal = await createSurreal();

	test("record signup", async () => {
		const signup = await surreal.signup({
			access: "user",
			variables: { id: 123 },
		});

		expect(typeof signup).toBe("string");
	});

	test("record signin", async () => {
		const mockHandler = mock(() => {});

		surreal.subscribe("authenticated", mockHandler);

		const signin = await surreal.signin({
			access: "user",
			variables: { id: 123 },
		});

		expect(typeof signin).toBe("string");
		expect(mockHandler).toBeCalledTimes(1);
	});

	test("info", async () => {
		const info = await surreal.info<{ id: RecordId<"user"> }>();
		expect(info).toMatchObject({ id: new RecordId("user", 123) });
	});

	test("invalidate", async () => {
		const mockHandler = mock(() => {});

		surreal.subscribe("invalidated", mockHandler);

		await surreal.invalidate();

		expect(mockHandler).toBeCalledTimes(1);
	});
});

describe("session renewal", async () => {
	const { surreal, connect } = createIdleSurreal({
		auth: "none",
	});

	surreal.subscribe("error", (error) => {
		console.error("SurrealDB error:", error);
	});

	test("disabled", async () => {
		const authenticateHandler = mock(() => {});
		const invalidateHandler = mock(() => {});

		surreal.subscribe("authenticated", authenticateHandler);
		surreal.subscribe("invalidated", invalidateHandler);

		await connect({
			renewAccess: false,
		});

		await surreal.signup({
			access: "user",
			variables: { id: 456 },
		});

		// Wait at least 1s for token to renew
		await Bun.sleep(1500);

		// One authentication, one renewal
		expect(authenticateHandler).toHaveBeenCalled();
		expect(invalidateHandler).toHaveBeenCalled();
	});

	test("provider", async () => {
		const authenticateHandler = mock(() => {});
		const invalidateHandler = mock(() => {});

		surreal.subscribe("authenticated", authenticateHandler);
		surreal.subscribe("invalidated", invalidateHandler);

		await connect({
			renewAccess: true,
			authentication: () => ({
				access: "user",
				variables: { id: 456 },
			}),
		});

		// Wait at least 1s for token to renew
		await Bun.sleep(1500);

		// One authentication, one renewal
		expect(authenticateHandler).toHaveBeenCalled();
		expect(invalidateHandler).toHaveBeenCalledTimes(0);
	});

	test("custom", async () => {
		const authenticateHandler = mock(() => {});
		const invalidateHandler = mock(() => {});

		surreal.subscribe("authenticated", authenticateHandler);
		surreal.subscribe("invalidated", invalidateHandler);

		await connect({
			authentication: () => ({
				access: "user",
				variables: { id: 456 },
			}),
			renewAccess: () => ({
				access: "user",
				variables: { id: 456 },
			}),
		});

		// Wait at least 1s for token to renew
		await Bun.sleep(1500);

		// One authentication, one renewal
		expect(authenticateHandler).toHaveBeenCalled();
		expect(invalidateHandler).toBeCalledTimes(0);
	});
});



================================================
FILE: packages/tests/integration/connection.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { VERSION_CHECK, setupServer } from "./__helpers__";

const { createSurreal, createIdleSurreal } = await setupServer();

describe("connection", async () => {
	test.todoIf(!VERSION_CHECK)("check version", async () => {
		const surreal = await createSurreal();

		const res = await surreal.version();
		expect(res.startsWith("surrealdb-")).toBe(true);
	});

	test("allowed rpcs without namespace or database", async () => {
		const surreal = await createSurreal({
			unselected: true,
		});

		await surreal.version();
		await surreal.invalidate();
	});

	test("disallowed rpcs without namespace or database", async () => {
		const surreal = await createSurreal({
			unselected: true,
		});

		expect(async () => {
			await surreal.query("SELECT * FROM test");
		}).toThrow();
	});

	test("access selected namespace and database", async () => {
		const surreal = await createSurreal({
			unselected: true,
		});

		await surreal.use({
			namespace: "test-ns",
			database: "test-db",
		});

		expect(surreal.namespace).toBe("test-ns");
		expect(surreal.database).toBe("test-db");
	});

	test("connection status", async () => {
		const { surreal, connect } = createIdleSurreal();

		expect(surreal.status).toBe("disconnected");
		connect();
		expect(surreal.status).toBe("connecting");
		await surreal.ready;
		expect(surreal.status).toBe("connected");
		await surreal.close();
		expect(surreal.status).toBe("disconnected");
	});

	test("access token", async () => {
		const surreal = await createSurreal({
			unselected: true,
		});

		await surreal.ready;

		expect(surreal.accessToken).toBeString();
	});

	test("sequential connects", async () => {
		const { connect } = createIdleSurreal();

		await connect();
		await connect();
		await connect();
		await connect();
		await connect();
	});
});



================================================
FILE: packages/tests/integration/export.test.ts
================================================
import { beforeAll, describe, expect, test } from "bun:test";
import { compareVersions } from "compare-versions";
import { surql } from "surrealdb";
import { fetchVersion, setupServer } from "./__helpers__";

const { createSurreal } = await setupServer();

beforeAll(async () => {
	const surreal = await createSurreal();

	await surreal.query(surql`
		CREATE foo:1 CONTENT { hello: "world" };
		CREATE bar:1 CONTENT { hello: "world" };
		DEFINE FUNCTION fn::foo() { RETURN "bar"; };
	`);
});

describe("export", async () => {
	const surreal = await createSurreal();
	const version = await fetchVersion(surreal);
	const hasPostExport = compareVersions(version, "2.1.0") >= 0;

	test.if(hasPostExport)("basic", async () => {
		const res = await surreal.export();

		expect(res).toMatchSnapshot();
	});

	test.if(hasPostExport)("filter tables", async () => {
		const res = await surreal.export({
			tables: ["foo"],
		});

		expect(res).toMatchSnapshot();
	});

	test.if(hasPostExport)("filter functions", async () => {
		const res = await surreal.export({
			functions: true,
			tables: false,
		});

		expect(res).toMatchSnapshot();
	});
});



================================================
FILE: packages/tests/integration/import.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { compareVersions } from "compare-versions";
import { fetchVersion, setupServer } from "./__helpers__";

const { createSurreal } = await setupServer();

describe("import", async () => {
	const surreal = await createSurreal();
	const version = await fetchVersion(surreal);
	const runTest = compareVersions(version, "2.0.0") >= 0;

	test.if(runTest)("basic", async () => {
		await surreal.import(/* surql */ `
			CREATE foo:1 CONTENT { hello: "world" };
		`);

		const res = await surreal.query(/* surql */ `
			SELECT * FROM foo;
		`);

		expect(res).toMatchSnapshot();
	});
});



================================================
FILE: packages/tests/integration/__helpers__/database.ts
================================================
import { RecordId, Table } from "surrealdb";
import type { AnySurreal } from "./surreal";

export const personTable: Table<"person"> = new Table("person");
export const graphTable: Table<"graph"> = new Table("graph");

export type Person = {
	id: RecordId<"person">;
	firstname: string;
	lastname: string;
	age?: number;
};

export async function insertMockRecords(surreal: AnySurreal): Promise<void> {
	await surreal.insert([
		{
			id: new RecordId("person", 1),
			firstname: "John",
			lastname: "Doe",
		},
		{
			id: new RecordId("person", 2),
			firstname: "Mary",
			lastname: "Doe",
		},
	]);
}



================================================
FILE: packages/tests/integration/__helpers__/env.ts
================================================
import getPort from "get-port";

const port = await getPort();
if (typeof port !== "number") throw new Error("Could not claim port");

const port_unreachable = await getPort();
if (typeof port_unreachable !== "number") {
	throw new Error("Could not claim port");
}

export const SURREAL_EXECUTABLE_PATH: string =
	process.env.SURREAL_EXECUTABLE_PATH || "/usr/local/bin/surreal";
export const SURREAL_PORT: string = port.toString();
export const SURREAL_BIND: string = `0.0.0.0:${SURREAL_PORT}`;
export const SURREAL_PORT_UNREACHABLE: string = port_unreachable.toString();
export const SURREAL_BIND_UNREACHABLE: string = `0.0.0.0:${SURREAL_PORT}`;
export const SURREAL_USER = "root";
export const SURREAL_PASS = "root";
export const SURREAL_NS = "test";
export const SURREAL_DB = "test";



================================================
FILE: packages/tests/integration/__helpers__/helpers.ts
================================================
import type { AnySurreal } from "./surreal";

export async function fetchVersion(surreal: AnySurreal): Promise<string> {
	return (await surreal.version()).replace(/^surrealdb-/, "");
}



================================================
FILE: packages/tests/integration/__helpers__/index.ts
================================================
export * from "./surreal";
export * from "./env";
export * from "./helpers";
export * from "./database";



================================================
FILE: packages/tests/integration/__helpers__/surreal.ts
================================================
import {
	type AnyAuth,
	type ConnectOptions,
	type ReconnectOptions,
	SurrealV1,
	type SurrealV2,
} from "surrealdb";

import { afterAll } from "bun:test";
import { rm } from "node:fs/promises";
import type { Subprocess } from "bun";
import { SURREAL_BIND, SURREAL_PORT_UNREACHABLE, SURREAL_USER } from "./env.ts";
import { SURREAL_EXECUTABLE_PATH } from "./env.ts";
import { SURREAL_PASS } from "./env.ts";
import { SURREAL_DB } from "./env.ts";
import { SURREAL_NS } from "./env.ts";
import { SURREAL_PORT } from "./env.ts";

export type AnySurreal = SurrealV1 | SurrealV2;
export type Protocol = "http" | "ws";
export type PremadeAuth = "root" | "invalid" | "none";
export type IdleSurreal = {
	surreal: SurrealV1;
	connect: (custom?: ConnectOptions) => Promise<true>;
};

export const DEFAULT_PROTOCOL: Protocol =
	import.meta.env.SURREAL_DEFAULT_PROTOCOL === "http" ? "http" : "ws";

export const VERSION_CHECK: boolean =
	import.meta.env.SURREAL_VERSION_CHECK !== "false";

declare global {
	var surrealProc: number;
}

export function createAuth(auth: PremadeAuth | AnyAuth): AnyAuth | undefined {
	switch (auth) {
		case "root": {
			return {
				username: SURREAL_USER,
				password: SURREAL_PASS,
			};
		}
		case "invalid": {
			return {
				username: "invalid",
				password: "invalid",
			};
		}
		case "none": {
			return undefined;
		}
		default:
			return auth;
	}
}

type CreateSurrealOptions = {
	protocol?: Protocol;
	auth?: PremadeAuth;
	reachable?: boolean;
	unselected?: boolean;
	reconnect?: boolean | Partial<ReconnectOptions>;
	renewAccess?: boolean;
};

export async function setupServer(): Promise<{
	spawn: () => Promise<void>;
	kill: () => Promise<void>;
	createSurreal: (options?: CreateSurrealOptions) => Promise<SurrealV1>;
	createIdleSurreal: (options?: CreateSurrealOptions) => IdleSurreal;
}> {
	const folder = `test.db/${Math.random().toString(36).substring(2, 7)}`;
	let proc: undefined | Subprocess = undefined;

	async function spawn() {
		proc = Bun.spawn([SURREAL_EXECUTABLE_PATH, "start", `rocksdb:${folder}`], {
			env: {
				SURREAL_BIND,
				SURREAL_USER,
				SURREAL_PASS,
			},
		});

		await waitForHealth();
	}

	async function kill() {
		proc?.kill();
		await Bun.sleep(1000);
	}

	function createIdleSurreal({
		protocol,
		auth,
		reachable,
		unselected,
		reconnect,
		renewAccess,
	}: CreateSurrealOptions = {}) {
		const surreal = new SurrealV1();
		const port = reachable === false ? SURREAL_PORT_UNREACHABLE : SURREAL_PORT;

		const connect = (custom?: ConnectOptions) => {
			return surreal.connect(
				`${protocol ?? DEFAULT_PROTOCOL}://127.0.0.1:${port}/rpc`,
				{
					namespace: unselected ? undefined : SURREAL_NS,
					database: unselected ? undefined : SURREAL_DB,
					authentication: createAuth(auth ?? "root"),
					renewAccess: renewAccess ?? false,
					reconnect,
					...custom,
				},
			);
		};

		return { surreal, connect } as IdleSurreal;
	}

	async function createSurreal(opts: CreateSurrealOptions = {}) {
		const { surreal, connect } = createIdleSurreal(opts);
		await connect();
		return surreal;
	}

	afterAll(async () => {
		await kill();
		await rm(folder, { recursive: true, force: true });
	});

	await spawn();

	return { createSurreal, createIdleSurreal, spawn, kill };
}

async function waitForHealth(): Promise<void> {
	const startAt = Date.now();

	while (Date.now() - startAt < 10_000) {
		try {
			const response = await fetch(`http://127.0.0.1:${SURREAL_PORT}/health`);

			if (response.ok) {
				return;
			}
		} catch {
			await new Promise((r) => setTimeout(r, 100));
		}
	}

	throw new Error("Could not resolve health endpoint after 10 seconds.");
}



================================================
FILE: packages/tests/integration/__snapshots__/export.test.ts.snap
================================================
// Bun Snapshot v1, https://goo.gl/fbAQLP

exports[`export basic 1`] = `
"-- ------------------------------
-- OPTION
-- ------------------------------

OPTION IMPORT;

-- ------------------------------
-- FUNCTIONS
-- ------------------------------

DEFINE FUNCTION fn::foo() { RETURN 'bar'; } PERMISSIONS FULL;

-- ------------------------------
-- TABLE: bar
-- ------------------------------

DEFINE TABLE bar TYPE ANY SCHEMALESS PERMISSIONS NONE;




-- ------------------------------
-- TABLE DATA: bar
-- ------------------------------

INSERT [ { hello: 'world', id: bar:1 } ];

-- ------------------------------
-- TABLE: foo
-- ------------------------------

DEFINE TABLE foo TYPE ANY SCHEMALESS PERMISSIONS NONE;




-- ------------------------------
-- TABLE DATA: foo
-- ------------------------------

INSERT [ { hello: 'world', id: foo:1 } ];

"
`;

exports[`export filter tables 1`] = `
"-- ------------------------------
-- OPTION
-- ------------------------------

OPTION IMPORT;

-- ------------------------------
-- FUNCTIONS
-- ------------------------------

DEFINE FUNCTION fn::foo() { RETURN 'bar'; } PERMISSIONS FULL;

-- ------------------------------
-- TABLE: foo
-- ------------------------------

DEFINE TABLE foo TYPE ANY SCHEMALESS PERMISSIONS NONE;




-- ------------------------------
-- TABLE DATA: foo
-- ------------------------------

INSERT [ { hello: 'world', id: foo:1 } ];

"
`;

exports[`export filter functions 1`] = `
"-- ------------------------------
-- OPTION
-- ------------------------------

OPTION IMPORT;

-- ------------------------------
-- FUNCTIONS
-- ------------------------------

DEFINE FUNCTION fn::foo() { RETURN 'bar'; } PERMISSIONS FULL;

"
`;



================================================
FILE: packages/tests/integration/__snapshots__/import.test.ts.snap
================================================
// Bun Snapshot v1, https://goo.gl/fbAQLP

exports[`import basic 1`] = `
[
  [
    {
      "hello": "world",
      "id": RecordId {
        "id": 1,
        "table": Table {
          "name": "foo",
        },
      },
    },
  ],
]
`;



================================================
FILE: packages/tests/integration/protocol/http.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { ConnectionUnavailable } from "surrealdb";
import { setupServer } from "../__helpers__";

const { createSurreal, createIdleSurreal } = await setupServer();

describe("HTTP protocol", () => {
	test("basic connection", async () => {
		const surreal = await createSurreal({
			protocol: "http",
		});

		await surreal.ready;
	});

	test("execute query", async () => {
		const surreal = await createSurreal({
			protocol: "http",
		});

		const [result] = await surreal.query("INFO FOR ROOT");

		expect(result).toBeObject();
	});

	test("status events", async () => {
		const { surreal, connect } = createIdleSurreal({
			protocol: "http",
		});

		let phase = 0;

		surreal.subscribe("connecting", () => {
			if (phase === 0) {
				phase = 1;
			}
		});

		surreal.subscribe("connected", () => {
			if (phase === 1) {
				phase = 2;
			}
		});

		surreal.subscribe("disconnected", () => {
			if (phase === 2) {
				phase = 3;
			}
		});

		await connect();
		await surreal.ready;
		await surreal.close();

		expect(phase).toBe(3);
	});

	test("connection unavailable", async () => {
		const { surreal } = createIdleSurreal({
			protocol: "ws",
		});

		expect(async () => {
			await surreal.ready;
		}).toThrow(ConnectionUnavailable);
	});
});



================================================
FILE: packages/tests/integration/protocol/websocket.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { ConnectionUnavailable } from "surrealdb";
import { setupServer } from "../__helpers__";

const { createSurreal, createIdleSurreal, kill, spawn } = await setupServer();

describe("WebSocket protocol", () => {
	test("basic connection", async () => {
		const surreal = await createSurreal({
			protocol: "ws",
		});

		await surreal.ready;
	});

	test("execute query", async () => {
		const surreal = await createSurreal({
			protocol: "ws",
		});

		const [result] = await surreal.query("INFO FOR ROOT");

		expect(result).toBeObject();
	});

	test("status events", async () => {
		const { surreal, connect } = createIdleSurreal({
			protocol: "ws",
		});

		let phase = 0;

		surreal.subscribe("connecting", () => {
			if (phase === 0) {
				phase = 1;
			}
		});

		surreal.subscribe("connected", () => {
			if (phase === 1) {
				phase = 2;
			}
		});

		surreal.subscribe("disconnected", () => {
			if (phase === 2) {
				phase = 3;
			}
		});

		await connect();
		await surreal.ready;
		await surreal.close();

		expect(phase).toBe(3);
	});

	test("connection unavailable", async () => {
		const { surreal } = createIdleSurreal({
			protocol: "ws",
		});

		expect(async () => {
			await surreal.ready;
		}).toThrow(ConnectionUnavailable);
	});

	test("reconnect on disconnect", async () => {
		const surreal = await createSurreal({
			protocol: "ws",
			reconnect: {
				enabled: true,
			},
		});

		const reconnectPromise = Promise.withResolvers();
		const connectedPromise = Promise.withResolvers();

		surreal.subscribe("reconnecting", () => reconnectPromise.resolve());
		surreal.subscribe("connected", () => connectedPromise.resolve());

		await kill();
		spawn();

		await reconnectPromise.promise;
		await connectedPromise.promise;
	});
});



================================================
FILE: packages/tests/integration/query/create.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { RecordId } from "surrealdb";
import { type Person, personTable, setupServer } from "../__helpers__";

const { createSurreal } = await setupServer();

describe("create()", async () => {
	const surreal = await createSurreal();

	test("single", async () => {
		const single = await surreal.create<Person, Omit<Person, "id">>(
			new RecordId("person", 1),
			{
				firstname: "John",
				lastname: "Doe",
			},
		);

		expect(single).toStrictEqual({
			id: new RecordId("person", 1),
			firstname: "John",
			lastname: "Doe",
		});
	});

	test("multiple", async () => {
		const multiple = await surreal.create<Person>(personTable, {
			id: new RecordId("person", 2),
			firstname: "Mary",
			lastname: "Doe",
		});

		expect(multiple).toStrictEqual([
			{
				id: new RecordId("person", 2),
				firstname: "Mary",
				lastname: "Doe",
			},
		]);
	});
});



================================================
FILE: packages/tests/integration/query/delete.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { RecordId } from "surrealdb";
import {
	type Person,
	insertMockRecords,
	personTable,
	setupServer,
} from "../__helpers__";

const { createSurreal } = await setupServer();

describe("delete()", async () => {
	const surreal = await createSurreal();

	await insertMockRecords(surreal);

	test("single", async () => {
		const single = await surreal.delete<Person>(new RecordId("person", 1));

		expect(single).toStrictEqual({
			id: new RecordId("person", 1),
			firstname: "John",
			lastname: "Doe",
		});
	});

	test("multiple", async () => {
		const multiple = await surreal.delete<Person>(personTable);

		expect(multiple).toStrictEqual([
			{
				id: new RecordId("person", 2),
				firstname: "Mary",
				lastname: "Doe",
			},
		]);
	});
});



================================================
FILE: packages/tests/integration/query/insert.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { RecordId } from "surrealdb";
import { type Person, setupServer } from "../__helpers__";

const { createSurreal } = await setupServer();

describe("insert()", async () => {
	const surreal = await createSurreal();

	test("single", async () => {
		const [single] = await surreal.insert<Person>({
			id: new RecordId("person", 1),
			firstname: "John",
			lastname: "Doe",
		});

		expect(single).toStrictEqual({
			id: new RecordId("person", 1),
			firstname: "John",
			lastname: "Doe",
		});
	});

	test("multiple", async () => {
		const multiple = await surreal.insert<Person>([
			{
				id: new RecordId("person", 3),
				firstname: "John",
				lastname: "Doe",
			},
			{
				id: new RecordId("person", 4),
				firstname: "Mary",
				lastname: "Doe",
			},
		]);

		expect(multiple).toStrictEqual([
			{
				id: new RecordId("person", 3),
				firstname: "John",
				lastname: "Doe",
			},
			{
				id: new RecordId("person", 4),
				firstname: "Mary",
				lastname: "Doe",
			},
		]);
	});
});



================================================
FILE: packages/tests/integration/query/live.test.ts
================================================
import { describe, expect, mock, test } from "bun:test";
import { RecordId, type Uuid } from "surrealdb";
import { insertMockRecords, personTable, setupServer } from "../__helpers__";

const { createSurreal, kill, spawn } = await setupServer();

describe("live() / liveOf()", async () => {
	const surreal = await createSurreal({
		protocol: "ws",
		reconnect: {
			enabled: true,
		},
	});

	await insertMockRecords(surreal);

	test("subscription properties", async () => {
		const subscription = await surreal.live(personTable);

		expect(subscription.isAlive).toBeTrue();
		expect(subscription.isManaged).toBeTrue();
		expect(subscription.resource).toEqual(personTable);

		await subscription.kill();

		expect(subscription.isAlive).toBeFalse();
	});

	test("create action", async () => {
		const subscription = await surreal.live(personTable);
		const { promise, resolve } = Promise.withResolvers();
		const mockHandler = mock(() => resolve());

		subscription.subscribe(mockHandler);

		await surreal.create(new RecordId("person", 3), {
			firstname: "John",
			lastname: "Doe",
		});

		await promise;

		expect(mockHandler).toBeCalledTimes(1);
		expect(mockHandler).toBeCalledWith(
			"CREATE",
			{
				id: new RecordId("person", 3),
				firstname: "John",
				lastname: "Doe",
			},
			new RecordId("person", 3),
		);

		await subscription.kill();
	});

	test("update action", async () => {
		const subscription = await surreal.live(personTable);
		const { promise, resolve } = Promise.withResolvers();
		const mockHandler = mock(() => resolve());

		subscription.subscribe(mockHandler);

		await surreal.update(new RecordId("person", 3), {
			firstname: "John",
			lastname: "Doe",
			age: 20,
		});

		await promise;

		expect(mockHandler).toBeCalledTimes(1);
		expect(mockHandler).toBeCalledWith(
			"UPDATE",
			{
				id: new RecordId("person", 3),
				firstname: "John",
				lastname: "Doe",
				age: 20,
			},
			new RecordId("person", 3),
		);

		await subscription.kill();
	});

	test("delete action", async () => {
		const subscription = await surreal.live(personTable);
		const { promise, resolve } = Promise.withResolvers();
		const mockHandler = mock(() => resolve());

		subscription.subscribe(mockHandler);

		await surreal.delete(new RecordId("person", 3));

		await promise;

		expect(mockHandler).toBeCalledTimes(1);
		expect(mockHandler).toBeCalledWith(
			"DELETE",
			{
				id: new RecordId("person", 3),
				firstname: "John",
				lastname: "Doe",
				age: 20,
			},
			new RecordId("person", 3),
		);

		await subscription.kill();
	});

	test("reconnect and resume", async () => {
		const subscription = await surreal.live(personTable);
		const { promise, resolve } = Promise.withResolvers();
		const mockHandler = mock(() => resolve());

		subscription.subscribe(mockHandler);

		const initialId = subscription.id;

		// Restart server and wait for reconnection
		await kill();
		await spawn();
		await surreal.ready;

		// Make sure we obtained a new live id
		expect(initialId).not.toEqual(subscription.id);

		await surreal.create(new RecordId("person", 3), {
			firstname: "John",
			lastname: "Doe",
		});

		await promise;

		expect(mockHandler).toBeCalledTimes(1);
		expect(mockHandler).toBeCalledWith(
			"CREATE",
			{
				id: new RecordId("person", 3),
				firstname: "John",
				lastname: "Doe",
			},
			new RecordId("person", 3),
		);

		await subscription.kill();

		expect(subscription.isAlive).toBeFalse();
	});

	test("unmanaged subscription properties", async () => {
		const [liveId] = await surreal.query<[Uuid]>("LIVE SELECT * FROM person");
		const subscription = await surreal.liveOf(liveId);

		expect(subscription.isAlive).toBeTrue();
		expect(subscription.isManaged).toBeFalse();
		expect(subscription.resource).toBeUndefined();

		await subscription.kill();

		expect(subscription.isAlive).toBeFalse();
	});

	test("unmanaged create action", async () => {
		const [liveId] = await surreal.query<[Uuid]>("LIVE SELECT * FROM person");
		const subscription = await surreal.liveOf(liveId);
		const { promise, resolve } = Promise.withResolvers();
		const mockHandler = mock(() => resolve());

		subscription.subscribe(mockHandler);

		await surreal.create(new RecordId("person", 4), {
			firstname: "John",
			lastname: "Doe",
		});

		await promise;

		expect(mockHandler).toBeCalledTimes(1);
		expect(mockHandler).toBeCalledWith(
			"CREATE",
			{
				id: new RecordId("person", 4),
				firstname: "John",
				lastname: "Doe",
			},
			new RecordId("person", 4),
		);

		await subscription.kill();
	});

	test.todo("iterator", async () => {
		const subscription = await surreal.live(personTable);
		const iterator = subscription.iterate();

		await surreal.create(new RecordId("person", 5), {
			firstname: "John",
			lastname: "Doe",
		});

		await surreal.merge(new RecordId("person", 5), {
			firstname: "Mary",
		});

		await surreal.delete(new RecordId("person", 5));

		// Order not guaranteed
		const responses = new Set([
			await iterator.next(),
			await iterator.next(),
			await iterator.next(),
		]);

		expect(responses).toContainEqual({
			done: false,
			value: [
				"CREATE",
				{
					id: new RecordId("person", 5),
					firstname: "John",
					lastname: "Doe",
				},
				new RecordId("person", 5),
			],
		});

		expect(responses).toContainEqual({
			done: false,
			value: [
				"UPDATE",
				{
					id: new RecordId("person", 5),
					firstname: "Mary",
					lastname: "Doe",
				},
				new RecordId("person", 5),
			],
		});

		expect(responses).toContainEqual({
			done: false,
			value: [
				"DELETE",
				{
					id: new RecordId("person", 5),
					firstname: "Mary",
					lastname: "Doe",
				},
				new RecordId("person", 5),
			],
		});

		await subscription.kill();

		expect(await iterator.next()).toEqual({
			done: true,
			value: ["CLOSED", "KILLED"],
		});
	});

	test.todo("iterator survives reconnect", async () => {
		const subscription = await surreal.live(personTable);
		const iterator = subscription.iterate();
		const initialId = subscription.id;

		// Restart server and wait for reconnection
		await kill();
		await spawn();
		await surreal.ready;

		// Make sure we obtained a new live id
		expect(initialId).not.toEqual(subscription.id);

		await surreal.create(new RecordId("person", 6), {
			firstname: "John",
			lastname: "Doe",
		});

		expect(await iterator.next()).toEqual({
			done: false,
			value: [
				"CREATE",
				{
					id: new RecordId("person", 6),
					firstname: "John",
					lastname: "Doe",
				},
				new RecordId("person", 6),
			],
		});

		subscription.kill();

		expect(await iterator.next()).toEqual({
			done: true,
			value: ["CLOSED", "KILLED"],
		});

		expect(subscription.isAlive).toBeFalse();
	});
});



================================================
FILE: packages/tests/integration/query/merge.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { RecordId } from "surrealdb";
import {
	type Person,
	insertMockRecords,
	personTable,
	setupServer,
} from "../__helpers__";

const { createSurreal } = await setupServer();

describe("merge()", async () => {
	const surreal = await createSurreal();

	await insertMockRecords(surreal);

	test("single", async () => {
		const single = await surreal.merge<Person>(new RecordId("person", 1), {
			age: 20,
		});

		expect(single).toStrictEqual({
			id: new RecordId("person", 1),
			firstname: "John",
			lastname: "Doe",
			age: 20,
		});
	});

	test("multiple", async () => {
		const multiple = await surreal.merge<Person>(personTable, { age: 25 });

		expect(multiple).toStrictEqual([
			{
				id: new RecordId("person", 1),
				firstname: "John",
				lastname: "Doe",
				age: 25,
			},
			{
				id: new RecordId("person", 2),
				firstname: "Mary",
				lastname: "Doe",
				age: 25,
			},
		]);
	});
});



================================================
FILE: packages/tests/integration/query/params.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { setupServer } from "../__helpers__";

const { createSurreal } = await setupServer();

describe("let() / unset()", async () => {
	const surreal = await createSurreal();

	test("define param", async () => {
		await surreal.let("hello", "world");

		const [result] = await surreal.query<[string]>("RETURN $hello");

		expect(result).toBe("world");
	});

	test("unset param", async () => {
		await surreal.unset("hello");

		const [result] = await surreal.query<[string]>("RETURN $hello");

		expect(result).toBeUndefined();
	});

	test("retrieve state", async () => {
		await surreal.let("foo", "bar");

		expect(surreal.parameters).toMatchObject({
			foo: "bar",
		});
	});
});



================================================
FILE: packages/tests/integration/query/patch.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { RecordId } from "surrealdb";
import {
	type Person,
	insertMockRecords,
	personTable,
	setupServer,
} from "../__helpers__";

const { createSurreal } = await setupServer();

describe("patch()", async () => {
	const surreal = await createSurreal();

	await insertMockRecords(surreal);

	test("single", async () => {
		const single = await surreal.patch<Person>(new RecordId("person", 1), [
			{ op: "replace", path: "/firstname", value: "John" },
		]);

		expect(single).toStrictEqual({
			id: new RecordId("person", 1),
			firstname: "John",
			lastname: "Doe",
		});
	});

	test("multiple", async () => {
		const multiple = await surreal.patch<Person>(personTable, [
			{ op: "replace", path: "/age", value: 30 },
		]);

		expect(multiple).toStrictEqual([
			{
				id: new RecordId("person", 1),
				firstname: "John",
				lastname: "Doe",
				age: 30,
			},
			{
				id: new RecordId("person", 2),
				firstname: "Mary",
				lastname: "Doe",
				age: 30,
			},
		]);
	});

	test("single diff", async () => {
		const singleDiff = await surreal.patch(
			new RecordId("person", 1),
			[{ op: "replace", path: "/age", value: 25 }],
			true,
		);

		expect(singleDiff).toStrictEqual([
			{ op: "replace", path: "/age", value: 25 },
		]);
	});

	test("multiple diff", async () => {
		const multipleDiff = await surreal.patch(
			personTable,
			[{ op: "replace", path: "/age", value: 20 }],
			true,
		);

		expect(multipleDiff).toStrictEqual([
			[{ op: "replace", path: "/age", value: 20 }],
			[{ op: "replace", path: "/age", value: 20 }],
		]);
	});
});



================================================
FILE: packages/tests/integration/query/relate.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { RecordId } from "surrealdb";
import { graphTable, setupServer } from "../__helpers__";

const { createSurreal } = await setupServer();

describe("relate()", async () => {
	const surreal = await createSurreal();
	const version = await surreal.version();
	const skip = version === "surrealdb-1.4.2";

	test.skipIf(skip)("single", async () => {
		const single = await surreal.relate(
			new RecordId("edge", "in"),
			new RecordId("graph", 1),
			new RecordId("edge", "out"),
			{
				num: 123,
			},
		);

		expect(single).toStrictEqual({
			id: new RecordId("graph", 1),
			in: new RecordId("edge", "in"),
			out: new RecordId("edge", "out"),
			num: 123,
		});
	});

	test.skipIf(skip)("multiple", async () => {
		const multiple = await surreal.relate(
			new RecordId("edge", "in"),
			graphTable,
			new RecordId("edge", "out"),
			{
				id: new RecordId("graph", 2),
				num: 456,
			},
		);

		expect(multiple).toStrictEqual([
			{
				id: new RecordId("graph", 2),
				in: new RecordId("edge", "in"),
				out: new RecordId("edge", "out"),
				num: 456,
			},
		]);
	});
});



================================================
FILE: packages/tests/integration/query/run.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { setupServer } from "../__helpers__";

const { createSurreal } = await setupServer();

describe("run()", async () => {
	const surreal = await createSurreal();

	test("run", async () => {
		const res = await surreal.run<number[]>("array::add", [[1, 2], 3]);
		expect(res).toMatchObject([1, 2, 3]);
	});
});



================================================
FILE: packages/tests/integration/query/select.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { BoundIncluded, RecordId, RecordIdRange } from "surrealdb";
import {
	type Person,
	insertMockRecords,
	personTable,
	setupServer,
} from "../__helpers__";

const { createSurreal } = await setupServer();

describe("select()", async () => {
	const surreal = await createSurreal();

	await insertMockRecords(surreal);

	test("single", async () => {
		const single = await surreal.select<Person>(new RecordId("person", 1));

		expect(single).toStrictEqual({
			id: new RecordId("person", 1),
			firstname: "John",
			lastname: "Doe",
		});
	});

	test("multiple", async () => {
		const multiple = await surreal.select<Person>(personTable);

		expect(multiple).toStrictEqual([
			{
				id: new RecordId("person", 1),
				firstname: "John",
				lastname: "Doe",
			},
			{
				id: new RecordId("person", 2),
				firstname: "Mary",
				lastname: "Doe",
			},
		]);
	});

	test("range", async () => {
		const range = await surreal.select<Person>(
			new RecordIdRange(
				personTable,
				new BoundIncluded(1),
				new BoundIncluded(2),
			),
		);

		expect(range).toStrictEqual([
			{
				id: new RecordId("person", 1),
				firstname: "John",
				lastname: "Doe",
			},
			{
				id: new RecordId("person", 2),
				firstname: "Mary",
				lastname: "Doe",
			},
		]);
	});
});



================================================
FILE: packages/tests/integration/query/update.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { RecordId } from "surrealdb";
import {
	type Person,
	insertMockRecords,
	personTable,
	setupServer,
} from "../__helpers__";

const { createSurreal } = await setupServer();

describe("update()", async () => {
	const surreal = await createSurreal();

	await insertMockRecords(surreal);

	test("single", async () => {
		const single = await surreal.update<Person, Omit<Person, "id">>(
			new RecordId("person", 1),
			{
				firstname: "John",
				lastname: "Doe",
			},
		);

		expect(single).toStrictEqual({
			id: new RecordId("person", 1),
			firstname: "John",
			lastname: "Doe",
		});
	});

	test("multiple", async () => {
		const multiple = await surreal.update<Person, Omit<Person, "id">>(
			personTable,
			{
				firstname: "Mary",
				lastname: "Doe",
			},
		);

		expect(multiple).toStrictEqual([
			{
				id: new RecordId("person", 1),
				firstname: "Mary",
				lastname: "Doe",
			},
			{
				id: new RecordId("person", 2),
				firstname: "Mary",
				lastname: "Doe",
			},
		]);
	});
});



================================================
FILE: packages/tests/integration/query/upsert.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { RecordId } from "surrealdb";
import { type Person, setupServer } from "../__helpers__";

const { createSurreal } = await setupServer();

describe("upsert()", async () => {
	const surreal = await createSurreal();

	test("single", async () => {
		const single = await surreal.upsert<Person, Omit<Person, "id">>(
			new RecordId("person", 1),
			{
				firstname: "John",
				lastname: "Doe",
			},
		);

		expect(single).toStrictEqual({
			id: new RecordId("person", 1),
			firstname: "John",
			lastname: "Doe",
		});
	});
});



================================================
FILE: packages/tests/unit/cbor.test.ts
================================================
import { describe, expect, test } from "bun:test";
import {
	CborFillMissing,
	CborInvalidMajorError,
	CborPartialDisabled,
	CborRangeError,
	Gap,
	POW_2_64,
	decode,
	encode,
} from "@surrealdb/cbor";

describe("cbor", () => {
	test("encode basic types", () => {
		expect(encode(123)).toMatchSnapshot("positive integer");
		expect(encode(-123)).toMatchSnapshot("negative integer");
		expect(encode(123.456)).toMatchSnapshot("positive float");
		expect(encode(-123.456)).toMatchSnapshot("negative float");
		expect(encode(POW_2_64 - 1n)).toMatchSnapshot("positive bigint");
		expect(encode(-POW_2_64)).toMatchSnapshot("negative bigint");
		expect(encode("Hello \nWorld!")).toMatchSnapshot("string");
		expect(encode(undefined)).toMatchSnapshot("undefined");
		expect(encode(null)).toMatchSnapshot("null");
		expect(encode(true)).toMatchSnapshot("true");
		expect(encode(false)).toMatchSnapshot("false");
		expect(encode(new Map([["key", "value"]]))).toMatchSnapshot("map");
		expect(encode({ key: "value" })).toMatchSnapshot("object");
		expect(encode([123, "abc"])).toMatchSnapshot("array");

		const bytes = new Uint8Array([1, 2, 3]);
		expect(encode(bytes)).toMatchSnapshot("uint8array");
		expect(encode(bytes.buffer)).toMatchSnapshot("arraybuffer");
	});

	test("encode/decode", () => {
		const bytes = new Uint8Array([1, 2, 3]);
		const input = {
			posint: 123,
			negint: -123,
			posflo: 123.456,
			negflo: -123.456,
			posbig: POW_2_64 - 1n,
			negbig: -POW_2_64,
			string: "Hello World!",
			undefined: undefined,
			null: null,
			false: false,
			true: true,
			map: new Map([["key", "value"]]),
			array: [123, "abc"],
			uint8array: bytes,
			arraybuffer: bytes.buffer,
		};

		const encoded = encode(input);
		expect(encoded).toMatchSnapshot("encoded input");

		const decoded = decode(encoded);
		expect(decoded).toMatchSnapshot("decoded input");
	});

	describe("infinity", () => {
		test("valid bytes", () => {
			const decoded = decode(
				new Uint8Array([
					95, // infinite bytes start
					65, // byte string, len 1
					1, // Some byte
					66, // byte string, len 2
					1, // Some byte
					2, // Some byte
					255, // break
				]),
			);

			expect(decoded).toMatchObject(new Uint8Array([1, 1, 2]).buffer);
		});

		test("invalid bytes, nested infinite bytes", () => {
			const res = new Promise(() =>
				decode(
					new Uint8Array([
						95, // infinite bytes start
						95, // infinite bytes start (not allowed)
						65, // byte string, len 1
						1, // Some byte
						255, // break
						255, // break
					]),
				),
			);

			expect(res).rejects.toBeInstanceOf(CborRangeError);
		});

		test("invalid bytes, no break", () => {
			const res = new Promise(() =>
				decode(
					new Uint8Array([
						95, // infinite bytes start
						65, // byte string, len 1
						1, // Some byte
						// break (255) is missing
					]),
				),
			);

			expect(res).rejects.toBeInstanceOf(CborRangeError);
		});

		test("invalid bytes, invalid major", () => {
			const res = new Promise(() =>
				decode(
					new Uint8Array([
						95, // infinite bytes start
						96, // text string, len 1 (invalid major)
						1, // Some byte
						255, // break
					]),
				),
			);

			expect(res).rejects.toBeInstanceOf(CborInvalidMajorError);
		});

		test("valid text", () => {
			const decoded = decode(
				new Uint8Array([
					127, // infinite text start
					97, // byte string, len 1
					97, // letter "a"
					98, // byte string, len 2
					98, // letter "b"
					99, // letter "c"
					255, // break
				]),
			);

			expect(decoded).toMatch("abc");
		});

		test("valid array", () => {
			const decoded = decode(
				new Uint8Array([
					159, // infinite array start
					97, // byte string, len 1
					97, // letter "a"
					98, // byte string, len 2
					98, // letter "b"
					99, // letter "c"
					255, // break
				]),
			);

			expect(decoded).toMatchObject(["a", "bc"]);
		});

		test("valid map", () => {
			const decoded = decode(
				new Uint8Array([
					191, // infinite map start
					97, // byte string, len 1
					97, // letter "a"
					98, // byte string, len 2
					98, // letter "b"
					99, // letter "c"
					255, // break
				]),
			);

			expect(decoded).toMatchObject({ a: "bc" });
		});
	});

	describe("partial", () => {
		test("Fails if not enabled", () => {
			const res = new Promise(() => {
				const gap = new Gap();
				encode({ gap });
			});

			expect(res).rejects.toBeInstanceOf(CborPartialDisabled);
		});

		test("Fails to build if fill for gap is missing", () => {
			const res = new Promise(() => {
				const gap = new Gap();
				const partial = encode({ gap }, { partial: true });
				partial.build([]);
			});

			expect(res).rejects.toBeInstanceOf(CborFillMissing);
		});

		describe("Succeeds if configured correctly", () => {
			const name = new Gap<string>();
			const age = new Gap<number>();
			const enabled = new Gap(true);
			const partial = encode(
				[
					"CREATE person SET name = $name, age = $age, enabled = $enabled",
					{
						name,
						age,
						enabled,
					},
				],
				{ partial: true },
			);

			test("with gaps filled", () => {
				const res = decode(partial.build([name.fill("John"), age.fill(30)]));
				expect(res?.[1]).toStrictEqual({
					name: "John",
					age: 30,
					enabled: true,
				});
			});

			test("with defaults overwritten", () => {
				const res = decode(
					partial.build([name.fill("John"), age.fill(30), enabled.fill(false)]),
				);

				expect(res?.[1]).toStrictEqual({
					name: "John",
					age: 30,
					enabled: false,
				});
			});
		});
	});
});



================================================
FILE: packages/tests/unit/__helpers__/index.ts
================================================
export * from "./mock.ts";



================================================
FILE: packages/tests/unit/__helpers__/mock.ts
================================================
import {
	BoundExcluded,
	BoundIncluded,
	Decimal,
	Duration,
	GeometryCollection,
	GeometryLine,
	GeometryMultiPolygon,
	GeometryPoint,
	GeometryPolygon,
	Range,
	RecordId,
	RecordIdRange,
	StringRecordId,
	Table,
	Uuid,
} from "surrealdb";

export function createMockValue(): object {
	return {
		rid: new RecordId("some:thing", "under_score"),
		id_looks_like_number: new RecordId("some:thing", "123"),
		id_almost_a_number: new RecordId("some:thing", "1e23"),
		id_is_a_number: new RecordId("some:thing", 123),
		str_rid: new StringRecordId("⟨some:thing⟩:under_score"),
		rng_rid: new RecordIdRa
			"bla",
			new BoundIncluded("a"),
			new BoundExcluded("z"),
		),
		range: new Range(
			new BoundIncluded(new RecordId("bla", "a")),
			new BoundExcluded("z"),
		),
		range_unbounded: new Range(undefined, new BoundExcluded("z")),
		dec: new Decimal("3.333333"),
		dur: new Duration("1d2h"),
		geo: new GeometryCollection([
			new GeometryPoint([1, 2]),
			new GeometryMultiPolygon([
				new GeometryPolygon([
					new GeometryLine([
						new GeometryPoint([1, 2]),
						new GeometryPoint([3, 4]),
					]),
					new GeometryLine([
						new GeometryPoint([5, 6]),
						new GeometryPoint([7, 8]),
					]),
				]),
			]),
			new GeometryPolygon([
				new GeometryLine([
					new GeometryPoint([1, 2]),
					new GeometryPoint([3, 4]),
				]),
				new GeometryLine([
					new GeometryPoint([5, 6]),
					new GeometryPoint([7, 8]),
				]),
			]),
		]),

		tb: new Table("some super _ cool table"),
		uuid: new Uuid("92b84bde-39c8-4b4b-92f7-626096d6c4d9"),
		date: new Date("2024-05-06T17:44:57.085Z"),
		undef: undefined,
		null: null,
		num: 123,
		float: 123.456,
		true: true,
		false: false,
		string: "I am a string",
	};
}



================================================
FILE: packages/tests/unit/__snapshots__/cbor.test.ts.snap
================================================
// Bun Snapshot v1, https://goo.gl/fbAQLP

exports[`cbor encode basic types: positive integer 1`] = `
Uint8Array [
  24,
  123,
]
`;

exports[`cbor encode basic types: negative integer 1`] = `
Uint8Array [
  56,
  122,
]
`;

exports[`cbor encode basic types: positive float 1`] = `
Uint8Array [
  251,
  64,
  94,
  221,
  47,
  26,
  159,
  190,
  119,
]
`;

exports[`cbor encode basic types: negative float 1`] = `
Uint8Array [
  251,
  192,
  94,
  221,
  47,
  26,
  159,
  190,
  119,
]
`;

exports[`cbor encode basic types: positive bigint 1`] = `
Uint8Array [
  27,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
]
`;

exports[`cbor encode basic types: negative bigint 1`] = `
Uint8Array [
  59,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
]
`;

exports[`cbor encode basic types: string 1`] = `
Uint8Array [
  109,
  72,
  101,
  108,
  108,
  111,
  32,
  10,
  87,
  111,
  114,
  108,
  100,
  33,
]
`;

exports[`cbor encode basic types: undefined 1`] = `
Uint8Array [
  247,
]
`;

exports[`cbor encode basic types: null 1`] = `
Uint8Array [
  246,
]
`;

exports[`cbor encode basic types: true 1`] = `
Uint8Array [
  245,
]
`;

exports[`cbor encode basic types: false 1`] = `
Uint8Array [
  244,
]
`;

exports[`cbor encode basic types: map 1`] = `
Uint8Array [
  161,
  99,
  107,
  101,
  121,
  101,
  118,
  97,
  108,
  117,
  101,
]
`;

exports[`cbor encode basic types: object 1`] = `
Uint8Array [
  161,
  99,
  107,
  101,
  121,
  101,
  118,
  97,
  108,
  117,
  101,
]
`;

exports[`cbor encode basic types: array 1`] = `
Uint8Array [
  130,
  24,
  123,
  99,
  97,
  98,
  99,
]
`;

exports[`cbor encode basic types: uint8array 1`] = `
Uint8Array [
  67,
  1,
  2,
  3,
]
`;

exports[`cbor encode basic types: arraybuffer 1`] = `
Uint8Array [
  67,
  1,
  2,
  3,
]
`;

exports[`cbor encode/decode: encoded input 1`] = `
Uint8Array [
  175,
  102,
  112,
  111,
  115,
  105,
  110,
  116,
  24,
  123,
  102,
  110,
  101,
  103,
  105,
  110,
  116,
  56,
  122,
  102,
  112,
  111,
  115,
  102,
  108,
  111,
  251,
  64,
  94,
  221,
  47,
  26,
  159,
  190,
  119,
  102,
  110,
  101,
  103,
  102,
  108,
  111,
  251,
  192,
  94,
  221,
  47,
  26,
  159,
  190,
  119,
  102,
  112,
  111,
  115,
  98,
  105,
  103,
  27,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  102,
  110,
  101,
  103,
  98,
  105,
  103,
  59,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  102,
  115,
  116,
  114,
  105,
  110,
  103,
  108,
  72,
  101,
  108,
  108,
  111,
  32,
  87,
  111,
  114,
  108,
  100,
  33,
  105,
  117,
  110,
  100,
  101,
  102,
  105,
  110,
  101,
  100,
  247,
  100,
  110,
  117,
  108,
  108,
  246,
  101,
  102,
  97,
  108,
  115,
  101,
  244,
  100,
  116,
  114,
  117,
  101,
  245,
  99,
  109,
  97,
  112,
  161,
  99,
  107,
  101,
  121,
  101,
  118,
  97,
  108,
  117,
  101,
  101,
  97,
  114,
  114,
  97,
  121,
  130,
  24,
  123,
  99,
  97,
  98,
  99,
  106,
  117,
  105,
  110,
  116,
  56,
  97,
  114,
  114,
  97,
  121,
  67,
  1,
  2,
  3,
  107,
  97,
  114,
  114,
  97,
  121,
  98,
  117,
  102,
  102,
  101,
  114,
  67,
  1,
  2,
  3,
]
`;

exports[`cbor encode/decode: decoded input 1`] = `
{
  "array": [
    123,
    "abc",
  ],
  "arraybuffer": ArrayBuffer [
    1,
    2,
    3,
  ],
  "false": false,
  "map": {
    "key": "value",
  },
  "negbig": -18446744073709551616n,
  "negflo": -123.456,
  "negint": -123,
  "null": null,
  "posbig": 18446744073709551615n,
  "posflo": 123.456,
  "posint": 123,
  "string": "Hello World!",
  "true": true,
  "uint8array": ArrayBuffer [
    1,
    2,
    3,
  ],
  "undefined": undefined,
}
`;



================================================
FILE: packages/tests/unit/utilities/equals.test.ts
================================================
import { describe, expect, test } from "bun:test";
import {
	BoundExcluded,
	BoundIncluded,
	RecordId,
	RecordIdRange,
	equals,
} from "surrealdb";
import { createMockValue } from "../__helpers__";

describe("equals()", () => {
	test("record ids", () => {
		const first = new RecordId("hello", "world");
		const second = new RecordId("hello", "world");

		expect(equals(first, second)).toBeTrue();
	});

	test("record id ranges", () => {
		const first = new RecordIdRange(
			"alphabet",
			new BoundIncluded("a"),
			new BoundExcluded("z"),
		);
		const second = new RecordIdRange(
			"alphabet",
			new BoundIncluded("a"),
			new BoundExcluded("z"),
		);

		expect(equals(first, second)).toBeTrue();
	});

	test("deep equality", () => {
		const first = createMockValue();
		const second = createMockValue();

		expect(equals(first, second)).toBeTrue();
	});
});



================================================
FILE: packages/tests/unit/utilities/escape.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { escapeIdent, escapeNumber } from "surrealdb";

describe("escape functions", () => {
	test("empty ident", () => {
		expect(escapeIdent("")).toBe("⟨⟩");
	});

	test("numeric ident", () => {
		expect(escapeIdent("123")).toBe("⟨123⟩");
	});

	test("nderscore ident", () => {
		expect(escapeIdent("hello_world")).toBe("hello_world");
	});

	test("hyphenated ident", () => {
		expect(escapeIdent("hello-world")).toBe("⟨hello-world⟩");
	});

	test("bigint number", () => {
		expect(escapeNumber(9223372036854775807n)).toBe("9223372036854775807");
		expect(escapeNumber(9223372036854775808n)).toBe("⟨9223372036854775808⟩");
	});
});



================================================
FILE: packages/tests/unit/utilities/jsonify.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { jsonify } from "surrealdb";
import { createMockValue } from "../__helpers__";

describe("jsonify()", () => {
	test("match snapshot", () => {
		const json = jsonify(createMockValue());

		expect(json).toMatchSnapshot();
	});
});



================================================
FILE: packages/tests/unit/utilities/string-prefixes.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { StringRecordId, Uuid, d, r, s, u } from "surrealdb";

describe("string prefixes", () => {
	test("s", () => {
		expect(s`Hello World!`).toBe("Hello World!");
		expect(s`Hello ${"World"}!`).toBe("Hello World!");
		expect(s`Hello ${"World"}! ${123}`).toBe("Hello World! 123");
	});

	test("d", () => {
		expect(d`2024-09-18T13:27:42.050Z`).toMatchObject(
			new Date("2024-09-18T13:27:42.050Z"),
		);
	});

	test("r", () => {
		expect(r`person:123`).toMatchObject(new StringRecordId("person:123"));
	});

	test("u", () => {
		expect(u`3c467084-4ac4-4938-b26a-13cadf3ab7e9`).toMatchObject(
			new Uuid("3c467084-4ac4-4938-b26a-13cadf3ab7e9"),
		);
	});
});



================================================
FILE: packages/tests/unit/utilities/to-surql-string.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { toSurqlString } from "surrealdb";
import { createMockValue } from "../__helpers__";

describe("toSurqlString()", () => {
	test("match snapshot", () => {
		const string = toSurqlString(createMockValue());

		expect(string).toMatchSnapshot();
	});
});



================================================
FILE: packages/tests/unit/utilities/version.test.ts
================================================
import { describe, expect, test } from "bun:test";
import { isVersionSupported } from "surrealdb";
{{{
describe("isVersionSupported()", () => {
	test("1.0.0 should be unsupported", () => {
		expect(isVersionSupported("1.0.0")).toBe(false);
	});

	test("1.5.6 should be unsupported", () => {
		expect(isVersionSupported("1.5.6")).toBe(false);
	});

	test("2.0.0 should be supported", () => {
		expect(isVersionSupported("2.0.0")).toBe(true);
	});

	test("3.0.0 should be supported", () => {
		expect(isVersionSupported("3.0.0")).toBe(true);
	});

	test("3.99.99 should be supported", () => {
		expect(isVersionSupported("3.99.99")).toBe(true);
	});

	test("4.0.0 should be unsupported", () => {
		expect(isVersionSupported("4.0.0")).toBe(false);
	});
});



================================================
FILE: packages/tests/unit/utilities/__snapshots__/jsonify.test.ts.snap
================================================
// Bun Snapshot v1, https://goo.gl/fbAQLP

exports[`jsonify() match snapshot 1`] = `
{
  "date": "2024-05-06T17:44:57.085Z",
  "dec": "3.333333",
  "dur": "1d2h",
  "false": false,
  "float": 123.456,
  "geo": {
    "geometries": [
      {
        "coordinates": [
          1,
          2,
        ],
        "type": "Point",
      },
      {
        "coordinates": [
          [
            [
              [
                1,
                2,
              ],
              [
                3,
                4,
              ],
              [
                1,
                2,
              ],
            ],
            [
              [
                5,
                6,
              ],
              [
                7,
                8,
              ],
              [
                5,
                6,
              ],
            ],
          ],
        ],
        "type": "MultiPolygon",
      },
      {
        "coordinates": [
          [
            [
              1,
              2,
            ],
            [
              3,
              4,
            ],
            [
              1,
              2,
            ],
          ],
          [
            [
              5,
              6,
            ],
            [
              7,
              8,
            ],
            [
              5,
              6,
            ],
          ],
        ],
        "type": "Polygon",
      },
    ],
    "type": "GeometryCollection",
  },
  "id_almost_a_number": "⟨some:thing⟩:1e23",
  "id_is_a_number": "⟨some:thing⟩:123",
  "id_looks_like_number": "⟨some:thing⟩:⟨123⟩",
  "null": null,
  "num": 123,
  "range": "r"bla:a"..z",
  "range_unbounded": "..z",
  "rid": "⟨some:thing⟩:under_score",
  "rng_rid": "bla:a..z",
  "str_rid": "⟨some:thing⟩:under_score",
  "string": "I am a string",
  "tb": "⟨some super _ cool table⟩",
  "true": true,
  "uuid": "92b84bde-39c8-4b4b-92f7-626096d6c4d9",
}
`;



================================================
FILE: packages/tests/unit/utilities/__snapshots__/to-surql-string.test.ts.snap
================================================
// Bun Snapshot v1, https://goo.gl/fbAQLP

exports[`toSurqlString() match snapshot 1`] = `"{ "rid": r"⟨some:thing⟩:under_score", "id_looks_like_number": r"⟨some:thing⟩:⟨123⟩", "id_almost_a_number": r"⟨some:thing⟩:1e23", "id_is_a_number": r"⟨some:thing⟩:123", "str_rid": r"⟨some:thing⟩:under_score", "rng_rid": bla:a..z, "range": r"bla:a"..z, "range_unbounded": ..z, "dec": 3.333333 1d2h, "geo": { "type": s"GeometryCollection", "geometries": [ { "type": s"Point", "coordinates": [ 1, 2 ] }, { "type": s"MultiPolygon", "coordinates": [ [ [ [ 1, 2 ], [ 3, 4 ], [ 1, 2 ] ], [ [ 5, 6 ], [ 7, 8 ], [ 5, 6 ] ] ] ] }, { "type": s"Polygon", "coordinates": [ [ [ 1, 2 ], [ 3, 4 ], [ 1, 2 ] ], [ [ 5, 6 ], [ 7, 8 ], [ 5, 6 ] ] ] } ] }, "tb": ⟨some super _ cool table⟩, "uuid": u"92b84bde-39c8-4b4b-92f7-626096d6c4d9", "date": d"2024-05-06T17:44:57.085Z", "undef": NONE, "null": NULL, "num": 123, "float": 123.456, "true": true, "false": false, "string": s"I am a string" }"`;



================================================
FILE: packages/tests/unit/values/decimal.test.ts
================================================
import { describe, expect, test } from "bun:test";
import fc from "fast-check";
import { Decimal } from "surrealdb"; // adjust the import path as needed

describe("decimal", () => {
	test("parses and returns high-precision values", () => {
		const input =
			"12345678901234567890123456789012345678.87654321098765432109876543210987654321";
		const dec = new Decimal(input);
		expect(dec.toString()).toBe(input);
	});

	test("basic arithmetic", () => {
		const a = new Decimal("1.00000000000000000000000000000000000001");
		const b = new Decimal("2.00000000000000000000000000000000000002");
		expect(a.add(b).toString()).toBe(
			"3.00000000000000000000000000000000000003",
		);
		expect(b.sub(a).toString()).toBe(
			"1.00000000000000000000000000000000000001",
		);
		expect(a.mul(b).toString()).toBe(
			"2.0000000000000000000000000000000000000400000000000000000000000000000000000002",
		);
		expect(b.div(a).toFixed(0)).toBe("2");
	});

	test("additional arithmetic scenarios", () => {
		const cases = [
			{ a: "0", b: "1", add: "1", sub: "-1", mul: "0", div: "0", mod: "0" },
			{ a: "0", b: "-1", add: "-1", sub: "1", mul: "0", div: "0", mod: "0" },
			{
				a: "0",
				b: "0.1",
				add: "0.1",
				sub: "-0.1",
				mul: "0",
				div: "0",
				mod: "0",
			},
			{
				a: "1",
				b: "0.1",
				add: "1.1",
				sub: "0.9",
				mul: "0.1",
				div: "10",
				mod: "0",
			},
			{
				a: "-1",
				b: "0.1",
				add: "-0.9",
				sub: "-1.1",
				mul: "-0.1",
				div: "-10",
				mod: "0",
			},
			{
				a: "0.00000000000000000001",
				b: "1e-20",
				add: "0.00000000000000000002",
				sub: "0",
				mul: "0.0000000000000000000000000000000000000001",
				div: "1",
				mod: "0",
			},
			{
				a: "123456789.987654321",
				b: "1",
				add: "123456790.987654321",
				sub: "123456788.987654321",
				mul: "123456789.987654321",
				div: "123456789.987654321",
				mod: "0.987654321",
			},
			{
				a: "0.1",
				b: "0.2",
				add: "0.3",
				sub: "-0.1",
				mul: "0.02",
				div: "0.5",
				mod: "0.1",
			},
		];

		for (const { a, b, add, sub, mul, div, mod } of cases) {
			const A = new Decimal(a);
			const B = new Decimal(b);
			expect(A.add(B).toString()).toBe(add);
			expect(A.sub(B).toString()).toBe(sub);
			expect(A.mul(B).toString()).toBe(mul);
			expect(A.div(B).toString()).toBe(div);
			expect(A.mod(B).toString()).toBe(mod);
		}
	});

	test("modulo returns remainder", () => {
		const a = new Decimal("5.75");
		const b = new Decimal("2.5");
		expect(a.mod(b).toString()).toBe("0.75");
	});

	test("handles very small values", () => {
		const tiny = new Decimal("0.00000000000000000000000000000000000001");
		expect(tiny.toString()).toBe("0.00000000000000000000000000000000000001");
		const result = tiny.add(tiny);
		expect(result.toString()).toBe("0.00000000000000000000000000000000000002");
	});

	test("zero", () => {
		const zero = new Decimal("0");
		expect(zero.mul(new Decimal("1")).toString()).toBe("0");
	});

	test("serialization to JSON", () => {
		const d = new Decimal("123.456789");
		expect(JSON.stringify(d)).toBe('"123.456789"');
	});

	test("abs and neg", () => {
		const d = new Decimal("-42.5");
		expect(d.abs().toString()).toBe("42.5");
		expect(d.neg().toString()).toBe("42.5");
		expect(d.neg().neg().toString()).toBe("-42.5");
	});

	test("isZero and isNegative", () => {
		expect(new Decimal("0").isZero()).toBe(true);
		expect(new Decimal("0.000").isZero()).toBe(true);
		expect(new Decimal("-0.000").isZero()).toBe(true);
		expect(new Decimal("-1.23").isNegative()).toBe(true);
		expect(new Decimal("1.23").isNegative()).toBe(false);
	});

	test("compare", () => {
		const a = new Decimal("1.234");
		const b = new Decimal("1.23400");
		const c = new Decimal("1.235");
		expect(a.compare(b)).toBe(0);
		expect(a.compare(c)).toBe(-1);
		expect(c.compare(a)).toBe(1);
	});

	test("round", () => {
		expect(new Decimal("1.999").round(2).toFixed(2)).toBe("2.00");
		expect(new Decimal("1.994").round(2).toString()).toBe("1.99");
		expect(new Decimal("1.005").round(2).toString()).toBe("1.01");
		expect(new Decimal("-1.005").round(2).toString()).toBe("-1.01");
	});

	test("toFixed", () => {
		expect(new Decimal("1.2").toFixed(3)).toBe("1.200");
		expect(new Decimal("1.2345").toFixed(2)).toBe("1.23");
		expect(new Decimal("-1.005").toFixed(2)).toBe("-1.01");
	});

	test("toFloat, toBigInt, toParts", () => {
		const d = new Decimal("123.456");
		expect(d.toFloat()).toBeCloseTo(123.456);
		expect(d.toBigInt()).toBe(123n);
		expect(new Decimal("-1.99").toBigInt()).toBe(-2n);
		expect(d.toParts()).toEqual({ int: 123n, frac: 456n, scale: 3 });
	});

